
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2016, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE




pragma Warnings (Off, "is an internal GNAT unit");
with Ada.Strings.Wide_Wide_Unbounded.Aux;
use Ada.Strings.Wide_Wide_Unbounded.Aux;
pragma Warnings (On, "is an internal GNAT unit");

with System.Memory;

with GNATCOLL.Iconv;

with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Extensions;  use Langkit_Support.Extensions;
with Langkit_Support.Text;        use Langkit_Support.Text;

with GPR_Parser.Analysis;
use GPR_Parser.Analysis;
with GPR_Parser.AST;
use GPR_Parser.AST;

package body GPR_Parser.Analysis.C is

   function Value_Or_Empty (S : chars_ptr) return String
   --  If S is null, return an empty string. Return Value (S) otherwise.
   is (if S = Null_Ptr
       then ""
       else Value (S));

   Last_Exception : gpr_exception_Ptr := null
     with Thread_Local_Storage => True;

   ----------
   -- Free --
   ----------

   procedure Free (Address : System.Address) is
      procedure C_Free (Address : System.Address)
        with Import        => True,
             Convention    => C,
             External_Name => "free";
   begin
      C_Free (Address);
   end Free;

   -------------------------
   -- Analysis primitives --
   -------------------------

   function gpr_create_analysis_context
     (Charset : chars_ptr)
      return gpr_analysis_context
   is
   begin
      Clear_Last_Exception;

      return Wrap (Create (Value (Charset)));
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_analysis_context (System.Null_Address);
   end gpr_create_analysis_context;

   procedure gpr_destroy_analysis_context
     (Context : gpr_analysis_context)
   is
   begin
      Clear_Last_Exception;

      declare
         C : Analysis_Context := Unwrap (Context);
      begin
         Destroy (C);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_destroy_analysis_context;

   function gpr_get_analysis_unit_from_file
     (Context           : gpr_analysis_context;
      Filename, Charset : chars_ptr;
      Reparse           : int) return gpr_analysis_unit
   is
   begin
      Clear_Last_Exception;

      declare
         Ctx  : constant Analysis_Context := Unwrap (Context);
         Unit : constant Analysis_Unit := Get_From_File
           (Ctx,
            Value (Filename),
            Value_Or_Empty (Charset),
            Reparse /= 0);
      begin
         return Wrap (Unit);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_analysis_unit (System.Null_Address);
   end gpr_get_analysis_unit_from_file;

   function gpr_get_analysis_unit_from_buffer
     (Context           : gpr_analysis_context;
      Filename, Charset : chars_ptr;
      Buffer            : chars_ptr;
      Buffer_Size       : size_t) return gpr_analysis_unit
   is
   begin
      Clear_Last_Exception;

      declare
         Ctx : constant Analysis_Context := Unwrap (Context);
         Unit : Analysis_Unit;

         Buffer_Str : String (1 .. Positive (Buffer_Size));
         for Buffer_Str'Address use Convert (Buffer);
      begin
         Unit := Get_From_Buffer
           (Ctx,
            Value (Filename),
            Value_Or_Empty (Charset),
            Buffer_Str);
         return Wrap (Unit);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_analysis_unit (System.Null_Address);
   end gpr_get_analysis_unit_from_buffer;

   function gpr_remove_analysis_unit
     (Context  : gpr_analysis_context;
      Filename : chars_ptr) return int
   is
   begin
      Clear_Last_Exception;

      declare
         Ctx : constant Analysis_Context := Unwrap (Context);
      begin
         begin
            Remove (Ctx, Value (Filename));
         exception
            when Constraint_Error =>
               return 0;
         end;
         return 1;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_remove_analysis_unit;

   function gpr_unit_root (Unit : gpr_analysis_unit)
                                           return gpr_base_node
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         return Wrap (U.AST_Root);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_base_node (System.Null_Address);
   end gpr_unit_root;

   function gpr_unit_diagnostic_count
     (Unit : gpr_analysis_unit) return unsigned
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         return unsigned (U.Diagnostics.Length);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_unit_diagnostic_count;

   function gpr_unit_diagnostic
     (Unit         : gpr_analysis_unit;
      N            : unsigned;
      Diagnostic_P : gpr_diagnostic_Ptr) return int
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         if N < unsigned (U.Diagnostics.Length) then
            declare
               D_In  : Diagnostic renames U.Diagnostics (Natural (N));
               D_Out : gpr_diagnostic renames Diagnostic_P.all;
            begin
               D_Out.Sloc_Range := Wrap (D_In.Sloc_Range);
               D_Out.Message := Wrap (D_In.Message);
               return 1;
            end;
         else
            return 0;
         end if;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_unit_diagnostic;

   function gpr_unit_incref
     (Unit : gpr_analysis_unit) return gpr_analysis_unit
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         Inc_Ref (U);
         return Unit;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_analysis_unit (System.Null_Address);
   end gpr_unit_incref;

   procedure gpr_unit_decref (Unit : gpr_analysis_unit)
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         Dec_Ref (U);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_unit_decref;

   procedure gpr_unit_reparse_from_file
     (Unit : gpr_analysis_unit; Charset : chars_ptr)
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         Reparse (U, Value_Or_Empty (Charset));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_unit_reparse_from_file;

   procedure gpr_unit_reparse_from_buffer
     (Unit        : gpr_analysis_unit;
      Charset     : chars_ptr;
      Buffer      : chars_ptr;
      Buffer_Size : size_t)
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
         Buffer_Str : String (1 .. Positive (Buffer_Size));
         for Buffer_Str'Address use Convert (Buffer);
      begin
         Reparse (U, Value_Or_Empty (Charset), Buffer_Str);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_unit_reparse_from_buffer;

   procedure gpr_unit_populate_lexical_env
     (Unit : gpr_analysis_unit)
   is
   begin
      Clear_Last_Exception;

      declare
         U : constant Analysis_Unit := Unwrap (Unit);
      begin
         Populate_Lexical_Env (U);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_unit_populate_lexical_env;

   ---------------------------------
   -- General AST node primitives --
   ---------------------------------

   Node_Kind_Names : constant array (Positive range <>) of Text_Access :=
     (new Text_Type'(To_Text ("list"))
            , new Text_Type'(To_Text ("AbstractPresent"))
            , new Text_Type'(To_Text ("AttributeDecl"))
            , new Text_Type'(To_Text ("AttributeReference"))
            , new Text_Type'(To_Text ("CaseConstruction"))
            , new Text_Type'(To_Text ("CaseItem"))
            , new Text_Type'(To_Text ("CompilationUnit"))
            , new Text_Type'(To_Text ("EmptyDecl"))
            , new Text_Type'(To_Text ("Prefix"))
            , new Text_Type'(To_Text ("Identifier"))
            , new Text_Type'(To_Text ("NumLiteral"))
            , new Text_Type'(To_Text ("StringLiteral"))
            , new Text_Type'(To_Text ("ExprList"))
            , new Text_Type'(To_Text ("External"))
            , new Text_Type'(To_Text ("ExternalAsList"))
            , new Text_Type'(To_Text ("ExternalName"))
            , new Text_Type'(To_Text ("ExternalReference"))
            , new Text_Type'(To_Text ("OthersDesignator"))
            , new Text_Type'(To_Text ("PackageDecl"))
            , new Text_Type'(To_Text ("PackageExtension"))
            , new Text_Type'(To_Text ("PackageRenaming"))
            , new Text_Type'(To_Text ("PackageSpec"))
            , new Text_Type'(To_Text ("Project"))
            , new Text_Type'(To_Text ("ProjectDeclaration"))
            , new Text_Type'(To_Text ("ProjectExtension"))
            , new Text_Type'(To_Text ("ProjectQualifier"))
            , new Text_Type'(To_Text ("ProjectReference"))
            , new Text_Type'(To_Text ("QualifierNames"))
            , new Text_Type'(To_Text ("StringLiteralAt"))
            , new Text_Type'(To_Text ("TermList"))
            , new Text_Type'(To_Text ("TypedStringDecl"))
            , new Text_Type'(To_Text ("VariableDecl"))
            , new Text_Type'(To_Text ("VariableReference"))
            , new Text_Type'(To_Text ("WithDecl"))
      );

   function gpr_node_kind (Node : gpr_base_node)
      return gpr_node_kind_enum
   is
   begin
      Clear_Last_Exception;

      declare
         N : constant GPR_Node := Unwrap (Node);
      begin
         return gpr_node_kind_enum (Kind (N));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_node_kind_enum'First;
   end gpr_node_kind;

   function gpr_kind_name (Kind : gpr_node_kind_enum)
                                           return gpr_text
   is
   begin
      Clear_Last_Exception;

      declare
         Name : Text_Access renames Node_Kind_Names (Natural (Kind));
      begin
         return (Chars => Name.all'Address, Length => Name'Length);
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return (System.Null_Address, 0);
   end gpr_kind_name;

   procedure gpr_node_sloc_range
     (Node         : gpr_base_node;
      Sloc_Range_P : gpr_source_location_range_Ptr)
   is
   begin
      Clear_Last_Exception;

      declare
         N : constant GPR_Node := Unwrap (Node);
      begin
         Sloc_Range_P.all := Wrap (Sloc_Range (N));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
   end gpr_node_sloc_range;

   function gpr_lookup_in_node
     (Node : gpr_base_node;
      Sloc : gpr_source_location_Ptr) return gpr_base_node
   is
   begin
      Clear_Last_Exception;

      declare
         N : constant GPR_Node := Unwrap (Node);
         S : constant Source_Location := Unwrap (Sloc.all);
      begin
         return Wrap (Lookup (N, S));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return gpr_base_node (System.Null_Address);
   end gpr_lookup_in_node;

   function gpr_node_child_count (Node : gpr_base_node)
                                                  return unsigned
   is
   begin
      Clear_Last_Exception;

      declare
         N : constant GPR_Node := Unwrap (Node);
      begin
         return unsigned (Child_Count (N));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_node_child_count;

   function gpr_node_child
     (Node    : gpr_base_node;
      N       : unsigned;
      Child_P : gpr_base_node_Ptr) return int
   is
   begin
      Clear_Last_Exception;

      declare
         Nod    : constant GPR_Node := Unwrap (Node);
         Result : GPR_Node;
         Exists : Boolean;
      begin
         if N > unsigned (Natural'Last) then
            return 0;
         end if;
         Get_Child (Nod, Natural (N), Exists, Result);
         if Exists then
            Child_P.all := Wrap (Result);
            return 1;
         else
            return 0;
         end if;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_node_child;

   function gpr_token_text (Token : gpr_token)
                                            return gpr_text
   is
   begin
      Clear_Last_Exception;

      declare
         T : Langkit_Support.Tokens.Token renames Unwrap (Token).all;
      begin
         return (if T.Text = null
                 then (Chars => System.Null_Address, Length => 0)
                 else (Chars => T.Text.all'Address, Length => T.Text'Length));
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return (System.Null_Address, 0);
   end gpr_token_text;

   function gpr_text_to_locale_string
     (Text : gpr_text) return System.Address
   is
   begin
      Clear_Last_Exception;

      declare
         use GNATCOLL.Iconv;

         Input_Byte_Size : constant size_t := 4 * Text.Length;

         Output_Byte_Size : constant size_t := Input_Byte_Size + 1;
         --  Assuming no encoding will take more than 4 bytes per character, 4
         --  times the size of the input text plus one null byte should be
         --  enough to hold the result. This is a development helper anyway, so
         --  we don't have performance concerns.

         Result : constant System.Address := System.Memory.Alloc
           (System.Memory.size_t (Output_Byte_Size));
         --  Buffer we are going to return to the caller. We use
         --  System.Memory.Alloc so that users can call C's "free" function in
         --  order to free it.

         Input : String (1 .. Natural (Input_Byte_Size));
         for Input'Address use Text.Chars;

         Output : String (1 .. Natural (Output_Byte_Size));
         for Output'Address use Result;

         State                     : Iconv_T;
         Input_Index, Output_Index : Positive := 1;
         Status                    : Iconv_Result;

         From_Code : constant String :=
           (if System."=" (System.Default_Bit_Order, System.Low_Order_First)
            then UTF32LE
            else UTF32BE);

      begin
         --  GNATCOLL.Iconv raises Constraint_Error exceptions for empty
         --  strings, so handle them ourselves.

         if Input_Byte_Size = 0 then
            Output (1) := ASCII.NUL;
         end if;

         --  Encode to the locale. Don't bother with error checking...

         Set_Locale;
         State := Iconv_Open
           (To_Code         => Locale,
            From_Code       => From_Code,
            Transliteration => True,
            Ignore          => True);
         Iconv (State, Input, Input_Index, Output, Output_Index, Status);
         Iconv_Close (State);

         --  Don't forget the trailing NULL character to keep C programs happy
         Output (Output_Index) := ASCII.NUL;

         return Result;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return System.Null_Address;
   end gpr_text_to_locale_string;

   -------------------------
   -- Extensions handling --
   -------------------------

   function gpr_register_extension (Name : chars_ptr)
      return unsigned
   is
   begin
      Clear_Last_Exception;

      return unsigned (Register_Extension (Value (Name)));
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return 0;
   end gpr_register_extension;

   function gpr_node_extension
     (Node   : gpr_base_node;
      Ext_Id : unsigned;
      Dtor   : gpr_node_extension_destructor)
      return System.Address
   is
   begin
      Clear_Last_Exception;

      declare
         N  : constant GPR_Node := Unwrap (Node);
         ID : constant Extension_ID := Extension_Id (Ext_Id);
         D  : constant Extension_Destructor := Convert (Dtor);
      begin
         return Get_Extension (N, ID, D).all'Address;
      end;
   exception
      when Exc : others =>
         Set_Last_Exception (Exc);
         return System.Null_Address;
   end gpr_node_extension;

   ----------
   -- Wrap --
   ----------

   function Wrap (S : Unbounded_Wide_Wide_String) return gpr_text is
      Chars  : Big_Wide_Wide_String_Access;
      Length : Natural;
   begin
      Get_Wide_Wide_String (S, Chars, Length);
      return (Chars.all'Address, size_t (Length));
   end Wrap;

   ------------------------
   -- Set_Last_Exception --
   ------------------------

   procedure Set_Last_Exception (Exc  : Exception_Occurrence) is
   begin
      --  If it's the first time, allocate room for the exception information

      if Last_Exception = null then
         Last_Exception := new gpr_exception;

      --  If it is not the first time, free memory allocated for the last
      --  exception.

      elsif Last_Exception.Information /= Null_Ptr then
         Free (Last_Exception.Information);
      end if;

      Last_Exception.Information := New_String (Exception_Information (Exc));
   end Set_Last_Exception;

   --------------------------
   -- Clear_Last_Exception --
   --------------------------

   procedure Clear_Last_Exception is
   begin
      if Last_Exception /= null then
         Free (Last_Exception.Information);
      end if;
   end Clear_Last_Exception;

   function gpr_get_last_exception return gpr_exception_Ptr
   is
   begin
      if Last_Exception = null
         or else Last_Exception.Information = Null_Ptr
      then
         return null;
      else
         return Last_Exception;
      end if;
   end gpr_get_last_exception;

end GPR_Parser.Analysis.C;
