
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2016, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE











with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;
with Ada.Unchecked_Deallocation;

pragma Warnings (Off, "referenced");
with Adalog.Abstract_Relation;   use Adalog.Abstract_Relation;
with Adalog.Operations;          use Adalog.Operations;
with Adalog.Predicates;          use Adalog.Predicates;
with Adalog.Pure_Relations;      use Adalog.Pure_Relations;
with Adalog.Variadic_Operations; use Adalog.Variadic_Operations;

with Langkit_Support.Extensions; use Langkit_Support.Extensions;
with Langkit_Support.PP_Utils;   use Langkit_Support.PP_Utils;
with Langkit_Support.Relative_Get;
with Langkit_Support.Slocs;      use Langkit_Support.Slocs;
with Langkit_Support.Symbols;    use Langkit_Support.Symbols;

with GPR_Parser.Analysis.Internal;
pragma Warnings (On, "referenced");


package body GPR_Parser.AST.Types is

   use Eq_Node, Eq_Node.Raw_Impl;

   procedure Register_Destroyable is new
      Analysis_Interfaces.Register_Destroyable
        (AST_Envs.Lexical_Env_Type, AST_Envs.Lexical_Env, AST_Envs.Destroy);


   

   

   ---------
   -- Get --
   ---------

   function Get
     (T       : Env_Element_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Env_Element
   is
      function Absolute_Get
        (T : Env_Element_Array_Access; Index : Integer)
         return Env_Element
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Env_Element,
         Sequence_Type => Env_Element_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Env_Element;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Env_Element;
      else
         raise Property_Error with "out-of-bounds array access";
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Env_Element_Array_Access) return Env_Element_Array_Access is
      use Env_Element_Arrays;
      Ret : Env_Element_Array_Access := Create (Length (L) + Length (R));
   begin
      Ret.Items := (L.Items & R.Items);
      return Ret;
   end Concat;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Env_Element_Array_Access) is
   begin
      T.Ref_Count := T.Ref_Count + 1;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Env_Element_Array_Access) is
   begin
      if T = null then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;



   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   


   

   --
   --  Primitives for Abstract_Present
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Abstract_Present_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Abstract_Present;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Abstract_Present_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AbstractPresent";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Abstract_Present_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Abstract_Present_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Abstract_Present_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Abstract_Present_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Abstract_Present_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Abstract_Present_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for Attribute_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Attribute_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Attribute_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Attribute_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AttributeDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Attribute_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attr_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attr_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Index)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Attribute_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Attribute_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attr_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Attr_Index);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Expr);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Attribute_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attr_Name /= null
                  and then not Is_Empty_List (Node.F_Attr_Name)
               then
                  Put_Line (Level + 1, "attr_name:");
                  Node.F_Attr_Name.Print (Level + 2);
               end if;

               if Node.F_Attr_Index /= null
                  and then not Is_Empty_List (Node.F_Attr_Index)
               then
                  Put_Line (Level + 1, "attr_index:");
                  Node.F_Attr_Index.Print (Level + 2);
               end if;

               if Node.F_Expr /= null
                  and then not Is_Empty_List (Node.F_Expr)
               then
                  Put_Line (Level + 1, "expr:");
                  Node.F_Expr.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Attribute_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Attr_Name /= null then
               Destroy (Node.F_Attr_Name);
            end if;
            if Node.F_Attr_Index /= null then
               Destroy (Node.F_Attr_Index);
            end if;
            if Node.F_Expr /= null then
               Destroy (Node.F_Expr);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Attribute_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attr_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attr_Index /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Index),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Expr /= null then
               Lookup_Relative (GPR_Node (Node.F_Expr),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Attr_Name
        (Node : access Attribute_Decl_Type) return Identifier
      is
      begin
         return Node.F_Attr_Name;
      end F_Attr_Name;
      function F_Attr_Index
        (Node : access Attribute_Decl_Type) return GPR_Node
      is
      begin
         return Node.F_Attr_Index;
      end F_Attr_Index;
      function F_Expr
        (Node : access Attribute_Decl_Type) return Term_List
      is
      begin
         return Node.F_Expr;
      end F_Expr;


   


   

   --
   --  Primitives for Attribute_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Attribute_Reference_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Attribute_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Attribute_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AttributeReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Attribute_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attribute_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Index)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Attribute_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Attribute_Reference_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attribute_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Attribute_Index);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Attribute_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attribute_Name /= null
                  and then not Is_Empty_List (Node.F_Attribute_Name)
               then
                  Put_Line (Level + 1, "attribute_name:");
                  Node.F_Attribute_Name.Print (Level + 2);
               end if;

               if Node.F_Attribute_Index /= null
                  and then not Is_Empty_List (Node.F_Attribute_Index)
               then
                  Put_Line (Level + 1, "attribute_index:");
                  Node.F_Attribute_Index.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Attribute_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Attribute_Name /= null then
               Destroy (Node.F_Attribute_Name);
            end if;
            if Node.F_Attribute_Index /= null then
               Destroy (Node.F_Attribute_Index);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Attribute_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attribute_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attribute_Index /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Index),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Attribute_Name
        (Node : access Attribute_Reference_Type) return Identifier
      is
      begin
         return Node.F_Attribute_Name;
      end F_Attribute_Name;
      function F_Attribute_Index
        (Node : access Attribute_Reference_Type) return GPR_Node
      is
      begin
         return Node.F_Attribute_Index;
      end F_Attribute_Index;


   


   

   --
   --  Primitives for Builtin_Function_Call
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Builtin_Function_Call_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Builtin_Function_Call;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Builtin_Function_Call_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "BuiltinFunctionCall";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Builtin_Function_Call_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Function_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Function_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Parameters /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Parameters)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Builtin_Function_Call_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Builtin_Function_Call_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Function_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Parameters);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Builtin_Function_Call_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Function_Name /= null
                  and then not Is_Empty_List (Node.F_Function_Name)
               then
                  Put_Line (Level + 1, "function_name:");
                  Node.F_Function_Name.Print (Level + 2);
               end if;

               if Node.F_Parameters /= null
                  and then not Is_Empty_List (Node.F_Parameters)
               then
                  Put_Line (Level + 1, "parameters:");
                  Node.F_Parameters.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Builtin_Function_Call_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Function_Name /= null then
               Destroy (Node.F_Function_Name);
            end if;
            if Node.F_Parameters /= null then
               Destroy (Node.F_Parameters);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Builtin_Function_Call_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Function_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Function_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Parameters /= null then
               Lookup_Relative (GPR_Node (Node.F_Parameters),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Function_Name
        (Node : access Builtin_Function_Call_Type) return Identifier
      is
      begin
         return Node.F_Function_Name;
      end F_Function_Name;
      function F_Parameters
        (Node : access Builtin_Function_Call_Type) return Expr_List
      is
      begin
         return Node.F_Parameters;
      end F_Parameters;


   


   

   --
   --  Primitives for Case_Construction
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Case_Construction_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Case_Construction;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Case_Construction_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CaseConstruction";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Case_Construction_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Var_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Ref)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Items /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Items)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Case_Construction_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Case_Construction_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Var_Ref);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Items);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Case_Construction_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Var_Ref /= null
                  and then not Is_Empty_List (Node.F_Var_Ref)
               then
                  Put_Line (Level + 1, "var_ref:");
                  Node.F_Var_Ref.Print (Level + 2);
               end if;

               if Node.F_Items /= null
                  and then not Is_Empty_List (Node.F_Items)
               then
                  Put_Line (Level + 1, "items:");
                  Node.F_Items.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Case_Construction_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Var_Ref /= null then
               Destroy (Node.F_Var_Ref);
            end if;
            if Node.F_Items /= null then
               Destroy (Node.F_Items);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Case_Construction_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Var_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Items /= null then
               Lookup_Relative (GPR_Node (Node.F_Items),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Var_Ref
        (Node : access Case_Construction_Type) return Variable_Reference
      is
      begin
         return Node.F_Var_Ref;
      end F_Var_Ref;
      function F_Items
        (Node : access Case_Construction_Type) return List_Case_Item
      is
      begin
         return Node.F_Items;
      end F_Items;


   


   

   --
   --  Primitives for Case_Item
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Case_Item_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Case_Item;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Case_Item_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CaseItem";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Case_Item_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Choice /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Choice)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Case_Item_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Case_Item_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Choice);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Case_Item_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Choice /= null
                  and then not Is_Empty_List (Node.F_Choice)
               then
                  Put_Line (Level + 1, "choice:");
                  Node.F_Choice.Print (Level + 2);
               end if;

               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Case_Item_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Choice /= null then
               Destroy (Node.F_Choice);
            end if;
            if Node.F_Decls /= null then
               Destroy (Node.F_Decls);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Case_Item_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Choice /= null then
               Lookup_Relative (GPR_Node (Node.F_Choice),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Choice
        (Node : access Case_Item_Type) return List_GPR_Node
      is
      begin
         return Node.F_Choice;
      end F_Choice;
      function F_Decls
        (Node : access Case_Item_Type) return List_GPR_Node
      is
      begin
         return Node.F_Decls;
      end F_Decls;


   


   

   --
   --  Primitives for Compilation_Unit
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Compilation_Unit_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Compilation_Unit;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Compilation_Unit_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CompilationUnit";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Compilation_Unit_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Project /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Compilation_Unit_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Compilation_Unit_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Project);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Compilation_Unit_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Project /= null
                  and then not Is_Empty_List (Node.F_Project)
               then
                  Put_Line (Level + 1, "project:");
                  Node.F_Project.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Compilation_Unit_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Project /= null then
               Destroy (Node.F_Project);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Compilation_Unit_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Project /= null then
               Lookup_Relative (GPR_Node (Node.F_Project),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Project
        (Node : access Compilation_Unit_Type) return Project
      is
      begin
         return Node.F_Project;
      end F_Project;


   


   

   --
   --  Primitives for Empty_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Empty_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Empty_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Empty_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "EmptyDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Empty_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Empty_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Empty_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Empty_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Empty_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Empty_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for Expr
   --

   






   


   

   --
   --  Primitives for Prefix
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Prefix_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Prefix;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Prefix_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Prefix";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Prefix_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prefix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prefix)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Suffix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Suffix)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Prefix_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Prefix_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prefix);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Suffix);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Prefix_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prefix /= null
                  and then not Is_Empty_List (Node.F_Prefix)
               then
                  Put_Line (Level + 1, "prefix:");
                  Node.F_Prefix.Print (Level + 2);
               end if;

               if Node.F_Suffix /= null
                  and then not Is_Empty_List (Node.F_Suffix)
               then
                  Put_Line (Level + 1, "suffix:");
                  Node.F_Suffix.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Prefix_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Prefix /= null then
               Destroy (Node.F_Prefix);
            end if;
            if Node.F_Suffix /= null then
               Destroy (Node.F_Suffix);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Prefix_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prefix /= null then
               Lookup_Relative (GPR_Node (Node.F_Prefix),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Suffix /= null then
               Lookup_Relative (GPR_Node (Node.F_Suffix),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Prefix
        (Node : access Prefix_Type) return Expr
      is
      begin
         return Node.F_Prefix;
      end F_Prefix;
      function F_Suffix
        (Node : access Prefix_Type) return Expr
      is
      begin
         return Node.F_Suffix;
      end F_Suffix;


   


   

   --
   --  Primitives for Single_Tok_Node
   --

   




      function F_Tok
        (Node : access Single_Tok_Node_Type) return Token_Type
      is
      begin
         return Token (Node, Node.F_Tok);
      end F_Tok;


   


   

   --
   --  Primitives for Identifier
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Identifier_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Identifier;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Identifier_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Id";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Identifier_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Identifier_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Identifier_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Identifier_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Token (Node, Node.F_Tok)));


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Identifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Identifier_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for Num_Literal
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Num_Literal_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Num_Literal;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Num_Literal_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Num";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Num_Literal_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Num_Literal_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Num_Literal_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Num_Literal_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Token (Node, Node.F_Tok)));


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Num_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Num_Literal_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for String_Literal
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access String_Literal_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_String_Literal;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access String_Literal_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Str";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access String_Literal_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access String_Literal_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access String_Literal_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access String_Literal_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Token (Node, Node.F_Tok)));


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access String_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access String_Literal_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for Expr_List
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Expr_List_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Expr_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Expr_List_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ExprList";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Expr_List_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Exprs /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Exprs)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Expr_List_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Expr_List_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Exprs);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Expr_List_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Exprs /= null
                  and then not Is_Empty_List (Node.F_Exprs)
               then
                  Put_Line (Level + 1, "exprs:");
                  Node.F_Exprs.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Expr_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Exprs /= null then
               Destroy (Node.F_Exprs);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Expr_List_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Exprs /= null then
               Lookup_Relative (GPR_Node (Node.F_Exprs),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Exprs
        (Node : access Expr_List_Type) return List_Term_List
      is
      begin
         return Node.F_Exprs;
      end F_Exprs;


   


   

   --
   --  Primitives for Others_Designator
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Others_Designator_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Others_Designator;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Others_Designator_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "OthersDesignator";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Others_Designator_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Others_Designator_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Others_Designator_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Others_Designator_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Others_Designator_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Others_Designator_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   


   

   --
   --  Primitives for Package_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Spec /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Spec)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Spec);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;

               if Node.F_Pkg_Spec /= null
                  and then not Is_Empty_List (Node.F_Pkg_Spec)
               then
                  Put_Line (Level + 1, "pkg_spec:");
                  Node.F_Pkg_Spec.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Pkg_Name /= null then
               Destroy (Node.F_Pkg_Name);
            end if;
            if Node.F_Pkg_Spec /= null then
               Destroy (Node.F_Pkg_Spec);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Spec /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Spec),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Pkg_Name
        (Node : access Package_Decl_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;
      function F_Pkg_Spec
        (Node : access Package_Decl_Type) return GPR_Node
      is
      begin
         return Node.F_Pkg_Spec;
      end F_Pkg_Spec;


   


   

   --
   --  Primitives for Package_Extension
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Extension_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Extension;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Extension_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageExtension";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Extension_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Extension_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Extension_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Extension_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prj_Name /= null
                  and then not Is_Empty_List (Node.F_Prj_Name)
               then
                  Put_Line (Level + 1, "prj_name:");
                  Node.F_Prj_Name.Print (Level + 2);
               end if;

               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Prj_Name /= null then
               Destroy (Node.F_Prj_Name);
            end if;
            if Node.F_Pkg_Name /= null then
               Destroy (Node.F_Pkg_Name);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Extension_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prj_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Prj_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Prj_Name
        (Node : access Package_Extension_Type) return Identifier
      is
      begin
         return Node.F_Prj_Name;
      end F_Prj_Name;
      function F_Pkg_Name
        (Node : access Package_Extension_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;


   


   

   --
   --  Primitives for Package_Renaming
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Renaming_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Renaming;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Renaming_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageRenaming";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Renaming_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Renaming_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Renaming_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Renaming_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prj_Name /= null
                  and then not Is_Empty_List (Node.F_Prj_Name)
               then
                  Put_Line (Level + 1, "prj_name:");
                  Node.F_Prj_Name.Print (Level + 2);
               end if;

               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Renaming_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Prj_Name /= null then
               Destroy (Node.F_Prj_Name);
            end if;
            if Node.F_Pkg_Name /= null then
               Destroy (Node.F_Pkg_Name);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Renaming_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prj_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Prj_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Prj_Name
        (Node : access Package_Renaming_Type) return Identifier
      is
      begin
         return Node.F_Prj_Name;
      end F_Prj_Name;
      function F_Pkg_Name
        (Node : access Package_Renaming_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;


   


   

   --
   --  Primitives for Package_Spec
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Spec_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Spec;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Spec_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageSpec";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Spec_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Spec_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Spec_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Extension);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Spec_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Extension /= null
                  and then not Is_Empty_List (Node.F_Extension)
               then
                  Put_Line (Level + 1, "extension:");
                  Node.F_Extension.Print (Level + 2);
               end if;

               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;

               if Node.F_End_Name /= null
                  and then not Is_Empty_List (Node.F_End_Name)
               then
                  Put_Line (Level + 1, "end_name:");
                  Node.F_End_Name.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Spec_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Extension /= null then
               Destroy (Node.F_Extension);
            end if;
            if Node.F_Decls /= null then
               Destroy (Node.F_Decls);
            end if;
            if Node.F_End_Name /= null then
               Destroy (Node.F_End_Name);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Spec_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Extension /= null then
               Lookup_Relative (GPR_Node (Node.F_Extension),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_End_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_End_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Extension
        (Node : access Package_Spec_Type) return Package_Extension
      is
      begin
         return Node.F_Extension;
      end F_Extension;
      function F_Decls
        (Node : access Package_Spec_Type) return List_GPR_Node
      is
      begin
         return Node.F_Decls;
      end F_Decls;
      function F_End_Name
        (Node : access Package_Spec_Type) return Identifier
      is
      begin
         return Node.F_End_Name;
      end F_End_Name;


   


   

   --
   --  Primitives for Project
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Project";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Context_Clauses /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Context_Clauses)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Decl /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Decl)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Context_Clauses);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Project_Decl);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Context_Clauses /= null
                  and then not Is_Empty_List (Node.F_Context_Clauses)
               then
                  Put_Line (Level + 1, "context_clauses:");
                  Node.F_Context_Clauses.Print (Level + 2);
               end if;

               if Node.F_Project_Decl /= null
                  and then not Is_Empty_List (Node.F_Project_Decl)
               then
                  Put_Line (Level + 1, "project_decl:");
                  Node.F_Project_Decl.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Context_Clauses /= null then
               Destroy (Node.F_Context_Clauses);
            end if;
            if Node.F_Project_Decl /= null then
               Destroy (Node.F_Project_Decl);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Context_Clauses /= null then
               Lookup_Relative (GPR_Node (Node.F_Context_Clauses),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Project_Decl /= null then
               Lookup_Relative (GPR_Node (Node.F_Project_Decl),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Context_Clauses
        (Node : access Project_Type) return List_With_Decl
      is
      begin
         return Node.F_Context_Clauses;
      end F_Context_Clauses;
      function F_Project_Decl
        (Node : access Project_Type) return Project_Declaration
      is
      begin
         return Node.F_Project_Decl;
      end F_Project_Decl;


   


   

   --
   --  Primitives for Project_Declaration
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Declaration_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Declaration;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Declaration_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectDeclaration";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Declaration_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Declaration_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 5;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Declaration_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Project_Name);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Extension);
                     Exists := True;
                 when 4 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
                 when 5 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Declaration_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier /= null
                  and then not Is_Empty_List (Node.F_Qualifier)
               then
                  Put_Line (Level + 1, "qualifier:");
                  Node.F_Qualifier.Print (Level + 2);
               end if;

               if Node.F_Project_Name /= null
                  and then not Is_Empty_List (Node.F_Project_Name)
               then
                  Put_Line (Level + 1, "project_name:");
                  Node.F_Project_Name.Print (Level + 2);
               end if;

               if Node.F_Extension /= null
                  and then not Is_Empty_List (Node.F_Extension)
               then
                  Put_Line (Level + 1, "extension:");
                  Node.F_Extension.Print (Level + 2);
               end if;

               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;

               if Node.F_End_Name /= null
                  and then not Is_Empty_List (Node.F_End_Name)
               then
                  Put_Line (Level + 1, "end_name:");
                  Node.F_End_Name.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Declaration_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Qualifier /= null then
               Destroy (Node.F_Qualifier);
            end if;
            if Node.F_Project_Name /= null then
               Destroy (Node.F_Project_Name);
            end if;
            if Node.F_Extension /= null then
               Destroy (Node.F_Extension);
            end if;
            if Node.F_Decls /= null then
               Destroy (Node.F_Decls);
            end if;
            if Node.F_End_Name /= null then
               Destroy (Node.F_End_Name);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Declaration_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Project_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Project_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Extension /= null then
               Lookup_Relative (GPR_Node (Node.F_Extension),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_End_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_End_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Qualifier
        (Node : access Project_Declaration_Type) return Project_Qualifier
      is
      begin
         return Node.F_Qualifier;
      end F_Qualifier;
      function F_Project_Name
        (Node : access Project_Declaration_Type) return Expr
      is
      begin
         return Node.F_Project_Name;
      end F_Project_Name;
      function F_Extension
        (Node : access Project_Declaration_Type) return Project_Extension
      is
      begin
         return Node.F_Extension;
      end F_Extension;
      function F_Decls
        (Node : access Project_Declaration_Type) return List_GPR_Node
      is
      begin
         return Node.F_Decls;
      end F_Decls;
      function F_End_Name
        (Node : access Project_Declaration_Type) return Expr
      is
      begin
         return Node.F_End_Name;
      end F_End_Name;


   


   

   --
   --  Primitives for Project_Extension
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Extension_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Extension;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Extension_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectExtension";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Extension_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_All));

                 Append (Result, ", ");

                 if Node.F_Path_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Extension_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Extension_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Path_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Extension_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "is_all: "
                         & Image (Node.F_Is_All));
               if Node.F_Path_Name /= null
                  and then not Is_Empty_List (Node.F_Path_Name)
               then
                  Put_Line (Level + 1, "path_name:");
                  Node.F_Path_Name.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Path_Name /= null then
               Destroy (Node.F_Path_Name);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Extension_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Path_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Path_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Is_All
        (Node : access Project_Extension_Type) return Boolean
      is
      begin
         return Node.F_Is_All;
      end F_Is_All;
      function F_Path_Name
        (Node : access Project_Extension_Type) return String_Literal
      is
      begin
         return Node.F_Path_Name;
      end F_Path_Name;


   


   

   --
   --  Primitives for Project_Qualifier
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Qualifier_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Qualifier;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Qualifier_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectQualifier";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Qualifier_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Qualifier_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Qualifier_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Qualifier_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier /= null
                  and then not Is_Empty_List (Node.F_Qualifier)
               then
                  Put_Line (Level + 1, "qualifier:");
                  Node.F_Qualifier.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Qualifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Qualifier /= null then
               Destroy (Node.F_Qualifier);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Qualifier_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Qualifier
        (Node : access Project_Qualifier_Type) return GPR_Node
      is
      begin
         return Node.F_Qualifier;
      end F_Qualifier;


   


   

   --
   --  Primitives for Project_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Reference_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attr_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Reference_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attr_Ref);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attr_Ref /= null
                  and then not Is_Empty_List (Node.F_Attr_Ref)
               then
                  Put_Line (Level + 1, "attr_ref:");
                  Node.F_Attr_Ref.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Attr_Ref /= null then
               Destroy (Node.F_Attr_Ref);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attr_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Attr_Ref
        (Node : access Project_Reference_Type) return Attribute_Reference
      is
      begin
         return Node.F_Attr_Ref;
      end F_Attr_Ref;


   


   

   --
   --  Primitives for Qualifier_Names
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Qualifier_Names_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Qualifier_Names;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Qualifier_Names_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "QualifierNames";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Qualifier_Names_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier_Id1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Qualifier_Id2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id2)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Qualifier_Names_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Qualifier_Names_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier_Id1);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Qualifier_Id2);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Qualifier_Names_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier_Id1 /= null
                  and then not Is_Empty_List (Node.F_Qualifier_Id1)
               then
                  Put_Line (Level + 1, "qualifier_id1:");
                  Node.F_Qualifier_Id1.Print (Level + 2);
               end if;

               if Node.F_Qualifier_Id2 /= null
                  and then not Is_Empty_List (Node.F_Qualifier_Id2)
               then
                  Put_Line (Level + 1, "qualifier_id2:");
                  Node.F_Qualifier_Id2.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Qualifier_Names_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Qualifier_Id1 /= null then
               Destroy (Node.F_Qualifier_Id1);
            end if;
            if Node.F_Qualifier_Id2 /= null then
               Destroy (Node.F_Qualifier_Id2);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Qualifier_Names_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier_Id1 /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier_Id1),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Qualifier_Id2 /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier_Id2),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Qualifier_Id1
        (Node : access Qualifier_Names_Type) return Identifier
      is
      begin
         return Node.F_Qualifier_Id1;
      end F_Qualifier_Id1;
      function F_Qualifier_Id2
        (Node : access Qualifier_Names_Type) return Identifier
      is
      begin
         return Node.F_Qualifier_Id2;
      end F_Qualifier_Id2;


   


   

   --
   --  Primitives for String_Literal_At
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access String_Literal_At_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_String_Literal_At;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access String_Literal_At_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "StringLiteralAt";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access String_Literal_At_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Str_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Str_Lit)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_At_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_At_Lit)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access String_Literal_At_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access String_Literal_At_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Str_Lit);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_At_Lit);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access String_Literal_At_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Str_Lit /= null
                  and then not Is_Empty_List (Node.F_Str_Lit)
               then
                  Put_Line (Level + 1, "str_lit:");
                  Node.F_Str_Lit.Print (Level + 2);
               end if;

               if Node.F_At_Lit /= null
                  and then not Is_Empty_List (Node.F_At_Lit)
               then
                  Put_Line (Level + 1, "at_lit:");
                  Node.F_At_Lit.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access String_Literal_At_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Str_Lit /= null then
               Destroy (Node.F_Str_Lit);
            end if;
            if Node.F_At_Lit /= null then
               Destroy (Node.F_At_Lit);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access String_Literal_At_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Str_Lit /= null then
               Lookup_Relative (GPR_Node (Node.F_Str_Lit),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_At_Lit /= null then
               Lookup_Relative (GPR_Node (Node.F_At_Lit),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Str_Lit
        (Node : access String_Literal_At_Type) return String_Literal
      is
      begin
         return Node.F_Str_Lit;
      end F_Str_Lit;
      function F_At_Lit
        (Node : access String_Literal_At_Type) return Num_Literal
      is
      begin
         return Node.F_At_Lit;
      end F_At_Lit;


   


   

   --
   --  Primitives for Term_List
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Term_List_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Term_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Term_List_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "TermList";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Term_List_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Terms /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Terms)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Term_List_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Term_List_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Terms);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Term_List_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Terms /= null
                  and then not Is_Empty_List (Node.F_Terms)
               then
                  Put_Line (Level + 1, "terms:");
                  Node.F_Terms.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Term_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Terms /= null then
               Destroy (Node.F_Terms);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Term_List_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Terms /= null then
               Lookup_Relative (GPR_Node (Node.F_Terms),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Terms
        (Node : access Term_List_Type) return List_GPR_Node
      is
      begin
         return Node.F_Terms;
      end F_Terms;


   


   

   --
   --  Primitives for Typed_String_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Typed_String_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Typed_String_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Typed_String_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "TypedStringDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Typed_String_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Type_Id /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Type_Id)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_String_Literals /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_String_Literals)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Typed_String_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Typed_String_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Type_Id);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_String_Literals);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Typed_String_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Type_Id /= null
                  and then not Is_Empty_List (Node.F_Type_Id)
               then
                  Put_Line (Level + 1, "type_id:");
                  Node.F_Type_Id.Print (Level + 2);
               end if;

               if Node.F_String_Literals /= null
                  and then not Is_Empty_List (Node.F_String_Literals)
               then
                  Put_Line (Level + 1, "string_literals:");
                  Node.F_String_Literals.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Typed_String_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Type_Id /= null then
               Destroy (Node.F_Type_Id);
            end if;
            if Node.F_String_Literals /= null then
               Destroy (Node.F_String_Literals);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Typed_String_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Type_Id /= null then
               Lookup_Relative (GPR_Node (Node.F_Type_Id),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_String_Literals /= null then
               Lookup_Relative (GPR_Node (Node.F_String_Literals),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Type_Id
        (Node : access Typed_String_Decl_Type) return Identifier
      is
      begin
         return Node.F_Type_Id;
      end F_Type_Id;
      function F_String_Literals
        (Node : access Typed_String_Decl_Type) return List_String_Literal
      is
      begin
         return Node.F_String_Literals;
      end F_String_Literals;


   


   

   --
   --  Primitives for Variable_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Variable_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Variable_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Variable_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "VariableDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Variable_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Var_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Var_Type /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Type)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Variable_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Variable_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Var_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Var_Type);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Expr);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Variable_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Var_Name /= null
                  and then not Is_Empty_List (Node.F_Var_Name)
               then
                  Put_Line (Level + 1, "var_name:");
                  Node.F_Var_Name.Print (Level + 2);
               end if;

               if Node.F_Var_Type /= null
                  and then not Is_Empty_List (Node.F_Var_Type)
               then
                  Put_Line (Level + 1, "var_type:");
                  Node.F_Var_Type.Print (Level + 2);
               end if;

               if Node.F_Expr /= null
                  and then not Is_Empty_List (Node.F_Expr)
               then
                  Put_Line (Level + 1, "expr:");
                  Node.F_Expr.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Variable_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Var_Name /= null then
               Destroy (Node.F_Var_Name);
            end if;
            if Node.F_Var_Type /= null then
               Destroy (Node.F_Var_Type);
            end if;
            if Node.F_Expr /= null then
               Destroy (Node.F_Expr);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Variable_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Var_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Var_Type /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Type),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Expr /= null then
               Lookup_Relative (GPR_Node (Node.F_Expr),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Var_Name
        (Node : access Variable_Decl_Type) return Identifier
      is
      begin
         return Node.F_Var_Name;
      end F_Var_Name;
      function F_Var_Type
        (Node : access Variable_Decl_Type) return Expr
      is
      begin
         return Node.F_Var_Type;
      end F_Var_Type;
      function F_Expr
        (Node : access Variable_Decl_Type) return Term_List
      is
      begin
         return Node.F_Expr;
      end F_Expr;


   


   

   --
   --  Primitives for Variable_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Variable_Reference_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Variable_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Variable_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "VariableReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Variable_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Variable_Name1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Variable_Name2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name2)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Variable_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Variable_Reference_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Variable_Name1);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Variable_Name2);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Attribute_Ref);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Variable_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Variable_Name1 /= null
                  and then not Is_Empty_List (Node.F_Variable_Name1)
               then
                  Put_Line (Level + 1, "variable_name1:");
                  Node.F_Variable_Name1.Print (Level + 2);
               end if;

               if Node.F_Variable_Name2 /= null
                  and then not Is_Empty_List (Node.F_Variable_Name2)
               then
                  Put_Line (Level + 1, "variable_name2:");
                  Node.F_Variable_Name2.Print (Level + 2);
               end if;

               if Node.F_Attribute_Ref /= null
                  and then not Is_Empty_List (Node.F_Attribute_Ref)
               then
                  Put_Line (Level + 1, "attribute_ref:");
                  Node.F_Attribute_Ref.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Variable_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Variable_Name1 /= null then
               Destroy (Node.F_Variable_Name1);
            end if;
            if Node.F_Variable_Name2 /= null then
               Destroy (Node.F_Variable_Name2);
            end if;
            if Node.F_Attribute_Ref /= null then
               Destroy (Node.F_Attribute_Ref);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Variable_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Variable_Name1 /= null then
               Lookup_Relative (GPR_Node (Node.F_Variable_Name1),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Variable_Name2 /= null then
               Lookup_Relative (GPR_Node (Node.F_Variable_Name2),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attribute_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Variable_Name1
        (Node : access Variable_Reference_Type) return Identifier
      is
      begin
         return Node.F_Variable_Name1;
      end F_Variable_Name1;
      function F_Variable_Name2
        (Node : access Variable_Reference_Type) return Identifier
      is
      begin
         return Node.F_Variable_Name2;
      end F_Variable_Name2;
      function F_Attribute_Ref
        (Node : access Variable_Reference_Type) return Attribute_Reference
      is
      begin
         return Node.F_Attribute_Ref;
      end F_Attribute_Ref;


   


   

   --
   --  Primitives for With_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access With_Decl_Type)
         return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_With_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access With_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "WithDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access With_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_Limited));

                 Append (Result, ", ");

                 if Node.F_Path_Names /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Names)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access With_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access With_Decl_Type;
                           Index  : Positive;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Path_Names);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access With_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "is_limited: "
                         & Image (Node.F_Is_Limited));
               if Node.F_Path_Names /= null
                  and then not Is_Empty_List (Node.F_Path_Names)
               then
                  Put_Line (Level + 1, "path_names:");
                  Node.F_Path_Names.Print (Level + 2);
               end if;


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access With_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
            if Node.F_Path_Names /= null then
               Destroy (Node.F_Path_Names);
            end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access With_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Path_Names /= null then
               Lookup_Relative (GPR_Node (Node.F_Path_Names),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;




      function F_Is_Limited
        (Node : access With_Decl_Type) return Boolean
      is
      begin
         return Node.F_Is_Limited;
      end F_Is_Limited;
      function F_Path_Names
        (Node : access With_Decl_Type) return List_String_Literal
      is
      begin
         return Node.F_Path_Names;
      end F_Path_Names;


   



   

   

   ---------
   -- Get --
   ---------

   function Get
     (Node    : List_Case_Item;
      Index   : Integer;
      Or_Null : Boolean := False) return Case_Item
   is
      function Absolute_Get
        (L : List_Case_Item; Index : Integer)
         return Case_Item
      is
        (Lists_Case_Item.Node_Vectors.Get_At_Index (L.Vec, Index + 1));
      --  L.Vec is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Case_Item,
         Sequence_Type => List_Case_Item,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Case_Item;
   begin
      if Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;


   

   

   ---------
   -- Get --
   ---------

   function Get
     (Node    : List_GPR_Node;
      Index   : Integer;
      Or_Null : Boolean := False) return GPR_Node
   is
      function Absolute_Get
        (L : List_GPR_Node; Index : Integer)
         return GPR_Node
      is
        (Lists_GPR_Node.Node_Vectors.Get_At_Index (L.Vec, Index + 1));
      --  L.Vec is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => GPR_Node,
         Sequence_Type => List_GPR_Node,
         Length        => Length,
         Get           => Absolute_Get);

      Result : GPR_Node;
   begin
      if Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;


   

   

   ---------
   -- Get --
   ---------

   function Get
     (Node    : List_String_Literal;
      Index   : Integer;
      Or_Null : Boolean := False) return String_Literal
   is
      function Absolute_Get
        (L : List_String_Literal; Index : Integer)
         return String_Literal
      is
        (Lists_String_Literal.Node_Vectors.Get_At_Index (L.Vec, Index + 1));
      --  L.Vec is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => String_Literal,
         Sequence_Type => List_String_Literal,
         Length        => Length,
         Get           => Absolute_Get);

      Result : String_Literal;
   begin
      if Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;


   

   

   ---------
   -- Get --
   ---------

   function Get
     (Node    : List_Term_List;
      Index   : Integer;
      Or_Null : Boolean := False) return Term_List
   is
      function Absolute_Get
        (L : List_Term_List; Index : Integer)
         return Term_List
      is
        (Lists_Term_List.Node_Vectors.Get_At_Index (L.Vec, Index + 1));
      --  L.Vec is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Term_List,
         Sequence_Type => List_Term_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Term_List;
   begin
      if Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;


   

   

   ---------
   -- Get --
   ---------

   function Get
     (Node    : List_With_Decl;
      Index   : Integer;
      Or_Null : Boolean := False) return With_Decl
   is
      function Absolute_Get
        (L : List_With_Decl; Index : Integer)
         return With_Decl
      is
        (Lists_With_Decl.Node_Vectors.Get_At_Index (L.Vec, Index + 1));
      --  L.Vec is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => With_Decl,
         Sequence_Type => List_With_Decl,
         Length        => Length,
         Get           => Absolute_Get);

      Result : With_Decl;
   begin
      if Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;



end GPR_Parser.AST.Types;
