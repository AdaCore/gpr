
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2016, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE











with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;

pragma Warnings (Off, "referenced");
with Langkit_Support.Extensions; use Langkit_Support.Extensions;
with Langkit_Support.PP_Utils;   use Langkit_Support.PP_Utils;
with Langkit_Support.Symbols;    use Langkit_Support.Symbols;
with Langkit_Support.Tokens;     use Langkit_Support.Tokens;
pragma Warnings (On, "referenced");

package body GPR_Parser.AST.Types is


   

   --
   --  Primitives for Abstract_Present
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Abstract_Present_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Abstract_Present_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Abstract_Present_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AbstractPresent";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Abstract_Present_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Abstract_Present_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Abstract_Present_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Abstract_Present_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Abstract_Present_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Abstract_Present_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for Attribute_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Attribute_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Attribute_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Attribute_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AttributeDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Attribute_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attr_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attr_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Index)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Attribute_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Attribute_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Attr_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Attr_Index);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Expr);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Attribute_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attr_Name /= null
                  and then not Is_Empty_List (Node.F_Attr_Name)
               then
                  Put_Line (Level + 1, "attr_name:");
                  Node.F_Attr_Name.Print (Level + 2);
               end if;
               if Node.F_Attr_Index /= null
                  and then not Is_Empty_List (Node.F_Attr_Index)
               then
                  Put_Line (Level + 1, "attr_index:");
                  Node.F_Attr_Index.Print (Level + 2);
               end if;
               if Node.F_Expr /= null
                  and then not Is_Empty_List (Node.F_Expr)
               then
                  Put_Line (Level + 1, "expr:");
                  Node.F_Expr.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Attribute_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Attr_Name /= null then
                  Destroy (Node.F_Attr_Name);
               end if;
               if Node.F_Attr_Index /= null then
                  Destroy (Node.F_Attr_Index);
               end if;
               if Node.F_Expr /= null then
                  Destroy (Node.F_Expr);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Attribute_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attr_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attr_Index /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Index),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Expr /= null then
               Lookup_Relative (GPR_Node (Node.F_Expr),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Attr_Name
        (Node : Attribute_Decl) return GPR_Node
      is
      begin
         return GPR_Node
           (Attribute_Decl_Type (Node.all).F_Attr_Name);
      end F_Attr_Name;
      function F_Attr_Index
        (Node : Attribute_Decl) return GPR_Node
      is
      begin
         return GPR_Node
           (Attribute_Decl_Type (Node.all).F_Attr_Index);
      end F_Attr_Index;
      function F_Expr
        (Node : Attribute_Decl) return Term_List
      is
      begin
         return Term_List
           (Attribute_Decl_Type (Node.all).F_Expr);
      end F_Expr;



   

   --
   --  Primitives for Attribute_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Attribute_Reference_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Attribute_Reference_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Attribute_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "AttributeReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Attribute_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attribute_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Index)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Attribute_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Attribute_Reference_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Attribute_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Attribute_Index);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Attribute_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attribute_Name /= null
                  and then not Is_Empty_List (Node.F_Attribute_Name)
               then
                  Put_Line (Level + 1, "attribute_name:");
                  Node.F_Attribute_Name.Print (Level + 2);
               end if;
               if Node.F_Attribute_Index /= null
                  and then not Is_Empty_List (Node.F_Attribute_Index)
               then
                  Put_Line (Level + 1, "attribute_index:");
                  Node.F_Attribute_Index.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Attribute_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Attribute_Name /= null then
                  Destroy (Node.F_Attribute_Name);
               end if;
               if Node.F_Attribute_Index /= null then
                  Destroy (Node.F_Attribute_Index);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Attribute_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attribute_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attribute_Index /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Index),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Attribute_Name
        (Node : Attribute_Reference) return Identifier
      is
      begin
         return Identifier
           (Attribute_Reference_Type (Node.all).F_Attribute_Name);
      end F_Attribute_Name;
      function F_Attribute_Index
        (Node : Attribute_Reference) return GPR_Node
      is
      begin
         return GPR_Node
           (Attribute_Reference_Type (Node.all).F_Attribute_Index);
      end F_Attribute_Index;



   

   --
   --  Primitives for Case_Construction
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Case_Construction_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Case_Construction_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Case_Construction_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CaseConstruction";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Case_Construction_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Var_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Ref)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Items /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Items)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Case_Construction_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Case_Construction_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Var_Ref);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Items);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Case_Construction_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Var_Ref /= null
                  and then not Is_Empty_List (Node.F_Var_Ref)
               then
                  Put_Line (Level + 1, "var_ref:");
                  Node.F_Var_Ref.Print (Level + 2);
               end if;
               if Node.F_Items /= null
                  and then not Is_Empty_List (Node.F_Items)
               then
                  Put_Line (Level + 1, "items:");
                  Node.F_Items.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Case_Construction_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Var_Ref /= null then
                  Destroy (Node.F_Var_Ref);
               end if;
               if Node.F_Items /= null then
                  Destroy (Node.F_Items);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Case_Construction_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Var_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Items /= null then
               Lookup_Relative (GPR_Node (Node.F_Items),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Var_Ref
        (Node : Case_Construction) return Variable_Reference
      is
      begin
         return Variable_Reference
           (Case_Construction_Type (Node.all).F_Var_Ref);
      end F_Var_Ref;
      function F_Items
        (Node : Case_Construction) return List_Case_Item
      is
      begin
         return List_Case_Item
           (Case_Construction_Type (Node.all).F_Items);
      end F_Items;



   

   --
   --  Primitives for Case_Item
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Case_Item_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Case_Item_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Case_Item_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CaseItem";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Case_Item_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Choice /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Choice)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Case_Item_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Case_Item_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Choice);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Case_Item_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Choice /= null
                  and then not Is_Empty_List (Node.F_Choice)
               then
                  Put_Line (Level + 1, "choice:");
                  Node.F_Choice.Print (Level + 2);
               end if;
               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Case_Item_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Choice /= null then
                  Destroy (Node.F_Choice);
               end if;
               if Node.F_Decls /= null then
                  Destroy (Node.F_Decls);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Case_Item_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Choice /= null then
               Lookup_Relative (GPR_Node (Node.F_Choice),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Choice
        (Node : Case_Item) return List_GPR_Node
      is
      begin
         return List_GPR_Node
           (Case_Item_Type (Node.all).F_Choice);
      end F_Choice;
      function F_Decls
        (Node : Case_Item) return List_GPR_Node
      is
      begin
         return List_GPR_Node
           (Case_Item_Type (Node.all).F_Decls);
      end F_Decls;



   

   --
   --  Primitives for Compilation_Unit
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Compilation_Unit_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Compilation_Unit_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Compilation_Unit_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "CompilationUnit";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Compilation_Unit_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Project /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Compilation_Unit_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Compilation_Unit_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Project);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Compilation_Unit_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Project /= null
                  and then not Is_Empty_List (Node.F_Project)
               then
                  Put_Line (Level + 1, "project:");
                  Node.F_Project.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Compilation_Unit_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Project /= null then
                  Destroy (Node.F_Project);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Compilation_Unit_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Project /= null then
               Lookup_Relative (GPR_Node (Node.F_Project),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Project
        (Node : Compilation_Unit) return Project
      is
      begin
         return Project
           (Compilation_Unit_Type (Node.all).F_Project);
      end F_Project;



   

   --
   --  Primitives for Empty_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Empty_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Empty_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Empty_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "EmptyDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Empty_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Empty_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Empty_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Empty_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Empty_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Empty_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for Expr
   --

   






   

   --
   --  Primitives for Prefix
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Prefix_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Prefix_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Prefix_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Prefix";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Prefix_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prefix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prefix)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Suffix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Suffix)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Prefix_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Prefix_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Prefix);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Suffix);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Prefix_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prefix /= null
                  and then not Is_Empty_List (Node.F_Prefix)
               then
                  Put_Line (Level + 1, "prefix:");
                  Node.F_Prefix.Print (Level + 2);
               end if;
               if Node.F_Suffix /= null
                  and then not Is_Empty_List (Node.F_Suffix)
               then
                  Put_Line (Level + 1, "suffix:");
                  Node.F_Suffix.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Prefix_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Prefix /= null then
                  Destroy (Node.F_Prefix);
               end if;
               if Node.F_Suffix /= null then
                  Destroy (Node.F_Suffix);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Prefix_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prefix /= null then
               Lookup_Relative (GPR_Node (Node.F_Prefix),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Suffix /= null then
               Lookup_Relative (GPR_Node (Node.F_Suffix),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Prefix
        (Node : Prefix) return Expr
      is
      begin
         return Expr
           (Prefix_Type (Node.all).F_Prefix);
      end F_Prefix;
      function F_Suffix
        (Node : Prefix) return Expr
      is
      begin
         return Expr
           (Prefix_Type (Node.all).F_Suffix);
      end F_Suffix;



   

   --
   --  Primitives for Single_Tok_Node
   --

   



      function F_Tok
        (Node : Single_Tok_Node) return Token
      is
      begin
         return Token
           (Single_Tok_Node_Type (Node.all).F_Tok);
      end F_Tok;



   

   --
   --  Primitives for Identifier
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Identifier_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Identifier_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Identifier_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Id";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Identifier_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Tok));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Identifier_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Identifier_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Identifier_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Node.F_Tok));

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Identifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Identifier_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for Num_Literal
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Num_Literal_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Num_Literal_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Num_Literal_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Num";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Num_Literal_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Tok));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Num_Literal_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Num_Literal_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Num_Literal_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Node.F_Tok));

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Num_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Num_Literal_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for String_Literal
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access String_Literal_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return String_Literal_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access String_Literal_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Str";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access String_Literal_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Tok));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access String_Literal_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access String_Literal_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access String_Literal_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "tok: "
                         & Image (Node.F_Tok));

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access String_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access String_Literal_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for Expr_List
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Expr_List_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Expr_List_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Expr_List_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ExprList";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Expr_List_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Exprs /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Exprs)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Expr_List_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Expr_List_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Exprs);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Expr_List_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Exprs /= null
                  and then not Is_Empty_List (Node.F_Exprs)
               then
                  Put_Line (Level + 1, "exprs:");
                  Node.F_Exprs.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Expr_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Exprs /= null then
                  Destroy (Node.F_Exprs);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Expr_List_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Exprs /= null then
               Lookup_Relative (GPR_Node (Node.F_Exprs),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Exprs
        (Node : Expr_List) return List_Term_List
      is
      begin
         return List_Term_List
           (Expr_List_Type (Node.all).F_Exprs);
      end F_Exprs;



   

   --
   --  Primitives for External
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access External_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return External_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access External_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "External";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access External_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access External_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access External_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access External_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access External_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access External_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for External_As_List
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access External_As_List_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return External_As_List_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access External_As_List_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ExternalAsList";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access External_As_List_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access External_As_List_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access External_As_List_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access External_As_List_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access External_As_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access External_As_List_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for External_Name
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access External_Name_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return External_Name_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access External_Name_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ExternalName";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access External_Name_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access External_Name_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access External_Name_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access External_Name_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access External_Name_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access External_Name_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for External_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access External_Reference_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return External_Reference_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access External_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ExternalReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access External_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Kind /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Kind)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_String_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_String_Lit)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access External_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access External_Reference_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Kind);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_String_Lit);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Expr);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access External_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Kind /= null
                  and then not Is_Empty_List (Node.F_Kind)
               then
                  Put_Line (Level + 1, "kind:");
                  Node.F_Kind.Print (Level + 2);
               end if;
               if Node.F_String_Lit /= null
                  and then not Is_Empty_List (Node.F_String_Lit)
               then
                  Put_Line (Level + 1, "string_lit:");
                  Node.F_String_Lit.Print (Level + 2);
               end if;
               if Node.F_Expr /= null
                  and then not Is_Empty_List (Node.F_Expr)
               then
                  Put_Line (Level + 1, "expr:");
                  Node.F_Expr.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access External_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Kind /= null then
                  Destroy (Node.F_Kind);
               end if;
               if Node.F_String_Lit /= null then
                  Destroy (Node.F_String_Lit);
               end if;
               if Node.F_Expr /= null then
                  Destroy (Node.F_Expr);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access External_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Kind /= null then
               Lookup_Relative (GPR_Node (Node.F_Kind),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_String_Lit /= null then
               Lookup_Relative (GPR_Node (Node.F_String_Lit),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Expr /= null then
               Lookup_Relative (GPR_Node (Node.F_Expr),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Kind
        (Node : External_Reference) return GPR_Node
      is
      begin
         return GPR_Node
           (External_Reference_Type (Node.all).F_Kind);
      end F_Kind;
      function F_String_Lit
        (Node : External_Reference) return String_Literal
      is
      begin
         return String_Literal
           (External_Reference_Type (Node.all).F_String_Lit);
      end F_String_Lit;
      function F_Expr
        (Node : External_Reference) return Term_List
      is
      begin
         return Term_List
           (External_Reference_Type (Node.all).F_Expr);
      end F_Expr;



   

   --
   --  Primitives for Others_Designator
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Others_Designator_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Others_Designator_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Others_Designator_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "OthersDesignator";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Others_Designator_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Others_Designator_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Others_Designator_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Others_Designator_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");


      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Others_Designator_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Others_Designator_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;

             pragma Unreferenced (Child);
             pragma Unreferenced (Pos);

      begin



         return Nod;
      end Lookup_Children;






   

   --
   --  Primitives for Package_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Package_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Spec /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Spec)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Pkg_Spec);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;
               if Node.F_Pkg_Spec /= null
                  and then not Is_Empty_List (Node.F_Pkg_Spec)
               then
                  Put_Line (Level + 1, "pkg_spec:");
                  Node.F_Pkg_Spec.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Pkg_Name /= null then
                  Destroy (Node.F_Pkg_Name);
               end if;
               if Node.F_Pkg_Spec /= null then
                  Destroy (Node.F_Pkg_Spec);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Spec /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Spec),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Pkg_Name
        (Node : Package_Decl) return Identifier
      is
      begin
         return Identifier
           (Package_Decl_Type (Node.all).F_Pkg_Name);
      end F_Pkg_Name;
      function F_Pkg_Spec
        (Node : Package_Decl) return GPR_Node
      is
      begin
         return GPR_Node
           (Package_Decl_Type (Node.all).F_Pkg_Spec);
      end F_Pkg_Spec;



   

   --
   --  Primitives for Package_Extension
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Extension_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Package_Extension_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Extension_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageExtension";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Extension_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Extension_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Extension_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Extension_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prj_Name /= null
                  and then not Is_Empty_List (Node.F_Prj_Name)
               then
                  Put_Line (Level + 1, "prj_name:");
                  Node.F_Prj_Name.Print (Level + 2);
               end if;
               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Prj_Name /= null then
                  Destroy (Node.F_Prj_Name);
               end if;
               if Node.F_Pkg_Name /= null then
                  Destroy (Node.F_Pkg_Name);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Extension_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prj_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Prj_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Prj_Name
        (Node : Package_Extension) return Identifier
      is
      begin
         return Identifier
           (Package_Extension_Type (Node.all).F_Prj_Name);
      end F_Prj_Name;
      function F_Pkg_Name
        (Node : Package_Extension) return Identifier
      is
      begin
         return Identifier
           (Package_Extension_Type (Node.all).F_Pkg_Name);
      end F_Pkg_Name;



   

   --
   --  Primitives for Package_Renaming
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Renaming_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Package_Renaming_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Renaming_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageRenaming";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Renaming_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Renaming_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Renaming_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Renaming_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Prj_Name /= null
                  and then not Is_Empty_List (Node.F_Prj_Name)
               then
                  Put_Line (Level + 1, "prj_name:");
                  Node.F_Prj_Name.Print (Level + 2);
               end if;
               if Node.F_Pkg_Name /= null
                  and then not Is_Empty_List (Node.F_Pkg_Name)
               then
                  Put_Line (Level + 1, "pkg_name:");
                  Node.F_Pkg_Name.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Renaming_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Prj_Name /= null then
                  Destroy (Node.F_Prj_Name);
               end if;
               if Node.F_Pkg_Name /= null then
                  Destroy (Node.F_Pkg_Name);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Renaming_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Prj_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Prj_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Pkg_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Pkg_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Prj_Name
        (Node : Package_Renaming) return Identifier
      is
      begin
         return Identifier
           (Package_Renaming_Type (Node.all).F_Prj_Name);
      end F_Prj_Name;
      function F_Pkg_Name
        (Node : Package_Renaming) return Identifier
      is
      begin
         return Identifier
           (Package_Renaming_Type (Node.all).F_Pkg_Name);
      end F_Pkg_Name;



   

   --
   --  Primitives for Package_Spec
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Package_Spec_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Package_Spec_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Package_Spec_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "PackageSpec";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Package_Spec_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Package_Spec_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Package_Spec_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Extension);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Package_Spec_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Extension /= null
                  and then not Is_Empty_List (Node.F_Extension)
               then
                  Put_Line (Level + 1, "extension:");
                  Node.F_Extension.Print (Level + 2);
               end if;
               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;
               if Node.F_End_Name /= null
                  and then not Is_Empty_List (Node.F_End_Name)
               then
                  Put_Line (Level + 1, "end_name:");
                  Node.F_End_Name.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Package_Spec_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Extension /= null then
                  Destroy (Node.F_Extension);
               end if;
               if Node.F_Decls /= null then
                  Destroy (Node.F_Decls);
               end if;
               if Node.F_End_Name /= null then
                  Destroy (Node.F_End_Name);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Package_Spec_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Extension /= null then
               Lookup_Relative (GPR_Node (Node.F_Extension),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_End_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_End_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Extension
        (Node : Package_Spec) return Package_Extension
      is
      begin
         return Package_Extension
           (Package_Spec_Type (Node.all).F_Extension);
      end F_Extension;
      function F_Decls
        (Node : Package_Spec) return List_GPR_Node
      is
      begin
         return List_GPR_Node
           (Package_Spec_Type (Node.all).F_Decls);
      end F_Decls;
      function F_End_Name
        (Node : Package_Spec) return Identifier
      is
      begin
         return Identifier
           (Package_Spec_Type (Node.all).F_End_Name);
      end F_End_Name;



   

   --
   --  Primitives for Project
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Project_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "Project";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Context_Clauses /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Context_Clauses)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Decl /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Decl)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Context_Clauses);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Project_Decl);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Context_Clauses /= null
                  and then not Is_Empty_List (Node.F_Context_Clauses)
               then
                  Put_Line (Level + 1, "context_clauses:");
                  Node.F_Context_Clauses.Print (Level + 2);
               end if;
               if Node.F_Project_Decl /= null
                  and then not Is_Empty_List (Node.F_Project_Decl)
               then
                  Put_Line (Level + 1, "project_decl:");
                  Node.F_Project_Decl.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Context_Clauses /= null then
                  Destroy (Node.F_Context_Clauses);
               end if;
               if Node.F_Project_Decl /= null then
                  Destroy (Node.F_Project_Decl);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Context_Clauses /= null then
               Lookup_Relative (GPR_Node (Node.F_Context_Clauses),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Project_Decl /= null then
               Lookup_Relative (GPR_Node (Node.F_Project_Decl),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Context_Clauses
        (Node : Project) return List_With_Decl
      is
      begin
         return List_With_Decl
           (Project_Type (Node.all).F_Context_Clauses);
      end F_Context_Clauses;
      function F_Project_Decl
        (Node : Project) return Project_Declaration
      is
      begin
         return Project_Declaration
           (Project_Type (Node.all).F_Project_Decl);
      end F_Project_Decl;



   

   --
   --  Primitives for Project_Declaration
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Declaration_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Project_Declaration_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Declaration_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectDeclaration";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Declaration_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Declaration_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 5;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Declaration_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Project_Name);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Extension);
                     Exists := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Decls);
                     Exists := True;
                 when 4 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Declaration_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier /= null
                  and then not Is_Empty_List (Node.F_Qualifier)
               then
                  Put_Line (Level + 1, "qualifier:");
                  Node.F_Qualifier.Print (Level + 2);
               end if;
               if Node.F_Project_Name /= null
                  and then not Is_Empty_List (Node.F_Project_Name)
               then
                  Put_Line (Level + 1, "project_name:");
                  Node.F_Project_Name.Print (Level + 2);
               end if;
               if Node.F_Extension /= null
                  and then not Is_Empty_List (Node.F_Extension)
               then
                  Put_Line (Level + 1, "extension:");
                  Node.F_Extension.Print (Level + 2);
               end if;
               if Node.F_Decls /= null
                  and then not Is_Empty_List (Node.F_Decls)
               then
                  Put_Line (Level + 1, "decls:");
                  Node.F_Decls.Print (Level + 2);
               end if;
               if Node.F_End_Name /= null
                  and then not Is_Empty_List (Node.F_End_Name)
               then
                  Put_Line (Level + 1, "end_name:");
                  Node.F_End_Name.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Declaration_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Qualifier /= null then
                  Destroy (Node.F_Qualifier);
               end if;
               if Node.F_Project_Name /= null then
                  Destroy (Node.F_Project_Name);
               end if;
               if Node.F_Extension /= null then
                  Destroy (Node.F_Extension);
               end if;
               if Node.F_Decls /= null then
                  Destroy (Node.F_Decls);
               end if;
               if Node.F_End_Name /= null then
                  Destroy (Node.F_End_Name);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Declaration_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Project_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Project_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Extension /= null then
               Lookup_Relative (GPR_Node (Node.F_Extension),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Decls /= null then
               Lookup_Relative (GPR_Node (Node.F_Decls),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_End_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_End_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Qualifier
        (Node : Project_Declaration) return Project_Qualifier
      is
      begin
         return Project_Qualifier
           (Project_Declaration_Type (Node.all).F_Qualifier);
      end F_Qualifier;
      function F_Project_Name
        (Node : Project_Declaration) return Expr
      is
      begin
         return Expr
           (Project_Declaration_Type (Node.all).F_Project_Name);
      end F_Project_Name;
      function F_Extension
        (Node : Project_Declaration) return Project_Extension
      is
      begin
         return Project_Extension
           (Project_Declaration_Type (Node.all).F_Extension);
      end F_Extension;
      function F_Decls
        (Node : Project_Declaration) return List_GPR_Node
      is
      begin
         return List_GPR_Node
           (Project_Declaration_Type (Node.all).F_Decls);
      end F_Decls;
      function F_End_Name
        (Node : Project_Declaration) return Expr
      is
      begin
         return Expr
           (Project_Declaration_Type (Node.all).F_End_Name);
      end F_End_Name;



   

   --
   --  Primitives for Project_Extension
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Extension_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Project_Extension_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Extension_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectExtension";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Extension_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_All));

                 Append (Result, ", ");

                 if Node.F_Path_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Extension_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Extension_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Path_Name);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Extension_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "is_all: "
                         & Image (Node.F_Is_All));
               if Node.F_Path_Name /= null
                  and then not Is_Empty_List (Node.F_Path_Name)
               then
                  Put_Line (Level + 1, "path_name:");
                  Node.F_Path_Name.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Path_Name /= null then
                  Destroy (Node.F_Path_Name);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Extension_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Path_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Path_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Is_All
        (Node : Project_Extension) return Boolean
      is
      begin
         return Boolean
           (Project_Extension_Type (Node.all).F_Is_All);
      end F_Is_All;
      function F_Path_Name
        (Node : Project_Extension) return String_Literal
      is
      begin
         return String_Literal
           (Project_Extension_Type (Node.all).F_Path_Name);
      end F_Path_Name;



   

   --
   --  Primitives for Project_Qualifier
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Qualifier_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Project_Qualifier_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Qualifier_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectQualifier";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Qualifier_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Qualifier_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Qualifier_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Qualifier_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier /= null
                  and then not Is_Empty_List (Node.F_Qualifier)
               then
                  Put_Line (Level + 1, "qualifier:");
                  Node.F_Qualifier.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Qualifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Qualifier /= null then
                  Destroy (Node.F_Qualifier);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Qualifier_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Qualifier
        (Node : Project_Qualifier) return GPR_Node
      is
      begin
         return GPR_Node
           (Project_Qualifier_Type (Node.all).F_Qualifier);
      end F_Qualifier;



   

   --
   --  Primitives for Project_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Project_Reference_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Project_Reference_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Project_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "ProjectReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Project_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Attr_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Project_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Project_Reference_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Attr_Ref);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Project_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Attr_Ref /= null
                  and then not Is_Empty_List (Node.F_Attr_Ref)
               then
                  Put_Line (Level + 1, "attr_ref:");
                  Node.F_Attr_Ref.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Project_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Attr_Ref /= null then
                  Destroy (Node.F_Attr_Ref);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Project_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Attr_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Attr_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Attr_Ref
        (Node : Project_Reference) return Attribute_Reference
      is
      begin
         return Attribute_Reference
           (Project_Reference_Type (Node.all).F_Attr_Ref);
      end F_Attr_Ref;



   

   --
   --  Primitives for Qualifier_Names
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Qualifier_Names_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Qualifier_Names_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Qualifier_Names_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "QualifierNames";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Qualifier_Names_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Qualifier_Id1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Qualifier_Id2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id2)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Qualifier_Names_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Qualifier_Names_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Qualifier_Id1);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier_Id2);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Qualifier_Names_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Qualifier_Id1 /= null
                  and then not Is_Empty_List (Node.F_Qualifier_Id1)
               then
                  Put_Line (Level + 1, "qualifier_id1:");
                  Node.F_Qualifier_Id1.Print (Level + 2);
               end if;
               if Node.F_Qualifier_Id2 /= null
                  and then not Is_Empty_List (Node.F_Qualifier_Id2)
               then
                  Put_Line (Level + 1, "qualifier_id2:");
                  Node.F_Qualifier_Id2.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Qualifier_Names_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Qualifier_Id1 /= null then
                  Destroy (Node.F_Qualifier_Id1);
               end if;
               if Node.F_Qualifier_Id2 /= null then
                  Destroy (Node.F_Qualifier_Id2);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Qualifier_Names_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Qualifier_Id1 /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier_Id1),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Qualifier_Id2 /= null then
               Lookup_Relative (GPR_Node (Node.F_Qualifier_Id2),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Qualifier_Id1
        (Node : Qualifier_Names) return Identifier
      is
      begin
         return Identifier
           (Qualifier_Names_Type (Node.all).F_Qualifier_Id1);
      end F_Qualifier_Id1;
      function F_Qualifier_Id2
        (Node : Qualifier_Names) return Identifier
      is
      begin
         return Identifier
           (Qualifier_Names_Type (Node.all).F_Qualifier_Id2);
      end F_Qualifier_Id2;



   

   --
   --  Primitives for String_Literal_At
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access String_Literal_At_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return String_Literal_At_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access String_Literal_At_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "StringLiteralAt";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access String_Literal_At_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Str_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Str_Lit)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_At_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_At_Lit)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access String_Literal_At_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access String_Literal_At_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Str_Lit);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_At_Lit);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access String_Literal_At_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Str_Lit /= null
                  and then not Is_Empty_List (Node.F_Str_Lit)
               then
                  Put_Line (Level + 1, "str_lit:");
                  Node.F_Str_Lit.Print (Level + 2);
               end if;
               if Node.F_At_Lit /= null
                  and then not Is_Empty_List (Node.F_At_Lit)
               then
                  Put_Line (Level + 1, "at_lit:");
                  Node.F_At_Lit.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access String_Literal_At_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Str_Lit /= null then
                  Destroy (Node.F_Str_Lit);
               end if;
               if Node.F_At_Lit /= null then
                  Destroy (Node.F_At_Lit);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access String_Literal_At_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Str_Lit /= null then
               Lookup_Relative (GPR_Node (Node.F_Str_Lit),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_At_Lit /= null then
               Lookup_Relative (GPR_Node (Node.F_At_Lit),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Str_Lit
        (Node : String_Literal_At) return String_Literal
      is
      begin
         return String_Literal
           (String_Literal_At_Type (Node.all).F_Str_Lit);
      end F_Str_Lit;
      function F_At_Lit
        (Node : String_Literal_At) return Num_Literal
      is
      begin
         return Num_Literal
           (String_Literal_At_Type (Node.all).F_At_Lit);
      end F_At_Lit;



   

   --
   --  Primitives for Term_List
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Term_List_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Term_List_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Term_List_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "TermList";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Term_List_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Terms /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Terms)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Term_List_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Term_List_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Terms);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Term_List_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Terms /= null
                  and then not Is_Empty_List (Node.F_Terms)
               then
                  Put_Line (Level + 1, "terms:");
                  Node.F_Terms.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Term_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Terms /= null then
                  Destroy (Node.F_Terms);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Term_List_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Terms /= null then
               Lookup_Relative (GPR_Node (Node.F_Terms),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Terms
        (Node : Term_List) return List_GPR_Node
      is
      begin
         return List_GPR_Node
           (Term_List_Type (Node.all).F_Terms);
      end F_Terms;



   

   --
   --  Primitives for Typed_String_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Typed_String_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Typed_String_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Typed_String_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "TypedStringDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Typed_String_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Type_Id /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Type_Id)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_String_Literals /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_String_Literals)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Typed_String_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Typed_String_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Type_Id);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_String_Literals);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Typed_String_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Type_Id /= null
                  and then not Is_Empty_List (Node.F_Type_Id)
               then
                  Put_Line (Level + 1, "type_id:");
                  Node.F_Type_Id.Print (Level + 2);
               end if;
               if Node.F_String_Literals /= null
                  and then not Is_Empty_List (Node.F_String_Literals)
               then
                  Put_Line (Level + 1, "string_literals:");
                  Node.F_String_Literals.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Typed_String_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Type_Id /= null then
                  Destroy (Node.F_Type_Id);
               end if;
               if Node.F_String_Literals /= null then
                  Destroy (Node.F_String_Literals);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Typed_String_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Type_Id /= null then
               Lookup_Relative (GPR_Node (Node.F_Type_Id),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_String_Literals /= null then
               Lookup_Relative (GPR_Node (Node.F_String_Literals),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Type_Id
        (Node : Typed_String_Decl) return Identifier
      is
      begin
         return Identifier
           (Typed_String_Decl_Type (Node.all).F_Type_Id);
      end F_Type_Id;
      function F_String_Literals
        (Node : Typed_String_Decl) return List_String_Literal
      is
      begin
         return List_String_Literal
           (Typed_String_Decl_Type (Node.all).F_String_Literals);
      end F_String_Literals;



   

   --
   --  Primitives for Variable_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Variable_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Variable_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Variable_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "VariableDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Variable_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Var_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Var_Type /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Type)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Variable_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Variable_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Var_Name);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Var_Type);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Expr);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Variable_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Var_Name /= null
                  and then not Is_Empty_List (Node.F_Var_Name)
               then
                  Put_Line (Level + 1, "var_name:");
                  Node.F_Var_Name.Print (Level + 2);
               end if;
               if Node.F_Var_Type /= null
                  and then not Is_Empty_List (Node.F_Var_Type)
               then
                  Put_Line (Level + 1, "var_type:");
                  Node.F_Var_Type.Print (Level + 2);
               end if;
               if Node.F_Expr /= null
                  and then not Is_Empty_List (Node.F_Expr)
               then
                  Put_Line (Level + 1, "expr:");
                  Node.F_Expr.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Variable_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Var_Name /= null then
                  Destroy (Node.F_Var_Name);
               end if;
               if Node.F_Var_Type /= null then
                  Destroy (Node.F_Var_Type);
               end if;
               if Node.F_Expr /= null then
                  Destroy (Node.F_Expr);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Variable_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Var_Name /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Name),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Var_Type /= null then
               Lookup_Relative (GPR_Node (Node.F_Var_Type),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Expr /= null then
               Lookup_Relative (GPR_Node (Node.F_Expr),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Var_Name
        (Node : Variable_Decl) return Identifier
      is
      begin
         return Identifier
           (Variable_Decl_Type (Node.all).F_Var_Name);
      end F_Var_Name;
      function F_Var_Type
        (Node : Variable_Decl) return Expr
      is
      begin
         return Expr
           (Variable_Decl_Type (Node.all).F_Var_Type);
      end F_Var_Type;
      function F_Expr
        (Node : Variable_Decl) return Term_List
      is
      begin
         return Term_List
           (Variable_Decl_Type (Node.all).F_Expr);
      end F_Expr;



   

   --
   --  Primitives for Variable_Reference
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access Variable_Reference_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return Variable_Reference_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access Variable_Reference_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "VariableReference";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access Variable_Reference_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");


                 if Node.F_Variable_Name1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Variable_Name2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name2)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access Variable_Reference_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access Variable_Reference_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Variable_Name1);
                     Exists := True;
                 when 1 =>
                     Result := GPR_Node (Node.F_Variable_Name2);
                     Exists := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Attribute_Ref);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access Variable_Reference_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               if Node.F_Variable_Name1 /= null
                  and then not Is_Empty_List (Node.F_Variable_Name1)
               then
                  Put_Line (Level + 1, "variable_name1:");
                  Node.F_Variable_Name1.Print (Level + 2);
               end if;
               if Node.F_Variable_Name2 /= null
                  and then not Is_Empty_List (Node.F_Variable_Name2)
               then
                  Put_Line (Level + 1, "variable_name2:");
                  Node.F_Variable_Name2.Print (Level + 2);
               end if;
               if Node.F_Attribute_Ref /= null
                  and then not Is_Empty_List (Node.F_Attribute_Ref)
               then
                  Put_Line (Level + 1, "attribute_ref:");
                  Node.F_Attribute_Ref.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access Variable_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Variable_Name1 /= null then
                  Destroy (Node.F_Variable_Name1);
               end if;
               if Node.F_Variable_Name2 /= null then
                  Destroy (Node.F_Variable_Name2);
               end if;
               if Node.F_Attribute_Ref /= null then
                  Destroy (Node.F_Attribute_Ref);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access Variable_Reference_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Variable_Name1 /= null then
               Lookup_Relative (GPR_Node (Node.F_Variable_Name1),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Variable_Name2 /= null then
               Lookup_Relative (GPR_Node (Node.F_Variable_Name2),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;

            if Node.F_Attribute_Ref /= null then
               Lookup_Relative (GPR_Node (Node.F_Attribute_Ref),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Variable_Name1
        (Node : Variable_Reference) return Identifier
      is
      begin
         return Identifier
           (Variable_Reference_Type (Node.all).F_Variable_Name1);
      end F_Variable_Name1;
      function F_Variable_Name2
        (Node : Variable_Reference) return Identifier
      is
      begin
         return Identifier
           (Variable_Reference_Type (Node.all).F_Variable_Name2);
      end F_Variable_Name2;
      function F_Attribute_Ref
        (Node : Variable_Reference) return Attribute_Reference
      is
      begin
         return Attribute_Reference
           (Variable_Reference_Type (Node.all).F_Attribute_Ref);
      end F_Attribute_Ref;



   

   --
   --  Primitives for With_Decl
   --

   


      ----------
      -- Kind --
      ----------

      overriding
      function Kind
        (Node : access With_Decl_Type)
         return GPR_Node_Type_Kind
      is
         pragma Unreferenced (Node);
      begin
         return With_Decl_Kind;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding
      function Kind_Name (Node : access With_Decl_Type) return String is
         pragma Unreferenced (Node);
      begin
         return "WithDecl";
      end Kind_Name;

      -----------
      -- Image --
      -----------

      overriding
      function Image (Node : access With_Decl_Type) return String is
         Result : Unbounded_String;
      begin
         Append (Result, Kind_Name (Node));
         Append (Result, '[');
         Append (Result, Image (Sloc_Range (GPR_Node (Node))));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_Limited));

                 Append (Result, ", ");

                 if Node.F_Path_Names /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Names)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding
      function Child_Count (Node : access With_Decl_Type) return Natural is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding
      procedure Get_Child (Node   : access With_Decl_Type;
                           Index  : Natural;
                           Exists : out Boolean;
                           Result : out GPR_Node) is
      begin
         case Index is
                 when 0 =>
                     Result := GPR_Node (Node.F_Path_Names);
                     Exists := True;
             when others =>
                Exists := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding
      procedure Print (Node  : access With_Decl_Type;
                       Level : Natural := 0)
      is
         Nod : constant GPR_Node :=
            GPR_Node (Node);
      begin
         Put_Line
           (Level, Kind_Name (Nod) & "[" & Image (Sloc_Range (Nod)) & "]");

               Put_Line (Level + 1, "is_limited: "
                         & Image (Node.F_Is_Limited));
               if Node.F_Path_Names /= null
                  and then not Is_Empty_List (Node.F_Path_Names)
               then
                  Put_Line (Level + 1, "path_names:");
                  Node.F_Path_Names.Print (Level + 2);
               end if;

      end Print;

      -------------
      -- Destroy --
      -------------

      overriding procedure Destroy
        (Node : access With_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
               if Node.F_Path_Names /= null then
                  Destroy (Node.F_Path_Names);
               end if;
         end if;
      end Destroy;

      ---------------------
      -- Lookup_Children --
      ---------------------

      overriding
      function Lookup_Children (Node : access With_Decl_Type;
                                Sloc : Source_Location;
                                Snap : Boolean := False)
        return GPR_Node
      is

         Nod : constant GPR_Node :=
            GPR_Node (Node);
         pragma Assert (Compare (Sloc_Range (Nod, Snap), Sloc) = Inside);

         Child : GPR_Node;
         Pos   : Relative_Position;


      begin


            if Node.F_Path_Names /= null then
               Lookup_Relative (GPR_Node (Node.F_Path_Names),
                                Sloc, Pos, Child, Snap);
               case Pos is
                  when Before =>
                      return Nod;

                  when Inside =>
                      return Child;

                  when After =>
                      null;
               end case;
            end if;


         return Nod;
      end Lookup_Children;



      function F_Is_Limited
        (Node : With_Decl) return Boolean
      is
      begin
         return Boolean
           (With_Decl_Type (Node.all).F_Is_Limited);
      end F_Is_Limited;
      function F_Path_Names
        (Node : With_Decl) return List_String_Literal
      is
      begin
         return List_String_Literal
           (With_Decl_Type (Node.all).F_Path_Names);
      end F_Path_Names;




end GPR_Parser.AST.Types;
