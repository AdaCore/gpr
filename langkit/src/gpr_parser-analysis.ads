
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2017, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE











with Ada.Containers.Hashed_Maps;
with Ada.Finalization;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Strings.Unbounded.Hash;
with Ada.Unchecked_Deallocation;

with System;

with Langkit_Support.Adalog.Abstract_Relation;
use Langkit_Support.Adalog.Abstract_Relation;
with Langkit_Support.Adalog.Eq_Same;

with Langkit_Support.Bump_Ptr;    use Langkit_Support.Bump_Ptr;
with Langkit_Support.Bump_Ptr.Vectors;
with Langkit_Support.Cheap_Sets;
with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Extensions;  use Langkit_Support.Extensions;
with Langkit_Support.Iterators;
with Langkit_Support.Lexical_Env;
with Langkit_Support.Slocs;       use Langkit_Support.Slocs;
with Langkit_Support.Symbols;     use Langkit_Support.Symbols;
with Langkit_Support.Text;        use Langkit_Support.Text;
with Langkit_Support.Tree_Traversal_Iterator;
with Langkit_Support.Vectors;

with GPR_Parser.Lexer; use GPR_Parser.Lexer;
use GPR_Parser.Lexer.Token_Data_Handlers;

--  This package provides types and primitives to analyze source files as
--  analysis units.
--
--  This is the entry point to parse and process an unit: first create an
--  analysis context with Create, then get analysis units out of it using
--  Get_From_File and/or Get_From_Buffer.

package GPR_Parser.Analysis is

   type Analysis_Context is private;
   --  Context for all source analysis.

   type Analysis_Unit is private;
   --  Context for the analysis of a single compilation unit. References are
   --  ref-counted.

   No_Analysis_Unit : constant Analysis_Unit;
   --  Special value to mean the absence of analysis unit. No analysis units
   --  can be passed this value.

   No_Analysis_Context : constant Analysis_Context;
   --  Special value to mean the absence of analysis unit. No analysis units
   --  can be passed this value.

   type Grammar_Rule is (
         Abstract_Present_Rule
            ,
         Associative_Array_Index_Rule
            ,
         Attribute_Decl_Rule
            ,
         Attribute_Reference_Rule
            ,
         Builtin_Function_Call_Rule
            ,
         Case_Construction_Rule
            ,
         Case_Item_Rule
            ,
         Choice_Rule
            ,
         Compilation_Unit_Rule
            ,
         Context_Clauses_Rule
            ,
         Declarative_Item_Rule
            ,
         Declarative_Items_Rule
            ,
         Discrete_Choice_List_Rule
            ,
         Empty_Declaration_Rule
            ,
         Expression_Rule
            ,
         Expression_List_Rule
            ,
         Identifier_Rule
            ,
         Num_Literal_Rule
            ,
         Others_Designator_Rule
            ,
         Package_Decl_Rule
            ,
         Package_Extension_Rule
            ,
         Package_Renaming_Rule
            ,
         Package_Spec_Rule
            ,
         Project_Rule
            ,
         Project_Declaration_Rule
            ,
         Project_Extension_Rule
            ,
         Project_Qualifier_Rule
            ,
         Project_Reference_Rule
            ,
         Qualifier_Names_Rule
            ,
         Simple_Declarative_Item_Rule
            ,
         Simple_Declarative_Items_Rule
            ,
         Static_Name_Rule
            ,
         String_Literal_Rule
            ,
         String_Literal_At_Rule
            ,
         Term_Rule
            ,
         Typed_String_Decl_Rule
            ,
         Variable_Decl_Rule
            ,
         Variable_Reference_Rule
            ,
         With_Decl_Rule
   );
   --  Gramar rule to use for parsing.

   type GPR_Node_Type is abstract tagged private;
   --  This "by-value" type is public to expose the fact that the various
   --  AST nodes are a hierarchy of tagged types, but it is not intended to be
   --  used directly, hence the "_Type" suffix. Please use instead the
   --  class-wide types such at the one below.

   type GPR_Node is access all GPR_Node_Type'Class;
   --  Most generic AST node type

   function Is_Null
     (Node : access GPR_Node_Type'Class) return Boolean;

   function Short_Image
     (Node : access GPR_Node_Type)
      return Text_Type;
   --  Return a short representation of the node, containing just the kind
   --  name and the sloc.

   Property_Error : exception;
   --  Raised when an error occurs while evaluating a property.

   type Token_Type is private;
   --  Reference to a token in an analysis unit.

   No_Token : constant Token_Type;

   Default_Charset : constant String := "utf-8";

   --------------------
   -- Unit providers --
   --------------------

   type Unit_Kind is (Unit_Specification, Unit_Body);
   --  Specify a kind of analysis unit. Specification units provide an
   --  interface to the outer world while body units provide an implementation
   --  for the corresponding interface.

   Invalid_Unit_Name_Error : exception;
   --  Raised when an invalid unit name is provided.

   type Unit_Provider_Interface is limited interface;
   type Unit_Provider_Access is
      access Unit_Provider_Interface'Class;
   type Unit_Provider_Access_Cst is
      access constant Unit_Provider_Interface'Class;
   --  Interface type for an object that can turn an analysis unit reference
   --  represented as an AST node into a file name. This is used get inter-unit
   --  analysis working.

   function Get_Unit
     (Provider    : Unit_Provider_Interface;
      Context     : Analysis_Context;
      Node        : GPR_Node;
      Kind        : Unit_Kind;
      Charset     : String := "";
      Reparse     : Boolean := False;
      With_Trivia : Boolean := False) return Analysis_Unit is abstract;
   --  Fetch and return the analysis unit referenced by the input AST node.
   --  Raise a Property_Error if Node is not a valid unit name representation.

   function Get_Unit
     (Provider    : Unit_Provider_Interface;
      Context     : Analysis_Context;
      Name        : Text_Type;
      Kind        : Unit_Kind;
      Charset     : String := "";
      Reparse     : Boolean := False;
      With_Trivia : Boolean := False) return Analysis_Unit is abstract;
   --  Fetch and return the analysis unit referenced by the input unit name.
   --  Raise a Property_Error if Name is not a valid unit name.

   procedure Destroy is new Ada.Unchecked_Deallocation
     (Unit_Provider_Interface'Class, Unit_Provider_Access);

   ---------------------------------
   -- Analysis context primitives --
   ---------------------------------

   function Create
     (Charset : String := Default_Charset
     ) return Analysis_Context;
   --  Create a new Analysis_Context. The returned value has a ref-count set to
   --  1. If you use shared ownership, use ref-counting primitives (Inc_Ref and
   --  Dec_Ref). Otherwise, just invoke Destroy when you are done with it: the
   --  ref-count will be ignored.
   --
   --  Charset will be used as a default charset to decode input sources in
   --  analysis units. Please see GNATCOLL.Iconv for a couple of supported
   --  charsets. Be careful: passing an unsupported charset here is not
   --  guaranteed to raise an error here.  If no charset is provided, take
   --  utf-8 as the default.
   --
   --  ??? Passing an unsupported charset here is not guaranteed to raise an
   --  error right here, but this would be really helpful for users.

   procedure Inc_Ref (Context : Analysis_Context);
   --  Increase the reference count to an analysis context.

   procedure Dec_Ref (Context : in out Analysis_Context);
   --  Decrease the reference count to an analysis context. Destruction happens
   --  when the ref-count reaches 0.

   function Get_From_File
     (Context     : Analysis_Context;
      Filename    : String;
      Charset     : String := "";
      Reparse     : Boolean := False;
      With_Trivia : Boolean := False;
      Rule        : Grammar_Rule :=
         Compilation_Unit_Rule)
      return Analysis_Unit;
   --  Create a new analysis unit for Filename or return the existing one if
   --  any. If Reparse is true and the analysis unit already exists, reparse it
   --  from Filename.
   --
   --  The result is owned by the context: the caller must increase its ref-
   --  count in order to keep a reference to it.
   --
   --  Rule controls which grammar rule is used to parse the unit.
   --
   --  ??? export this feature to the C and Python APIs.
   --
   --  Use Charset in order to decode the content of Filename. If Charset is
   --  empty then use the last charset used for this unit, or use the context's
   --  default if creating this unit.
   --
   --  If any failure occurs, such as file opening, decoding, lexing or parsing
   --  failure, return an analysis unit anyway: errors are described as
   --  diagnostics.
   --
   --  When With_Trivia is true, the parsed analysis unit will contain trivias.
   --  Already existing analysis units are reparsed if needed.

   function Get_From_Buffer
     (Context     : Analysis_Context;
      Filename    : String;
      Charset     : String := "";
      Buffer      : String;
      With_Trivia : Boolean := False;
      Rule        : Grammar_Rule :=
         Compilation_Unit_Rule)
      return Analysis_Unit;
   --  Create a new analysis unit for Filename or return the existing one if
   --  any. Whether the analysis unit already exists or not, (re)parse it from
   --  the source code in Buffer.
   --
   --  The result is owned by the context: the caller must increase its ref-
   --  count in order to keep a reference to it.
   --
   --  Use Charset in order to decode the content of Filename. If Charset is
   --  empty then use the last charset used for this unit, or use the context's
   --  default if creating this unit.
   --
   --  If any failure occurs, such as file opening, decoding, lexing or parsing
   --  failure, return an analysis unit anyway: errors are described as
   --  diagnostics of the returned analysis unit.
   --
   --  When With_Trivia is true, the parsed analysis unit will contain trivias.
   --  Already existing analysis units are reparsed if needed.

   function Has_Unit
     (Context       : Analysis_Context;
      Unit_Filename : String) return Boolean;
   --  Returns whether Context contains an unit correponding to Unit_Filename


   procedure Remove (Context   : Analysis_Context;
                     File_Name : String);
   --  Remove the corresponding analysis unit from this context. If someone
   --  still owns a reference to it, it remains available but becomes context-
   --  less.
   --
   --  If there is no such analysis unit, raise a Constraint_Error exception.

   procedure Destroy (Context : in out Analysis_Context);
   --  Invoke Remove on all the units Context contains and free Context. Thus,
   --  any analysis unit it contains may survive if there are still references
   --  to it elsewhere.

   procedure Inc_Ref (Unit : Analysis_Unit);
   --  Increase the reference count to an analysis unit.

   procedure Dec_Ref (Unit : Analysis_Unit);
   --  Decrease the reference count to an analysis unit.

   function Get_Context (Unit : Analysis_Unit) return Analysis_Context;
   --  Return the context that owns this unit.

   procedure Reparse (Unit : Analysis_Unit; Charset : String := "");
   --  Reparse an analysis unit from the associated file. If Charset is empty
   --  or null, use the last charset successfuly used for this unit, otherwise
   --  use it to decode the content of Filename.
   --
   --  If any failure occurs, such as decoding, lexing or parsing failure,
   --  diagnostic are emitted to explain what happened.

   procedure Reparse
     (Unit    : Analysis_Unit;
      Charset : String := "";
      Buffer  : String);
   --  Reparse an analysis unit from a buffer. If Charset is empty or null, use
   --  the last charset successfuly used for this unit, otherwise use it to
   --  decode the content of Filename.
   --
   --  If any failure occurs, such as decoding, lexing or parsing failure,
   --  diagnostic are emitted to explain what happened.

   procedure Populate_Lexical_Env (Unit : Analysis_Unit);
   --  Populate the lexical environments for this analysis unit, according to
   --  the specifications given in the language spec.
   --
   --  Raise a Property_Error on failure.

   function Get_Filename (Unit : Analysis_Unit) return String;
   --  Return the filename an unit is associated to.

   function Has_Diagnostics (Unit : Analysis_Unit) return Boolean;
   --  Return whether this unit has associated diagnostics.

   function Diagnostics (Unit : Analysis_Unit) return Diagnostics_Array;
   --  Return an array that contains the diagnostics associated to this unit.

   function Root (Unit : Analysis_Unit) return GPR_Node;
   --  Return the root AST node for this unit, or null if there is none.

   function First_Token (Unit : Analysis_Unit) return Token_Type;
   --  Return a reference to the first token scanned in this unit.

   function Last_Token (Unit : Analysis_Unit) return Token_Type;
   --  Return a reference to the last token scanned in this unit.

   function Token_Count (Unit : Analysis_Unit) return Natural;
   --  Return the number of tokens in this unit.

   function Trivia_Count (Unit : Analysis_Unit) return Natural;
   --  Return the number of trivias in this unit. This is 0 for units that were
   --  parsed with trivia analysis disabled.

   procedure Dump_Lexical_Env (Unit : Analysis_Unit);
   --  Debug helper: output the lexical envs for given analysis unit

   procedure Print (Unit : Analysis_Unit);
   --  Debug helper: output the AST and eventual diagnostic for this unit on
   --  standard output.

   procedure PP_Trivia (Unit : Analysis_Unit);
   --  Debug helper: output a minimal AST with mixed trivias

   procedure Reference_Unit (From, Referenced : Analysis_Unit);
   --  Set the Referenced unit as being referenced from the From unit. This is
   --  useful for visibility purposes, and is mainly meant to be used in the
   --  env hooks.

   ----------------
   -- Extensions --
   ----------------

   --  Extensions are a way to associate arbitrary data (Extension_Type, i.e.
   --  pointers) to AST nodes.
   --
   --  In order to associate an extension to an AST node, one has first to
   --  register itself in Langkit_Support.Extensions to get an Extension_ID.
   --  Then, this ID must be passed to Get_Extension, which will create a slot
   --  to store this extension (or return an already existing one for the same
   --  ID). It is this slot that can be used to store arbitrary data.
   --
   --  As AST nodes can be deallocated later on, this abritrary data sometimes
   --  needs to be deallocated as well. The destructor mechanism was designed
   --  for this: when the AST node is about to be deallocated, the destructor
   --  callback is invoked so that one has a chance to release allocated
   --  resources.

   type Extension_Type is new System.Address;
   --  Data type storing arbitrary values in AST nodes

   type Extension_Access is access all Extension_Type;
   --  Access to the arbitrary values stored in AST nodes

   type Extension_Destructor is
     access procedure (Node      : access GPR_Node_Type'Class;
                       Extension : Extension_Type)
     with Convention => C;
   --  Type for extension destructors. The parameter are the "Node" the
   --  extension was attached to and the "Extension" itself.

   function Get_Extension
     (Node : access GPR_Node_Type'Class;
      ID   : Extension_ID;
      Dtor : Extension_Destructor) return Extension_Access;
   --  Get (and create if needed) the extension corresponding to ID for Node.
   --  If the extension is created, the Dtor destructor is associated to it.
   --  Note that the returned access is not guaranteed to stay valid after
   --  subsequent calls to Get_Extension.

   ---------------------------
   -- Environments handling --
   ---------------------------

   --  The following types and operations are implementation details we did not
   --  manage yet to put in a private part. Please don't use them.

   

   type Metadata;
   


   

   


   type Metadata is record

         null;
   end record
     with Convention => C;
   No_Metadata : constant Metadata :=
   (null record);




   function Combine
     (L, R : Metadata) return Metadata;
   --  The combine function on environments metadata does a boolean Or on every
   --  boolean component of the env metadata.

   function Can_Reach (El, From : GPR_Node) return Boolean;
   --  Return whether El can reach From, from a sequential viewpoint. If
   --  elements are declared in different units, it will always return True,
   --  eg. this does not handle general visibility issues, just sequentiality of
   --  declarations.

   type Env_Getter_State_T is record
      Node : GPR_Node;
   end record;

   function Node_File_And_Sloc_Image
     (Node : GPR_Node) return Text_Type;
   --  Return a "sourcefile:lineno:columnno" corresponding to the starting sloc
   --  of Node. Used to create a human-readable representation for env.
   --  rebindings.

   package AST_Envs is new Langkit_Support.Lexical_Env
     (Element_T        => GPR_Node,
      Element_Metadata => Metadata,
      No_Element       => null,
      Empty_Metadata   => No_Metadata,
      Combine          => Combine,
      Getter_State_T   => Env_Getter_State_T,
      Element_Image    => Node_File_And_Sloc_Image);

   --  The following subtypes are introduced to ease code generation, so we
   --  don't have to deal with the AST_Envs suffix.

   subtype Lexical_Env is AST_Envs.Lexical_Env;
   subtype Entity_Info is AST_Envs.Entity_Info;
   subtype Entity is AST_Envs.Entity;
   subtype Env_Rebindings is AST_Envs.Env_Rebindings;
   Empty_Env : Lexical_Env renames AST_Envs.Empty_Env;
   No_Entity_Info : Entity_Info renames AST_Envs.No_Entity_Info;

   procedure Inc_Ref (E : Entity) renames AST_Envs.Inc_Ref;
   procedure Dec_Ref (E : in out Entity) renames AST_Envs.Dec_Ref;
   function Create
     (El : GPR_Node; Info : Entity_Info)
      return Entity;

   
   type Lexical_Env_Array_Record;
   type Lexical_Env_Array_Access is access all Lexical_Env_Array_Record;

   

   

   type Lexical_Env_Array
     is array (Positive range <>) of Lexical_Env;
   type Lexical_Env_Array_Record (N : Natural) is record
      Ref_Count : Positive;
      Items     : Lexical_Env_Array (1 .. N);
   end record;


   function Create (Items_Count : Natural) return Lexical_Env_Array_Access;
   --  Create a new array for N uninitialized elements and give its only
   --  ownership share to the caller.

   function Get
     (T       : Lexical_Env_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Lexical_Env;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based. If
   --  the result is ref-counted, a new owning reference is returned.

   function Concat (L, R : Lexical_Env_Array_Access) return Lexical_Env_Array_Access;

   function Length (T : Lexical_Env_Array_Access) return Natural;

   procedure Inc_Ref (T : Lexical_Env_Array_Access);
   procedure Dec_Ref (T : in out Lexical_Env_Array_Access);



   
   type Entity_Array_Record;
   type Entity_Array_Access is access all Entity_Array_Record;

   

   

   type Entity_Array
     is array (Positive range <>) of Entity;
   type Entity_Array_Record (N : Natural) is record
      Ref_Count : Positive;
      Items     : Entity_Array (1 .. N);
   end record;

   function Create (Items : AST_Envs.Entity_Array) return Entity_Array_Access;

   function Create (Items_Count : Natural) return Entity_Array_Access;
   --  Create a new array for N uninitialized elements and give its only
   --  ownership share to the caller.

   function Get
     (T       : Entity_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Entity;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based. If
   --  the result is ref-counted, a new owning reference is returned.

   function Concat (L, R : Entity_Array_Access) return Entity_Array_Access;

   function Length (T : Entity_Array_Access) return Natural;

   procedure Inc_Ref (T : Entity_Array_Access);
   procedure Dec_Ref (T : in out Entity_Array_Access);



   
   type GPR_Node_Array_Record;
   type GPR_Node_Array_Access is access all GPR_Node_Array_Record;

   

   

   type GPR_Node_Array
     is array (Positive range <>) of GPR_Node;
   type GPR_Node_Array_Record (N : Natural) is record
      Ref_Count : Positive;
      Items     : GPR_Node_Array (1 .. N);
   end record;


   function Create (Items_Count : Natural) return GPR_Node_Array_Access;
   --  Create a new array for N uninitialized elements and give its only
   --  ownership share to the caller.

   function Get
     (T       : GPR_Node_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return GPR_Node;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based. If
   --  the result is ref-counted, a new owning reference is returned.

   function Concat (L, R : GPR_Node_Array_Access) return GPR_Node_Array_Access;

   function Length (T : GPR_Node_Array_Access) return Natural;

   procedure Inc_Ref (T : GPR_Node_Array_Access);
   procedure Dec_Ref (T : in out GPR_Node_Array_Access);



   -----------------------------
   -- Miscellanous operations --
   -----------------------------

   type GPR_Node_Kind_Type is
     (GPR_Abstract_Present, GPR_Attribute_Decl, GPR_Attribute_Reference, GPR_Case_Item_List, GPR_GPR_Node_List, GPR_String_Literal_List, GPR_Term_List_List, GPR_With_Decl_List, GPR_Builtin_Function_Call, GPR_Case_Construction, GPR_Case_Item, GPR_Compilation_Unit, GPR_Empty_Decl, GPR_Prefix, GPR_Identifier, GPR_Num_Literal, GPR_String_Literal, GPR_Expr_List, GPR_Others_Designator, GPR_Package_Decl, GPR_Package_Extension, GPR_Package_Renaming, GPR_Package_Spec, GPR_Project, GPR_Project_Declaration, GPR_Project_Extension, GPR_Project_Qualifier, GPR_Project_Reference, GPR_Qualifier_Names, GPR_String_Literal_At, GPR_Term_List, GPR_Typed_String_Decl, GPR_Variable_Decl, GPR_Variable_Reference, GPR_With_Decl);
   --  AST node concrete types

   for GPR_Node_Kind_Type use
     (GPR_Abstract_Present => 1, GPR_Attribute_Decl => 2, GPR_Attribute_Reference => 3, GPR_Case_Item_List => 4, GPR_GPR_Node_List => 5, GPR_String_Literal_List => 6, GPR_Term_List_List => 7, GPR_With_Decl_List => 8, GPR_Builtin_Function_Call => 9, GPR_Case_Construction => 10, GPR_Case_Item => 11, GPR_Compilation_Unit => 12, GPR_Empty_Decl => 13, GPR_Prefix => 14, GPR_Identifier => 15, GPR_Num_Literal => 16, GPR_String_Literal => 17, GPR_Expr_List => 18, GPR_Others_Designator => 19, GPR_Package_Decl => 20, GPR_Package_Extension => 21, GPR_Package_Renaming => 22, GPR_Package_Spec => 23, GPR_Project => 24, GPR_Project_Declaration => 25, GPR_Project_Extension => 26, GPR_Project_Qualifier => 27, GPR_Project_Reference => 28, GPR_Qualifier_Names => 29, GPR_String_Literal_At => 30, GPR_Term_List => 31, GPR_Typed_String_Decl => 32, GPR_Variable_Decl => 33, GPR_Variable_Reference => 34, GPR_With_Decl => 35);

      
         subtype GPR_GPR_Node is
            GPR_Node_Kind_Type range
               GPR_Abstract_Present
               .. GPR_With_Decl;
      
      
      
      
         subtype GPR_Base_List is
            GPR_Node_Kind_Type range
               GPR_Case_Item_List
               .. GPR_With_Decl_List;
      
      
      
      
      
      
      
      
      
      
      
         subtype GPR_Expr is
            GPR_Node_Kind_Type range
               GPR_Prefix
               .. GPR_String_Literal;
      
      
         subtype GPR_Single_Tok_Node is
            GPR_Node_Kind_Type range
               GPR_Identifier
               .. GPR_String_Literal;
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

   function PP
     (Node : access GPR_Node_Type) return String
   is ("Pretty printer not generated");

   function Kind (Node : access GPR_Node_Type)
                  return GPR_Node_Kind_Type is abstract;
   function Kind_Name
     (Node : access GPR_Node_Type) return String is abstract;
   --  Return the concrete kind for Node

   function Is_Empty_List
     (Node : access GPR_Node_Type) return Boolean;
   --  Return whether Node is an empty list (so this is wrong for all nodes
   --  that are not lists).

   function Is_Ghost
     (Node : access GPR_Node_Type'Class) return Boolean;
   --  Return whether the node is a ghost node. In other words, return False if
   --  it correspondins to a real chain of tokens in the source, True
   --  otherwise.

   function Get_Unit
     (Node : access GPR_Node_Type'Class)
      return Analysis_Unit;

   --  Return the unit that owns an AST node.

   -------------------------------
   -- Tree traversal operations --
   -------------------------------

   function Child_Count (Node : access GPR_Node_Type)
                         return Natural is abstract;
   --  Return the number of children Node has

   function First_Child_Index
     (Node : access GPR_Node_Type'Class) return Natural;
   --  Return the index of the first child Node has

   function Last_Child_Index
     (Node : access GPR_Node_Type'Class) return Natural;
   --  Return the index of the last child Node has, or 0 if there is no child

   procedure Get_Child
     (Node            : access GPR_Node_Type;
      Index           : Positive;
      Index_In_Bounds : out Boolean;
      Result          : out GPR_Node) is abstract;
   --  Get the Index'th child of Node, storing it into Result. Child indexing
   --  is 1-based. Store in Index_In_Bounds whether Node had such a child; if
   --  not, the content of Result is undefined.

   function Child (Node  : access GPR_Node_Type'Class;
                   Index : Positive) return GPR_Node;
   --  Return the Index'th child of Node, or null if Node has no such child

   function Children
     (Node : access GPR_Node_Type'Class)
     return GPR_Node_Array;
   --  Return an array containing all the children of Node.
   --  This is an alternative to the Child/Child_Count pair, useful if you want
   --  the convenience of Ada arrays, and you don't care about the small
   --  performance hit of creating an array.

   function Parents
     (Node         : access GPR_Node_Type'Class;
      Include_Self : Boolean := True)
      return GPR_Node_Array_Access;
   --  Return the list of parents for this node. This node included in the list
   --  iff Include_Self.

   function Parent
     (Node : access GPR_Node_Type'Class)
     return GPR_Node;

   type Visit_Status is (Into, Over, Stop);
   --  Helper type to control the AST node traversal process. See Traverse.

   function Traverse
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class)
                               return Visit_Status)
     return Visit_Status;
   --  Given the parent node for a subtree, traverse all syntactic nodes of
   --  this tree, calling the given function on each node in pre order (ie.
   --  top-down). The order of traversing subtrees follows the order of
   --  declaration of the corresponding attributes in the grammar. The
   --  traversal is controlled as follows by the result returned by Visit:
   --
   --     Into   The traversal continues normally with the syntactic
   --            children of the node just processed.
   --
   --     Over   The children of the node just processed are skipped and
   --            excluded from the traversal, but otherwise processing
   --            continues elsewhere in the tree.
   --
   --     Stop   The entire traversal is immediately abandoned, and the
   --            original call to Traverse returns Stop.

   procedure Traverse
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class)
                               return Visit_Status);
   --  This is the same as Traverse function except that no result is returned
   --  i.e. the Traverse function is called and the result is simply discarded.

   generic
      type Data_Type is private;
      Reset_After_Traversal : Boolean := False;
   function Traverse_With_Data
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class;
                               Data : in out Data_type)
                               return Visit_Status;
      Data  : in out Data_Type)
      return Visit_Status;
   --  This is the same as the first Traverse function except it accepts an
   --  argument that is passed to all Visit calls.
   --
   --  If Reset_After_Traversal is True, the Data formal is left unchanged when
   --  Traverse_With_Data returns no matter what Visit does. Visit can change
   --  it otherwise.

   package GPR_Node_Iterators is new Langkit_Support.Iterators
     (Element_Type => GPR_Node);

   type Traverse_Iterator is
     limited new GPR_Node_Iterators.Iterator
     with private;

   function Traverse
     (Root : access GPR_Node_Type'Class)
      return Traverse_Iterator;
   --  Return an iterator that yields all AST nodes under Root (included) in a
   --  prefix DFS (depth first search) fasion.

   type GPR_Node_Predicate_Type is interface;
   type GPR_Node_Predicate is
      access all GPR_Node_Predicate_Type'Class;
   --  Predicate on AST nodes.
   --
   --  Useful predicates often rely on values from some context, so predicates
   --  that are mere accesses to a function are not powerful enough. Having a
   --  full interface for this makes it possible to package both the predicate
   --  code and some data it needs.

   function Evaluate
     (P : access GPR_Node_Predicate_Type;
      N : GPR_Node)
      return Boolean is abstract;
   --  Return the value of the predicate for the N node

   procedure Destroy is new Ada.Unchecked_Deallocation
     (GPR_Node_Predicate_Type'Class,
      GPR_Node_Predicate);

   type Find_Iterator is limited
     new GPR_Node_Iterators.Iterator
     with private;
   --  Iterator type for Find (see below)

   overriding function Next
     (It       : in out Find_Iterator;
      Element  : out GPR_Node) return Boolean;

   type Local_Find_Iterator is limited
      new GPR_Node_Iterators.Iterator
   with private;
   --  Iterator type for the Find function that takes an access to function. It
   --  is called Local_Find_Iterator because if you use a locally declared
   --  function, the iterator itself will only be valid in the scope of the
   --  function.

   overriding function Next
     (It      : in out Local_Find_Iterator;
      Element : out GPR_Node)
      return Boolean;

   function Find
     (Root      : access GPR_Node_Type'Class;
      Predicate : access function (N : GPR_Node) return Boolean)
      return Local_Find_Iterator;
   --  Return an iterator that yields all AST nodes under Root (included) that
   --  satisfy the Predicate predicate.

   function Find
     (Root      : access GPR_Node_Type'Class;
      Predicate : GPR_Node_Predicate)
      return Find_Iterator;
   --  Return an iterator that yields all AST nodes under Root (included) that
   --  satisfy the Predicate predicate. Predicate will be destroyed when
   --  Find_Iterator is exhausted.

   function Find_First
     (Root      : access GPR_Node_Type'Class;
      Predicate : GPR_Node_Predicate)
      return GPR_Node;
   --  Return the first found AST node under Root (included) that satisfies the
   --  Pred, or return null if there is no such node.

   type GPR_Node_Kind_Filter is
      new GPR_Node_Predicate_Type with
   record
      Kind : GPR_Node_Kind_Type;
   end record;
   --  Predicate that returns true for all AST nodes of some kind

   function Evaluate
     (P : access GPR_Node_Kind_Filter;
      N : GPR_Node)
      return Boolean;

   function Previous_Sibling
     (Node : access GPR_Node_Type'Class)
     return GPR_Node;
   --  Return the Node's previous sibling in the tree, if there is such a node

   function Next_Sibling
     (Node : access GPR_Node_Type'Class)
     return GPR_Node;
   --  Return the Node's next sibling in the tree, if there is such a node

   ----------------------------------------
   -- Source location-related operations --
   ----------------------------------------

   function Sloc_Range (Node : access GPR_Node_Type'Class;
                        Snap : Boolean := False) return Source_Location_Range;
   --  Return the source location range corresponding to the set of tokens from
   --  which Node was parsed.
   --
   --  TODO??? Document the Snap formal.

   function Compare (Node : access GPR_Node_Type'Class;
                     Sloc : Source_Location;
                     Snap : Boolean := False) return Relative_Position;
   --  Compare Sloc to the sloc range of Node.
   --
   --  TODO??? Document the Snap formal.

   function Lookup (Node : access GPR_Node_Type'Class;
                    Sloc : Source_Location;
                    Snap : Boolean := False) return GPR_Node;
   --  Look for the bottom-most AST node whose sloc range contains Sloc. Return
   --  it, or null if no such node was found.
   --
   --  TODO??? Document the Snap formal.

   -----------------------
   -- Lexical utilities --
   -----------------------

   type Token_Data_Type is private;

   function "<" (Left, Right : Token_Type) return Boolean;
   --  Assuming Left and Right belong to the same analysis unit, return whether
   --  Left came before Right in the source file.

   function Next (Token : Token_Type) return Token_Type;
   --  Return a reference to the next token in the corresponding analysis unit.

   function Previous (Token : Token_Type) return Token_Type;
   --  Return a reference to the previous token in the corresponding analysis
   --  unit.

   function Data (Token : Token_Type) return Token_Data_Type;
   --  Return the data associated to T

   function Is_Equivalent (L, R : Token_Type) return Boolean;
   --  Return whether L and R are structurally equivalent tokens. This means
   --  that their position in the stream won't be taken into account, only the
   --  kind and text of the token.

   function Image (Token : Token_Type) return String;
   --  Debug helper: return a human-readable text to represent a token

   function Text (Token : Token_Type) return Text_Type;
   --  Return the text of the token as Text_Type

   function Text (Token : Token_Type) return String;
   --  Return the text of the token as String

   function Text (First, Last : Token_Type) return Text_Type;
   --  Compute the source buffer slice corresponding to the text that spans
   --  between the First and Last tokens (both included). This yields an empty
   --  slice if Last actually appears before First.
   --
   --  This raises a Constraint_Error if First and Last don't belong to the
   --  same analysis unit.

   function Kind (Token_Data : Token_Data_Type) return Token_Kind
      with Inline;
   --  Kind for this token.

   function Is_Trivia (Token_Data : Token_Data_Type) return Boolean
      with Inline;
   --  Return whether this token is a trivia. If it's not, it's a regular
   --  token.

   function Index (Token_Data : Token_Data_Type) return Token_Index
      with Inline;
   --  One-based index for this token/trivia. Tokens and trivias get their own
   --  index space.

   function Sloc_Range
     (Token_Data : Token_Data_Type) return Source_Location_Range
      with Inline;
   --  Source location range for this token. Note that the end bound is
   --  exclusive.

   function Text
     (Node : access GPR_Node_Type'Class) return Text_Type;
   --  Shortcut to get the source buffer slice corresponding to the text that
   --  spans between the first and last tokens of an AST node.

   type Child_Or_Trivia is (Child, Trivia);
   --  Discriminator for the Child_Record type

   type Child_Record (Kind : Child_Or_Trivia := Child) is record
      case Kind is
         when Child =>
            Node : GPR_Node;
         when Trivia =>
            Trivia : Token_Type;
      end case;
   end record;
   --  Variant that holds either an AST node or a token

   type Children_Array is array (Positive range <>) of Child_Record;

   function Children_With_Trivia
     (Node : access GPR_Node_Type'Class) return Children_Array;
   --  Return the children of this node interleaved with Trivia token nodes, so
   --  that:
   --  - Every trivia contained between Node.Start_Token and Node.End_Token - 1
   --    will be part of the returned array;
   --  - Nodes and trivias will be lexically ordered.

   --------------------
   -- Token Iterator --
   --------------------

   type Token_Iterator is private
      with Iterable => (First       => First_Token,
                        Next        => Next_Token,
                        Has_Element => Has_Element,
                        Element     => Element);
   --  This type allows iteration on a range of tokens

   function First_Token (Self : Token_Iterator) return Token_Type;
   function Next_Token
     (Self : Token_Iterator; Tok : Token_Type) return Token_Type;
   function Has_Element
     (Self : Token_Iterator; Tok : Token_Type) return Boolean;
   function Element (Self : Token_Iterator; Tok : Token_Type) return Token_Type;

   function Token_Range
     (Node : access GPR_Node_Type'Class)
      return Token_Iterator;
   --  Return an iterator on the range of tokens encompassed by Node

   -------------------
   -- Debug helpers --
   -------------------

   function Image
     (Node : access GPR_Node_Type) return String is abstract;
   --  Debug helper: return a textual representation of this node and all its
   --  children.

   procedure Print (Node        : access GPR_Node_Type;
                    Line_Prefix : String := "") is abstract;
   --  Debug helper: print to standard output Node and all its children.
   --  Line_Prefix is prepended to each output line.

   procedure PP_Trivia
     (Node        : access GPR_Node_Type'Class;
      Line_Prefix : String := "");
   --  Debug helper: print to standard output Node and all its children along
   --  with the trivia associated to them. Line_Prefix is prepended to each
   --  output line.


   procedure Dump_Lexical_Env
     (Node     : access GPR_Node_Type'Class;
      Root_Env : AST_Envs.Lexical_Env);
   --  Debug helper: dump the lexical environment of Node, and consequently any
   --  nested lexical environment. Used for debugging/testing purpose. Pass the
   --  root env explicitly so that we can tag it properly in the output.

   procedure Dump_One_Lexical_Env
     (Self           : AST_Envs.Lexical_Env;
      Env_Id         : String := "";
      Parent_Env_Id  : String := "";
      Dump_Addresses : Boolean := False;
      Dump_Content   : Boolean := True);
   --  Debug helper: Dumps one lexical env. You can supply ids for env and its
   --  parent, so that they will be identified in the output.

   procedure Dump_Lexical_Env_Parent_Chain (Env : AST_Envs.Lexical_Env);
   --  Debug helper: dump a lexical env as all its parents

   procedure Assign_Names_To_Logic_Vars
     (Node : access GPR_Node_Type'Class);
   --  Debug helper: Assign names to every logical variable in the root node,
   --  so that we can trace logical variables.

   procedure Assign_Names_To_Logic_Vars_Impl
     (Node : access GPR_Node_Type) is null;

   ------------------------------------------------------
   -- AST node derived types (incomplete declarations) --
   ------------------------------------------------------

   type Base_List_Type;
   --  Base type for all lists of AST node subclasses

   type Base_List is
      access all Base_List_Type'Class;

       

   type Abstract_Present_Type;
   type Abstract_Present is access all Abstract_Present_Type'Class;
   


       

   type Attribute_Decl_Type;
   type Attribute_Decl is access all Attribute_Decl_Type'Class;
   


       

   type Attribute_Reference_Type;
   type Attribute_Reference is access all Attribute_Reference_Type'Class;
   


       

   type Builtin_Function_Call_Type;
   type Builtin_Function_Call is access all Builtin_Function_Call_Type'Class;
   


       

   type Case_Construction_Type;
   type Case_Construction is access all Case_Construction_Type'Class;
   


       

   type Case_Item_Type;
   type Case_Item is access all Case_Item_Type'Class;
   


       

   type Compilation_Unit_Type;
   type Compilation_Unit is access all Compilation_Unit_Type'Class;
   


       

   type Empty_Decl_Type;
   type Empty_Decl is access all Empty_Decl_Type'Class;
   


       

   type Expr_Type;
   type Expr is access all Expr_Type'Class;
   


       

   type Prefix_Type;
   type Prefix is access all Prefix_Type'Class;
   


       

   type Single_Tok_Node_Type;
   type Single_Tok_Node is access all Single_Tok_Node_Type'Class;
   


       

   type Identifier_Type;
   type Identifier is access all Identifier_Type'Class;
   


       

   type Num_Literal_Type;
   type Num_Literal is access all Num_Literal_Type'Class;
   


       

   type String_Literal_Type;
   type String_Literal is access all String_Literal_Type'Class;
   


       

   type Expr_List_Type;
   type Expr_List is access all Expr_List_Type'Class;
   


       

   type Others_Designator_Type;
   type Others_Designator is access all Others_Designator_Type'Class;
   


       

   type Package_Decl_Type;
   type Package_Decl is access all Package_Decl_Type'Class;
   


       

   type Package_Extension_Type;
   type Package_Extension is access all Package_Extension_Type'Class;
   


       

   type Package_Renaming_Type;
   type Package_Renaming is access all Package_Renaming_Type'Class;
   


       

   type Package_Spec_Type;
   type Package_Spec is access all Package_Spec_Type'Class;
   


       

   type Project_Type;
   type Project is access all Project_Type'Class;
   


       

   type Project_Declaration_Type;
   type Project_Declaration is access all Project_Declaration_Type'Class;
   


       

   type Project_Extension_Type;
   type Project_Extension is access all Project_Extension_Type'Class;
   


       

   type Project_Qualifier_Type;
   type Project_Qualifier is access all Project_Qualifier_Type'Class;
   


       

   type Project_Reference_Type;
   type Project_Reference is access all Project_Reference_Type'Class;
   


       

   type Qualifier_Names_Type;
   type Qualifier_Names is access all Qualifier_Names_Type'Class;
   


       

   type String_Literal_At_Type;
   type String_Literal_At is access all String_Literal_At_Type'Class;
   


       

   type Term_List_Type;
   type Term_List is access all Term_List_Type'Class;
   


       

   type Typed_String_Decl_Type;
   type Typed_String_Decl is access all Typed_String_Decl_Type'Class;
   


       

   type Variable_Decl_Type;
   type Variable_Decl is access all Variable_Decl_Type'Class;
   


       

   type Variable_Reference_Type;
   type Variable_Reference is access all Variable_Reference_Type'Class;
   


       

   type With_Decl_Type;
   type With_Decl is access all With_Decl_Type'Class;
   



         

   

   type Case_Item_List_Type;
   type Case_Item_List is
      access all Case_Item_List_Type'Class;


         

   

   type GPR_Node_List_Type;
   type GPR_Node_List is
      access all GPR_Node_List_Type'Class;


         

   

   type String_Literal_List_Type;
   type String_Literal_List is
      access all String_Literal_List_Type'Class;


         

   

   type Term_List_List_Type;
   type Term_List_List is
      access all Term_List_List_Type'Class;


         

   

   type With_Decl_List_Type;
   type With_Decl_List is
      access all With_Decl_List_Type'Class;



   ---------------------------
   -- Adalog instantiations --
   ---------------------------

   function Image (N : Entity) return String;

   package Eq_Node is new Langkit_Support.Adalog.Eq_Same
     (LR_Type       => Entity,
      Element_Image => Image,
      Inc_Ref       => AST_Envs.Inc_Ref,
      Dec_Ref       => AST_Envs.Dec_Ref);
   subtype Logic_Var is Eq_Node.Refs.Raw_Var;
   subtype Logic_Var_Record is Eq_Node.Refs.Var;
   Null_Var : constant Logic_Var := null;
   Null_Var_Record : constant Logic_Var_Record := (Reset => True, others => <>);

   subtype Logic_Equation is Relation;
   Null_Logic_Equation : constant Logic_Equation := null;

   -----------------------
   -- Enumeration types --
   -----------------------

   function Image (Value : Boolean) return String;


   -----------------------------------------------
   -- Structure types (incomplete declarations) --
   -----------------------------------------------


   -------------------------------------------
   -- Array types (incomplete declarations) --
   -------------------------------------------


   ------------------------------
   -- Root AST node properties --
   ------------------------------

      



 function Token_Start
   
  (Node :
   access GPR_Node_Type'Class

  )

   return Token_Type
   ;
--  Return the first token used to parse this node.



      



 function Token_End
   
  (Node :
   access GPR_Node_Type'Class

  )

   return Token_Type
   ;
--  Return the last token used to parse this node.




   -----------------------
   -- Generic list type --
   -----------------------

   type Base_List_Type is
      abstract new GPR_Node_Type
      with private;
   --  Base type for all lists of AST node subclasses

   overriding function Image
     (Node : access Base_List_Type) return String;

   overriding function Child_Count
     (Node : access Base_List_Type) return Natural;

   overriding procedure Get_Child
     (Node            : access Base_List_Type;
      Index           : Positive;
      Index_In_Bounds : out Boolean;
      Result          : out GPR_Node);

   overriding procedure Print
     (Node : access Base_List_Type; Line_Prefix : String := "");

   overriding function Is_Empty_List
     (Node : access Base_List_Type) return Boolean;

   -----------------------------------------
   -- Structure types (full declarations) --
   -----------------------------------------


   -----------------
   -- Array types --
   -----------------

   --  We implement array types as discriminated records so that binding to C
   --  can be done without copy.

   --  TODO??? This is likely to change in the near future: we would like to
   --  have here pure Ada arrays instead.


   ------------------------------------------------
   -- AST node derived types (full declarations) --
   ------------------------------------------------

   --  See above for overriden primitive operations documentations

       

   

   --
   --  Abstract_Present
   --

   type Abstract_Present_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Abstract_Present_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Abstract_Present_Type) return String;

         overriding function Image
           (Node : access Abstract_Present_Type) return String;

         overriding function Child_Count
           (Node : access Abstract_Present_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Abstract_Present_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Abstract_Present_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  Attribute_Decl
   --

   type Attribute_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Attribute_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Attribute_Decl_Type) return String;

         overriding function Image
           (Node : access Attribute_Decl_Type) return String;

         overriding function Child_Count
           (Node : access Attribute_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Attribute_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Attribute_Decl_Type;
            Line_Prefix : String := "");




      
   

   function F_Attr_Name
     (Node : access Attribute_Decl_Type) return Identifier;
   


      
   

   function F_Attr_Index
     (Node : access Attribute_Decl_Type) return GPR_Node;
   


      
   

   function F_Expr
     (Node : access Attribute_Decl_Type) return Term_List;
   




   


       

   

   --
   --  Attribute_Reference
   --

   type Attribute_Reference_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Attribute_Reference_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Attribute_Reference_Type) return String;

         overriding function Image
           (Node : access Attribute_Reference_Type) return String;

         overriding function Child_Count
           (Node : access Attribute_Reference_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Attribute_Reference_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Attribute_Reference_Type;
            Line_Prefix : String := "");




      
   

   function F_Attribute_Name
     (Node : access Attribute_Reference_Type) return Identifier;
   


      
   

   function F_Attribute_Index
     (Node : access Attribute_Reference_Type) return GPR_Node;
   




   


       

   

   --
   --  Builtin_Function_Call
   --

   type Builtin_Function_Call_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Builtin_Function_Call_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Builtin_Function_Call_Type) return String;

         overriding function Image
           (Node : access Builtin_Function_Call_Type) return String;

         overriding function Child_Count
           (Node : access Builtin_Function_Call_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Builtin_Function_Call_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Builtin_Function_Call_Type;
            Line_Prefix : String := "");




      
   

   function F_Function_Name
     (Node : access Builtin_Function_Call_Type) return Identifier;
   


      
   

   function F_Parameters
     (Node : access Builtin_Function_Call_Type) return Expr_List;
   




   


       

   

   --
   --  Case_Construction
   --

   type Case_Construction_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Case_Construction_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Case_Construction_Type) return String;

         overriding function Image
           (Node : access Case_Construction_Type) return String;

         overriding function Child_Count
           (Node : access Case_Construction_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Case_Construction_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Case_Construction_Type;
            Line_Prefix : String := "");




      
   

   function F_Var_Ref
     (Node : access Case_Construction_Type) return Variable_Reference;
   


      
   

   function F_Items
     (Node : access Case_Construction_Type) return Case_Item_List;
   




   


       

   

   --
   --  Case_Item
   --

   type Case_Item_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Case_Item_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Case_Item_Type) return String;

         overriding function Image
           (Node : access Case_Item_Type) return String;

         overriding function Child_Count
           (Node : access Case_Item_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Case_Item_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Case_Item_Type;
            Line_Prefix : String := "");




      
   

   function F_Choice
     (Node : access Case_Item_Type) return GPR_Node_List;
   


      
   

   function F_Decls
     (Node : access Case_Item_Type) return GPR_Node_List;
   




   


       

   

   --
   --  Compilation_Unit
   --

   type Compilation_Unit_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Compilation_Unit_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Compilation_Unit_Type) return String;

         overriding function Image
           (Node : access Compilation_Unit_Type) return String;

         overriding function Child_Count
           (Node : access Compilation_Unit_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Compilation_Unit_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Compilation_Unit_Type;
            Line_Prefix : String := "");




      
   

   function F_Project
     (Node : access Compilation_Unit_Type) return Project;
   




   


       

   

   --
   --  Empty_Decl
   --

   type Empty_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Empty_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Empty_Decl_Type) return String;

         overriding function Image
           (Node : access Empty_Decl_Type) return String;

         overriding function Child_Count
           (Node : access Empty_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Empty_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Empty_Decl_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  Expr
   --

   type Expr_Type is abstract
      new GPR_Node_Type with private;






   


       

   

   --
   --  Prefix
   --

   type Prefix_Type is 
      new Expr_Type with private;



      overriding function Kind
        (Node : access Prefix_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Prefix_Type) return String;

         overriding function Image
           (Node : access Prefix_Type) return String;

         overriding function Child_Count
           (Node : access Prefix_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Prefix_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Prefix_Type;
            Line_Prefix : String := "");




      
   

   function F_Prefix
     (Node : access Prefix_Type) return Expr;
   


      
   

   function F_Suffix
     (Node : access Prefix_Type) return Identifier;
   




   


       

   

   --
   --  Single_Tok_Node
   --

   type Single_Tok_Node_Type is abstract
      new Expr_Type with private;




      
   

   function F_Tok
     (Node : access Single_Tok_Node_Type) return Token_Type;
   




   


       

   

   --
   --  Identifier
   --

   type Identifier_Type is 
      new Single_Tok_Node_Type with private;



      overriding function Kind
        (Node : access Identifier_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Identifier_Type) return String;

         overriding function Image
           (Node : access Identifier_Type) return String;

         overriding function Child_Count
           (Node : access Identifier_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Identifier_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Identifier_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  Num_Literal
   --

   type Num_Literal_Type is 
      new Single_Tok_Node_Type with private;



      overriding function Kind
        (Node : access Num_Literal_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Num_Literal_Type) return String;

         overriding function Image
           (Node : access Num_Literal_Type) return String;

         overriding function Child_Count
           (Node : access Num_Literal_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Num_Literal_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Num_Literal_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  String_Literal
   --

   type String_Literal_Type is 
      new Single_Tok_Node_Type with private;



      overriding function Kind
        (Node : access String_Literal_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access String_Literal_Type) return String;

         overriding function Image
           (Node : access String_Literal_Type) return String;

         overriding function Child_Count
           (Node : access String_Literal_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access String_Literal_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access String_Literal_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  Expr_List
   --

   type Expr_List_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Expr_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Expr_List_Type) return String;

         overriding function Image
           (Node : access Expr_List_Type) return String;

         overriding function Child_Count
           (Node : access Expr_List_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Expr_List_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Expr_List_Type;
            Line_Prefix : String := "");




      
   

   function F_Exprs
     (Node : access Expr_List_Type) return Term_List_List;
   




   


       

   

   --
   --  Others_Designator
   --

   type Others_Designator_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Others_Designator_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Others_Designator_Type) return String;

         overriding function Image
           (Node : access Others_Designator_Type) return String;

         overriding function Child_Count
           (Node : access Others_Designator_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Others_Designator_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Others_Designator_Type;
            Line_Prefix : String := "");






   


       

   

   --
   --  Package_Decl
   --

   type Package_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Package_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Package_Decl_Type) return String;

         overriding function Image
           (Node : access Package_Decl_Type) return String;

         overriding function Child_Count
           (Node : access Package_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Package_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Package_Decl_Type;
            Line_Prefix : String := "");




      
   

   function F_Pkg_Name
     (Node : access Package_Decl_Type) return Identifier;
   


      
   

   function F_Pkg_Spec
     (Node : access Package_Decl_Type) return GPR_Node;
   




   


       

   

   --
   --  Package_Extension
   --

   type Package_Extension_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Package_Extension_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Package_Extension_Type) return String;

         overriding function Image
           (Node : access Package_Extension_Type) return String;

         overriding function Child_Count
           (Node : access Package_Extension_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Package_Extension_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Package_Extension_Type;
            Line_Prefix : String := "");




      
   

   function F_Prj_Name
     (Node : access Package_Extension_Type) return Identifier;
   


      
   

   function F_Pkg_Name
     (Node : access Package_Extension_Type) return Identifier;
   




   


       

   

   --
   --  Package_Renaming
   --

   type Package_Renaming_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Package_Renaming_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Package_Renaming_Type) return String;

         overriding function Image
           (Node : access Package_Renaming_Type) return String;

         overriding function Child_Count
           (Node : access Package_Renaming_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Package_Renaming_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Package_Renaming_Type;
            Line_Prefix : String := "");




      
   

   function F_Prj_Name
     (Node : access Package_Renaming_Type) return Identifier;
   


      
   

   function F_Pkg_Name
     (Node : access Package_Renaming_Type) return Identifier;
   




   


       

   

   --
   --  Package_Spec
   --

   type Package_Spec_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Package_Spec_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Package_Spec_Type) return String;

         overriding function Image
           (Node : access Package_Spec_Type) return String;

         overriding function Child_Count
           (Node : access Package_Spec_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Package_Spec_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Package_Spec_Type;
            Line_Prefix : String := "");




      
   

   function F_Extension
     (Node : access Package_Spec_Type) return Package_Extension;
   


      
   

   function F_Decls
     (Node : access Package_Spec_Type) return GPR_Node_List;
   


      
   

   function F_End_Name
     (Node : access Package_Spec_Type) return Identifier;
   




   


       

   

   --
   --  Project
   --

   type Project_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Project_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Project_Type) return String;

         overriding function Image
           (Node : access Project_Type) return String;

         overriding function Child_Count
           (Node : access Project_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Project_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Project_Type;
            Line_Prefix : String := "");




      
   

   function F_Context_Clauses
     (Node : access Project_Type) return With_Decl_List;
   


      
   

   function F_Project_Decl
     (Node : access Project_Type) return Project_Declaration;
   




   


       

   

   --
   --  Project_Declaration
   --

   type Project_Declaration_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Project_Declaration_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Project_Declaration_Type) return String;

         overriding function Image
           (Node : access Project_Declaration_Type) return String;

         overriding function Child_Count
           (Node : access Project_Declaration_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Project_Declaration_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Project_Declaration_Type;
            Line_Prefix : String := "");




      
   

   function F_Qualifier
     (Node : access Project_Declaration_Type) return Project_Qualifier;
   


      
   

   function F_Project_Name
     (Node : access Project_Declaration_Type) return Expr;
   


      
   

   function F_Extension
     (Node : access Project_Declaration_Type) return Project_Extension;
   


      
   

   function F_Decls
     (Node : access Project_Declaration_Type) return GPR_Node_List;
   


      
   

   function F_End_Name
     (Node : access Project_Declaration_Type) return Expr;
   




   


       

   

   --
   --  Project_Extension
   --

   type Project_Extension_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Project_Extension_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Project_Extension_Type) return String;

         overriding function Image
           (Node : access Project_Extension_Type) return String;

         overriding function Child_Count
           (Node : access Project_Extension_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Project_Extension_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Project_Extension_Type;
            Line_Prefix : String := "");




      
   

   function F_Is_All
     (Node : access Project_Extension_Type) return Boolean;
   


      
   

   function F_Path_Name
     (Node : access Project_Extension_Type) return String_Literal;
   




   


       

   

   --
   --  Project_Qualifier
   --

   type Project_Qualifier_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Project_Qualifier_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Project_Qualifier_Type) return String;

         overriding function Image
           (Node : access Project_Qualifier_Type) return String;

         overriding function Child_Count
           (Node : access Project_Qualifier_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Project_Qualifier_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Project_Qualifier_Type;
            Line_Prefix : String := "");




      
   

   function F_Qualifier
     (Node : access Project_Qualifier_Type) return GPR_Node;
   




   


       

   

   --
   --  Project_Reference
   --

   type Project_Reference_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Project_Reference_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Project_Reference_Type) return String;

         overriding function Image
           (Node : access Project_Reference_Type) return String;

         overriding function Child_Count
           (Node : access Project_Reference_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Project_Reference_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Project_Reference_Type;
            Line_Prefix : String := "");




      
   

   function F_Attr_Ref
     (Node : access Project_Reference_Type) return Attribute_Reference;
   




   


       

   

   --
   --  Qualifier_Names
   --

   type Qualifier_Names_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Qualifier_Names_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Qualifier_Names_Type) return String;

         overriding function Image
           (Node : access Qualifier_Names_Type) return String;

         overriding function Child_Count
           (Node : access Qualifier_Names_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Qualifier_Names_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Qualifier_Names_Type;
            Line_Prefix : String := "");




      
   

   function F_Qualifier_Id1
     (Node : access Qualifier_Names_Type) return Identifier;
   


      
   

   function F_Qualifier_Id2
     (Node : access Qualifier_Names_Type) return Identifier;
   




   


       

   

   --
   --  String_Literal_At
   --

   type String_Literal_At_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access String_Literal_At_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access String_Literal_At_Type) return String;

         overriding function Image
           (Node : access String_Literal_At_Type) return String;

         overriding function Child_Count
           (Node : access String_Literal_At_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access String_Literal_At_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access String_Literal_At_Type;
            Line_Prefix : String := "");




      
   

   function F_Str_Lit
     (Node : access String_Literal_At_Type) return String_Literal;
   


      
   

   function F_At_Lit
     (Node : access String_Literal_At_Type) return Num_Literal;
   




   


       

   

   --
   --  Term_List
   --

   type Term_List_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Term_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Term_List_Type) return String;

         overriding function Image
           (Node : access Term_List_Type) return String;

         overriding function Child_Count
           (Node : access Term_List_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Term_List_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Term_List_Type;
            Line_Prefix : String := "");




      
   

   function F_Terms
     (Node : access Term_List_Type) return GPR_Node_List;
   




   


       

   

   --
   --  Typed_String_Decl
   --

   type Typed_String_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Typed_String_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Typed_String_Decl_Type) return String;

         overriding function Image
           (Node : access Typed_String_Decl_Type) return String;

         overriding function Child_Count
           (Node : access Typed_String_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Typed_String_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Typed_String_Decl_Type;
            Line_Prefix : String := "");




      
   

   function F_Type_Id
     (Node : access Typed_String_Decl_Type) return Identifier;
   


      
   

   function F_String_Literals
     (Node : access Typed_String_Decl_Type) return String_Literal_List;
   




   


       

   

   --
   --  Variable_Decl
   --

   type Variable_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Variable_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Variable_Decl_Type) return String;

         overriding function Image
           (Node : access Variable_Decl_Type) return String;

         overriding function Child_Count
           (Node : access Variable_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Variable_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Variable_Decl_Type;
            Line_Prefix : String := "");




      
   

   function F_Var_Name
     (Node : access Variable_Decl_Type) return Identifier;
   


      
   

   function F_Var_Type
     (Node : access Variable_Decl_Type) return Expr;
   


      
   

   function F_Expr
     (Node : access Variable_Decl_Type) return Term_List;
   




   


       

   

   --
   --  Variable_Reference
   --

   type Variable_Reference_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access Variable_Reference_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Variable_Reference_Type) return String;

         overriding function Image
           (Node : access Variable_Reference_Type) return String;

         overriding function Child_Count
           (Node : access Variable_Reference_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access Variable_Reference_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access Variable_Reference_Type;
            Line_Prefix : String := "");




      
   

   function F_Variable_Name1
     (Node : access Variable_Reference_Type) return Identifier;
   


      
   

   function F_Variable_Name2
     (Node : access Variable_Reference_Type) return Identifier;
   


      
   

   function F_Attribute_Ref
     (Node : access Variable_Reference_Type) return Attribute_Reference;
   




   


       

   

   --
   --  With_Decl
   --

   type With_Decl_Type is 
      new GPR_Node_Type with private;



      overriding function Kind
        (Node : access With_Decl_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access With_Decl_Type) return String;

         overriding function Image
           (Node : access With_Decl_Type) return String;

         overriding function Child_Count
           (Node : access With_Decl_Type) return Natural;
         overriding procedure Get_Child
           (Node            : access With_Decl_Type;
            Index           : Positive;
            Index_In_Bounds : out Boolean;
            Result          : out GPR_Node);

         overriding procedure Print
           (Node        : access With_Decl_Type;
            Line_Prefix : String := "");




      
   

   function F_Is_Limited
     (Node : access With_Decl_Type) return Boolean;
   


      
   

   function F_Path_Names
     (Node : access With_Decl_Type) return String_Literal_List;
   




   



         

   

   type Case_Item_List_Type is
      
      new Base_List_Type with private;

      overriding function Kind
        (Node : access Case_Item_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Case_Item_List_Type) return String;

   function Item
     (Node  : access Case_Item_List_Type; Index : Positive) return Case_Item;


         

   

   type GPR_Node_List_Type is
      
      new Base_List_Type with private;

      overriding function Kind
        (Node : access GPR_Node_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access GPR_Node_List_Type) return String;

   function Item
     (Node  : access GPR_Node_List_Type; Index : Positive) return GPR_Node;


         

   

   type String_Literal_List_Type is
      
      new Base_List_Type with private;

      overriding function Kind
        (Node : access String_Literal_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access String_Literal_List_Type) return String;

   function Item
     (Node  : access String_Literal_List_Type; Index : Positive) return String_Literal;


         

   

   type Term_List_List_Type is
      
      new Base_List_Type with private;

      overriding function Kind
        (Node : access Term_List_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access Term_List_List_Type) return String;

   function Item
     (Node  : access Term_List_List_Type; Index : Positive) return Term_List;


         

   

   type With_Decl_List_Type is
      
      new Base_List_Type with private;

      overriding function Kind
        (Node : access With_Decl_List_Type) return GPR_Node_Kind_Type;
      overriding function Kind_Name
        (Node : access With_Decl_List_Type) return String;

   function Item
     (Node  : access With_Decl_List_Type; Index : Positive) return With_Decl;



private

   use AST_Envs;

   type Analysis_Context_Type;
   type Analysis_Unit_Type;

   type Analysis_Context is access all Analysis_Context_Type;
   type Analysis_Unit is access all Analysis_Unit_Type;

   No_Analysis_Unit    : constant Analysis_Unit := null;
   No_Analysis_Context : constant Analysis_Context := null;

   package Units_Maps is new Ada.Containers.Hashed_Maps
     (Key_Type        => Unbounded_String,
      Element_Type    => Analysis_Unit,
      Hash            => Ada.Strings.Unbounded.Hash,
      Equivalent_Keys => "=");


   type Analysis_Context_Private_Part_Type;
   type Analysis_Context_Private_Part
   is access all Analysis_Context_Private_Part_Type;

   type Analysis_Context_Type is record
      Ref_Count  : Natural;
      Units_Map  : Units_Maps.Map;
      Symbols    : Symbol_Table;

      Charset    : Unbounded_String;
      --  Default charset to use in analysis units

      Root_Scope : AST_Envs.Lexical_Env;
      --  The lexical scope that is shared amongst every compilation unit. Used
      --  to resolve cross file references.



      Private_Part : Analysis_Context_Private_Part;
   end record;

   procedure Reset_Property_Caches (Context : Analysis_Context);
   --  Call Reset_Property_Caches on all units Context contains

   type Destroy_Procedure is access procedure (Object : System.Address);

   type Destroyable_Type is record
      Object  : System.Address;
      --  Object to destroy

      Destroy : Destroy_Procedure;
      --  Procedure to destroy Object
   end record;
   --  Simple holder to associate an object to destroy and the procedure to
   --  perform the destruction.

   package Destroyable_Vectors is new Langkit_Support.Vectors
     (Destroyable_Type);

   package Analysis_Unit_Sets
   is new Langkit_Support.Cheap_Sets (Analysis_Unit, null);

   type Lex_Env_Data_Type;
   type Lex_Env_Data is access all Lex_Env_Data_Type;

   procedure Destroy (Self : in out Lex_Env_Data);
   --  Likewise, but also free the memory allocated to Self

   type Analysis_Unit_Type is record
      Context           : Analysis_Context;
      --  The owning context for this analysis unit

      Ref_Count         : Natural;
      --  Ref count for the analysis unit. Note that in the Ada API you'll
      --  still have to call Inc_Ref/Dec_Ref manually.

      AST_Root          : GPR_Node;

      File_Name         : Unbounded_String;
      --  The originating name for this analysis unit. This should be set even
      --  if the analysis unit was parsed from a buffer.

      Charset           : Unbounded_String;
      --  The parsing charset for this analysis unit, as a string. If the
      --  charset used actually came from a byte order mark, this is
      --  nevertheless set to the one the user requested.

      TDH               : aliased Token_Data_Handler;
      --  The token data handler that handles all token data during parsing and
      --  owns it afterwards.

      Diagnostics       : Diagnostics_Vectors.Vector;
      --  The list of diagnostics produced for this analysis unit

      With_Trivia       : Boolean;
      --  Whether Trivia nodes were parsed and included in this analysis unit

      Is_Env_Populated  : Boolean;
      --  Whether Populate_Lexical_Env was called on this unit. Used not to
      --  populate multiple times the same unit and hence avoid infinite
      --  populate recursions for circular dependencies.

      Has_Filled_Caches : Boolean;
      --  Set iff at least one memoized property has been evaluated
      --  successfully in one of the nodes, i.e. whether we need to invalidate
      --  the cache on the AST_Root tree.

      Rule              : Grammar_Rule;
      --  The grammar rule used to parse this unit

      AST_Mem_Pool      : Bump_Ptr_Pool;
      --  This memory pool shall only be used for AST parsing. Stored here
      --  because it is more convenient, but one shall not allocate from it.

      Destroyables      : Destroyable_Vectors.Vector;
      --  Collection of objects to destroy when destroying the analysis unit

      Referenced_Units  : Analysis_Unit_Sets.Set;
      --  Units that are referenced from this one. Useful for
      --  visibility/computation of the reference graph.

      Lex_Env_Data_Acc  : Lex_Env_Data;
      --  Lexical environment metadata for elements in this units' environments
      --  that belong to other units.
   end record;

   function Token_Data
     (Unit : Analysis_Unit) return Token_Data_Handler_Access;

   procedure Register_Destroyable_Helper
     (Unit    : Analysis_Unit;
      Object  : System.Address;
      Destroy : Destroy_Procedure);

   procedure Set_Filled_Caches (Unit : Analysis_Unit);
   --  Tag Unit as having filled caches for properties memoization

   procedure Reset_Property_Caches (Unit : Analysis_Unit);
   --  If AST_Node is not null, invoke Reset_Property_Caches primitives on all
   --  the nodes it contains.

   function Is_Referenced_From
     (Referenced, Unit : Analysis_Unit) return Boolean;
   --  Check whether the Referenced unit is referenced from Unit

   generic
      type T (<>) is limited private;
      type T_Access is access all T;
      with procedure Destroy (Object : in out T_Access);
   procedure Register_Destroyable_Gen
     (Unit : Analysis_Unit; Object : T_Access);
   --  Generic procedure to register an object so that it is automatically
   --  destroyed when Unit is destroyed.

   function Children
     (Node : access GPR_Node_Type'Class)
     return GPR_Node_Array_Access;
   --  Return an array containing all the children of Node.
   --  This is an alternative to the Child/Child_Count pair, useful if you want
   --  the convenience of ada arrays, and you don't care about the small
   --  performance hit of creating an array.

   procedure Reset_Property_Caches (Node : access GPR_Node_Type)
      is null;
   --  Reset the properties memoization caches attached to this node

   procedure Set_Parents (Node, Parent : access GPR_Node_Type'Class);
   --  Set Node.Parent to Parent, and initialize recursively the parent of all
   --  child nodes.

   procedure Destroy_Node (Node : access GPR_Node_Type) is null;
   --  Free the resources allocated to this node. This is conceptually abstract
   --  but we can't have private abstract primitives in Ada.

   procedure Destroy (Node : access GPR_Node_Type'Class);
   --  Free the resources allocated to this node and all its children

   ------------------------------
   -- Root AST node properties --
   ------------------------------

         



 function Node_Env
   
  (Node :
   access GPR_Node_Type

      ; E_Info : Entity_Info
         := No_Entity_Info
  )

   return Lexical_Env
   ;
--  For nodes that introduce a new environment, return the parent lexical
--  environment. Return the "inherited" environment otherwise.




   --------------------------
   -- Extensions internals --
   --------------------------

   type Extension_Slot is record
      ID        : Extension_ID;
      Extension : Extension_Access;
      Dtor      : Extension_Destructor;
   end record;

   package Extension_Vectors is new Langkit_Support.Vectors
     (Element_Type => Extension_Slot);

   --------------------------------------
   -- Environments handling (internal) --
   --------------------------------------

   No_Entity : constant Entity := (null, No_Entity_Info);

   procedure Inc_Ref (Self : Lexical_Env) renames AST_Envs.Inc_Ref;
   procedure Dec_Ref (Self : in out Lexical_Env) renames AST_Envs.Dec_Ref;

   function Get
     (A     : AST_Envs.Entity_Array;
      Index : Integer)
      return Entity;
   --  Simple getter that raises Property_Error on out-of-bound accesses.
   --  Useful for code generation.

   function Group is new AST_Envs.Group
     (Index_Type        => Positive,
      Lexical_Env_Array => Lexical_Env_Array);

   function Group
     (Envs : Lexical_Env_Array_Access)
      return Lexical_Env;
   --  Convenience wrapper for uniform types handling in code generation

   -------------------------------
   -- Root AST node (internals) --
   -------------------------------

   type Memoization_State is
     (Not_Computed,
      Computed,
      Raise_Property_Error);
   --  Implementation detail for properties memoization. Values describe if the
   --  property is still to be evaluated (Not_Computed), if its result value is
   --  already available (Comptuted) or if it is known to raise a
   --  Property_Error (Raise_Property_Error).

   type GPR_Node_Type is abstract tagged record
      Parent                 : GPR_Node := null;

      Unit                   : Analysis_Unit := null;
      --  Reference to the analysis unit that owns this node

      Token_Start_Index      : Token_Index  := No_Token_Index;
      Token_End_Index        : Token_Index  := No_Token_Index;
      --  Reference to the start and end token that constitutes this node. If
      --  this node is a ghost, Token_Start_Index is the token that this AST
      --  node relates to and Token_End_Index is No_Token_Index. Otherwise,
      --  both tokens are inclusive, i.e. they both belong to this node.

      Extensions             : Extension_Vectors.Vector;

      Self_Env               : AST_Envs.Lexical_Env;
      --  Hold the environment this node defines, or the parent environment
      --  otherwise.

      
   


   end record;

   procedure Free_Extensions (Node : access GPR_Node_Type'Class);
   --  Implementation helper to free the extensions associatde to Node

   
  procedure Free is new Ada.Unchecked_Deallocation
    (Lexical_Env_Array_Record, Lexical_Env_Array_Access);

   
  procedure Free is new Ada.Unchecked_Deallocation
    (Entity_Array_Record, Entity_Array_Access);

   
  procedure Free is new Ada.Unchecked_Deallocation
    (GPR_Node_Array_Record, GPR_Node_Array_Access);


   package GPR_Node_Vectors is
      new Langkit_Support.Vectors (GPR_Node);

   function Pre_Env_Actions
     (Self                : access GPR_Node_Type;
      Bound_Env, Root_Env : AST_Envs.Lexical_Env;
      Add_To_Env_Only     : Boolean := False) return AST_Envs.Lexical_Env;
   --  Internal procedure that will execute all necessary lexical env actions
   --  for Node. This is meant to be called by Populate_Lexical_Env, and not by
   --  the user.
   --  The return value is the initial environment to be passed to
   --  Post_Env_Actions.

   procedure Post_Env_Actions
     (Self                : access GPR_Node_Type;
      Bound_Env, Root_Env : AST_Envs.Lexical_Env) is null;
   --  Internal procedure that will execute all post add to env actions for
   --  Node. This is meant to be called by Populate_Lexical_Env.

   function Is_Visible_From
     (Referenced_Env, Base_Env : AST_Envs.Lexical_Env) return Boolean;
   --  Return whether the unit that Referenced_Env belongs to is visible from
   --  the unit that Base_Env belongs to. If at least one of these two lexical
   --  environments does not belong to a particular analysis unit, this raises
   --  a Property_Error.

   procedure Populate_Lexical_Env
     (Node     : access GPR_Node_Type'Class;
      Root_Env : AST_Envs.Lexical_Env);
   --  Populate the lexical environment for node and all its children

   --------------------------------
   -- Tree traversal (internals) --
   --------------------------------

   function Get_Parent
     (N : GPR_Node) return GPR_Node;

   function First_Child_Index_For_Traverse
     (N : GPR_Node) return Natural;

   function Last_Child_Index_For_Traverse
     (N : GPR_Node) return Natural;

   function Get_Child
     (N : GPR_Node; I : Natural) return GPR_Node;

   package Traversal_Iterators is new Langkit_Support.Tree_Traversal_Iterator
     (Element_type      => GPR_Node,
      Null_Value        => null,
      First_Child_Index => First_Child_Index_For_Traverse,
      Last_Child_Index  => Last_Child_Index_For_Traverse,
      Iterators         => GPR_Node_Iterators);

   type Traverse_Iterator is
      limited new Traversal_Iterators.Traverse_Iterator with null record;

   type Find_Iterator is limited
      new Ada.Finalization.Limited_Controlled
      and GPR_Node_Iterators.Iterator with
   record
      Traverse_It : Traverse_Iterator;
      --  Traverse iterator to fetch all nodes

      Predicate   : GPR_Node_Predicate;
      --  Predicate used to filter the nodes Traverse_It yields
   end record;

   overriding procedure Finalize (It : in out Find_Iterator);

   type Local_Find_Iterator is limited
      new Ada.Finalization.Limited_Controlled
      and GPR_Node_Iterators.Iterator with
   record
      Traverse_It : Traverse_Iterator;
      --  Traverse iterator to fetch all nodes

      Predicate   : access function (N : GPR_Node)
                                     return Boolean;
      --  Predicate used to filter the nodes Traverse_It yields
   end record;
   --  Iterator type for Find (see below)

   -----------------------------------
   -- Lexical utilities (internals) --
   -----------------------------------

   type Token_Type is record
      TDH           : Token_Data_Handler_Access;
      --  Token data handler that owns this token

      Token, Trivia : Token_Index;
      --  Indices that identify what this token refers to.
      --
      --  * If this references a token, then Token is the corresponding index
      --    in TDH.Tokens and Trivia is No_Token_Index.
      --
      --  * If this references a trivia that comes before the first token,
      --    Token is No_Token_Index while Trivia is the corresponding index in
      --    TDH.Trivias.
      --
      --  * If this references a trivia that comes after some token, Token is
      --    the index for this token and Trivia is the corresponding index for
      --    this trivia.
      --
      --  * If this references no token, both Token and Trivia are
      --    No_Token_Index.
   end record;

   No_Token : constant Token_Type := (null, No_Token_Index, No_Token_Index);

   type Token_Data_Type is record
      Kind          : Token_Kind;
      --  See documentation for the Kind accessor

      Is_Trivia     : Boolean;
      --  See documentation for the Is_Trivia accessor

      Index         : Token_Index;
      --  See documentation for the Index accessor

      Source_Buffer : Text_Cst_Access;
      --  Text for the original source file

      Source_First  : Positive;
      Source_Last   : Natural;
      --  Bounds in Source_Buffer for the text corresponding to this token

      Sloc_Range    : Source_Location_Range;
      --  See documenation for the Sloc_Range accessor
   end record;

   function First_Token (TDH : Token_Data_Handler_Access) return Token_Type;
   --  Internal helper. Return a reference to the first token in TDH.

   function Last_Token (TDH : Token_Data_Handler_Access) return Token_Type;
   --  Internal helper. Return a reference to the last token in TDH.

   function Token
     (Node  : access GPR_Node_Type'Class;
      Index : Token_Index) return Token_Type;
   --  Helper for properties. This is used to turn token indexes as stored in
   --  AST nodes into Token_Type values.

   function Stored_Token
     (Node  : access GPR_Node_Type'Class;
      Token : Token_Type)
      return Token_Index;
   --  Helper for properties. This is used to turn a Token_Type value into a
   --  Token_Index value that can be stored as a field in Node. This raises a
   --  Property_Error if Node and Token don't belong to the same analysis unit
   --  or if Token is actually a Trivia.

   function Is_Synthetic
     (Node : access GPR_Node_Type'Class) return Boolean;
   --  Returns whether the node is a synthetic node, i.e. whether it was
   --  generated for semantic analysis instead of parsing.

   --------------------------------
   -- Token Iterator (internals) --
   --------------------------------

   type Token_Iterator is record
      Node : GPR_Node;
      Last : Token_Index;
   end record;

   function Raw_Data (T : Token_Type) return Lexer.Token_Data_Type;
   --  Return the raw token data for T

   function Get_Symbol (Token : Token_Type) return Symbol_Type;
   --  Assuming that Token refers to a token that contains a symbol, return the
   --  corresponding symbol. This is an internal helper for properties code
   --  generation.


   package Alloc_AST_List_Array is new Langkit_Support.Bump_Ptr.Array_Alloc
     (Element_T  => GPR_Node,
      Index_Type => Positive);
   use type Alloc_AST_List_Array.Element_Array_Access;

   type Base_List_Type is
      abstract new GPR_Node_Type
   with record
      Count : Natural;
      Nodes : Alloc_AST_List_Array.Element_Array_Access;
   end record;

   overriding procedure Destroy_Node
     (Node : access Base_List_Type);

       

   

   type Abstract_Present_Type is 
      new GPR_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access Abstract_Present_Type);



   





       

   

   type Attribute_Decl_Type is 
      new GPR_Node_Type with record
      
   
            F_Attr_Name : aliased Identifier
               := null;
            
            F_Attr_Index : aliased GPR_Node
               := null;
            
            F_Expr : aliased Term_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Attribute_Decl_Type);



   





       

   

   type Attribute_Reference_Type is 
      new GPR_Node_Type with record
      
   
            F_Attribute_Name : aliased Identifier
               := null;
            
            F_Attribute_Index : aliased GPR_Node
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Attribute_Reference_Type);



   





       

   

   type Builtin_Function_Call_Type is 
      new GPR_Node_Type with record
      
   
            F_Function_Name : aliased Identifier
               := null;
            
            F_Parameters : aliased Expr_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Builtin_Function_Call_Type);



   





       

   

   type Case_Construction_Type is 
      new GPR_Node_Type with record
      
   
            F_Var_Ref : aliased Variable_Reference
               := null;
            
            F_Items : aliased Case_Item_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Case_Construction_Type);



   





       

   

   type Case_Item_Type is 
      new GPR_Node_Type with record
      
   
            F_Choice : aliased GPR_Node_List
               := null;
            
            F_Decls : aliased GPR_Node_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Case_Item_Type);



   





       

   

   type Compilation_Unit_Type is 
      new GPR_Node_Type with record
      
   
            F_Project : aliased Project
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Compilation_Unit_Type);



   





       

   

   type Empty_Decl_Type is 
      new GPR_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access Empty_Decl_Type);



   





       

   

   type Expr_Type is abstract
      new GPR_Node_Type with record
      
   
      null;


   end record;



   





       

   

   type Prefix_Type is 
      new Expr_Type with record
      
   
            F_Prefix : aliased Expr
               := null;
            
            F_Suffix : aliased Identifier
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Prefix_Type);



   





       

   

   type Single_Tok_Node_Type is abstract
      new Expr_Type with record
      
   
            F_Tok : aliased Token_Index
               := No_Token_Index;
            
       



   end record;



   





       

   

   type Identifier_Type is 
      new Single_Tok_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access Identifier_Type);



   





       

   

   type Num_Literal_Type is 
      new Single_Tok_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access Num_Literal_Type);



   





       

   

   type String_Literal_Type is 
      new Single_Tok_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access String_Literal_Type);



   





       

   

   type Expr_List_Type is 
      new GPR_Node_Type with record
      
   
            F_Exprs : aliased Term_List_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Expr_List_Type);



   





       

   

   type Others_Designator_Type is 
      new GPR_Node_Type with record
      
   
      null;


   end record;



      overriding procedure Destroy_Node
        (Node : access Others_Designator_Type);



   





       

   

   type Package_Decl_Type is 
      new GPR_Node_Type with record
      
   
            F_Pkg_Name : aliased Identifier
               := null;
            
            F_Pkg_Spec : aliased GPR_Node
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Package_Decl_Type);



   





       

   

   type Package_Extension_Type is 
      new GPR_Node_Type with record
      
   
            F_Prj_Name : aliased Identifier
               := null;
            
            F_Pkg_Name : aliased Identifier
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Package_Extension_Type);



   





       

   

   type Package_Renaming_Type is 
      new GPR_Node_Type with record
      
   
            F_Prj_Name : aliased Identifier
               := null;
            
            F_Pkg_Name : aliased Identifier
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Package_Renaming_Type);



   





       

   

   type Package_Spec_Type is 
      new GPR_Node_Type with record
      
   
            F_Extension : aliased Package_Extension
               := null;
            
            F_Decls : aliased GPR_Node_List
               := null;
            
            F_End_Name : aliased Identifier
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Package_Spec_Type);



   





       

   

   type Project_Type is 
      new GPR_Node_Type with record
      
   
            F_Context_Clauses : aliased With_Decl_List
               := null;
            
            F_Project_Decl : aliased Project_Declaration
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Project_Type);



   





       

   

   type Project_Declaration_Type is 
      new GPR_Node_Type with record
      
   
            F_Qualifier : aliased Project_Qualifier
               := null;
            
            F_Project_Name : aliased Expr
               := null;
            
            F_Extension : aliased Project_Extension
               := null;
            
            F_Decls : aliased GPR_Node_List
               := null;
            
            F_End_Name : aliased Expr
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Project_Declaration_Type);



   





       

   

   type Project_Extension_Type is 
      new GPR_Node_Type with record
      
   
            F_Is_All : aliased Boolean
               := false;
            
            F_Path_Name : aliased String_Literal
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Project_Extension_Type);



   





       

   

   type Project_Qualifier_Type is 
      new GPR_Node_Type with record
      
   
            F_Qualifier : aliased GPR_Node
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Project_Qualifier_Type);



   





       

   

   type Project_Reference_Type is 
      new GPR_Node_Type with record
      
   
            F_Attr_Ref : aliased Attribute_Reference
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Project_Reference_Type);



   





       

   

   type Qualifier_Names_Type is 
      new GPR_Node_Type with record
      
   
            F_Qualifier_Id1 : aliased Identifier
               := null;
            
            F_Qualifier_Id2 : aliased Identifier
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Qualifier_Names_Type);



   





       

   

   type String_Literal_At_Type is 
      new GPR_Node_Type with record
      
   
            F_Str_Lit : aliased String_Literal
               := null;
            
            F_At_Lit : aliased Num_Literal
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access String_Literal_At_Type);



   





       

   

   type Term_List_Type is 
      new GPR_Node_Type with record
      
   
            F_Terms : aliased GPR_Node_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Term_List_Type);



   





       

   

   type Typed_String_Decl_Type is 
      new GPR_Node_Type with record
      
   
            F_Type_Id : aliased Identifier
               := null;
            
            F_String_Literals : aliased String_Literal_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Typed_String_Decl_Type);



   





       

   

   type Variable_Decl_Type is 
      new GPR_Node_Type with record
      
   
            F_Var_Name : aliased Identifier
               := null;
            
            F_Var_Type : aliased Expr
               := null;
            
            F_Expr : aliased Term_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Variable_Decl_Type);



   





       

   

   type Variable_Reference_Type is 
      new GPR_Node_Type with record
      
   
            F_Variable_Name1 : aliased Identifier
               := null;
            
            F_Variable_Name2 : aliased Identifier
               := null;
            
            F_Attribute_Ref : aliased Attribute_Reference
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access Variable_Reference_Type);



   





       

   

   type With_Decl_Type is 
      new GPR_Node_Type with record
      
   
            F_Is_Limited : aliased Boolean
               := false;
            
            F_Path_Names : aliased String_Literal_List
               := null;
            
       



   end record;



      overriding procedure Destroy_Node
        (Node : access With_Decl_Type);



   






         

   

   type Case_Item_List_Type is
      
      new Base_List_Type with null record;

   function Get
     (Node    : access Case_Item_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return Case_Item;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based.

   function Length (Node : access Case_Item_List_Type'Class) return Natural;

         

   

   type GPR_Node_List_Type is
      
      new Base_List_Type with null record;

   function Get
     (Node    : access GPR_Node_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return GPR_Node;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based.

   function Length (Node : access GPR_Node_List_Type'Class) return Natural;

         

   

   type String_Literal_List_Type is
      
      new Base_List_Type with null record;

   function Get
     (Node    : access String_Literal_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return String_Literal;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based.

   function Length (Node : access String_Literal_List_Type'Class) return Natural;

         

   

   type Term_List_List_Type is
      
      new Base_List_Type with null record;

   function Get
     (Node    : access Term_List_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return Term_List;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based.

   function Length (Node : access Term_List_List_Type'Class) return Natural;

         

   

   type With_Decl_List_Type is
      
      new Base_List_Type with null record;

   function Get
     (Node    : access With_Decl_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return With_Decl;
   --  When Index is positive, return the Index'th element in T. Otherwise,
   --  return the element at index (Size - Index - 1). Index is zero-based.

   function Length (Node : access With_Decl_List_Type'Class) return Natural;


end GPR_Parser.Analysis;
