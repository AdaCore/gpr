
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2017, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE




with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Unchecked_Conversion;

with Interfaces;   use Interfaces;
with Interfaces.C; use Interfaces.C;

with System;

with GNAT.Byte_Order_Mark;

with GNATCOLL.Iconv;
with GNATCOLL.Mmap;    use GNATCOLL.Mmap;

with Langkit_Support.Symbols; use Langkit_Support.Symbols;
with Langkit_Support.Text;    use Langkit_Support.Text;


package body GPR_Parser.Lexer is

   Quex_Leading_Characters : constant := 2;
   Quex_Trailing_Characters : constant := 1;
   Quex_Extra_Characters : constant :=
      Quex_Leading_Characters + Quex_Trailing_Characters;
   --  Quex requires its input buffer to have two leading reserved bytes and
   --  one trailing. These are not part of the true payload, but must be
   --  available anyway.

   use Token_Vectors, Trivia_Vectors, Integer_Vectors;

   type Quex_Token_Type is record
      Id                       : Unsigned_16;
      Text                     : System.Address;
      Text_Length              : size_t;
      Start_Line, End_Line     : Unsigned_32;
      Start_Column, End_Column : Unsigned_16;
      Offset                   : Unsigned_32;
   end record
      with Convention => C;
   type Interface_Token_Access is access all Quex_Token_Type;

   type Lexer_Type is new System.Address;

   procedure Decode_Buffer
     (Buffer, Charset : String;
      Read_BOM        : Boolean;
      Decoded_Buffer  : out Text_Access;
      Source_First    : out Positive;
      Source_Last     : out Natural);
   --  Allocate a Text_Type buffer, set it to Decoded_Buffer, decode Buffer
   --  into it using Charset and Source_First/Source_Last to the actual slice
   --  in Decoded_Buffer that hold the input source text. It is up to the
   --  caller to deallocate Decoded_Buffer when done with it.
   --
   --  Quex quirk: this actually allocates more than the actual buffer to keep
   --  Quex happy. The two first characters are set to null and there is an
   --  extra null character at the end of the buffer. See the Quex_*_Characters
   --  constants above.

   function Lexer_From_Buffer (Buffer  : System.Address;
                               Length  : Size_T)
                               return Lexer_Type
      with Import        => True,
           Convention    => C,
           External_Name => "gpr_lexer_from_buffer";

   procedure Free_Lexer (Lexer : Lexer_Type)
      with Import        => True,
           Convention    => C,
           External_Name => "gpr_free_lexer";

   function Next_Token (Lexer : Lexer_Type;
                        Token : Interface_Token_Access) return int
      with Import        => True,
           Convention    => C,
           External_Name => "gpr_next_token";

   generic
      With_Trivia : Boolean;
   procedure Process_All_Tokens
     (Lexer : Lexer_Type; TDH : in out Token_Data_Handler);

   ------------------------
   -- Process_All_Tokens --
   ------------------------

   procedure Process_All_Tokens
     (Lexer : Lexer_Type; TDH : in out Token_Data_Handler)
   is

      Token                 : aliased Quex_Token_Type;
      Token_Id              : Token_Kind := GPR_Termination;
      Symbol                : Symbol_Type;
      Continue              : Boolean := True;
      Last_Token_Was_Trivia : Boolean := False;


      function Source_First return Positive is
        (Natural (Token.Offset) + TDH.Source_First - 1);
      --  Index in TDH.Source_Buffer for the first character corresponding to
      --  the current token.

      function Source_Last return Natural is
        (Source_First + Natural (Token.Text_Length) - 1);
      --  Likewise, for the last character

      function Sloc_Range return Source_Location_Range is
        ((Line_Number (Token.Start_Line),
          Line_Number (Token.End_Line),
          Column_Number (Token.Start_Column),
          Column_Number (Token.End_Column)));
      --  Create a sloc range value corresponding to Token

      procedure Prepare_For_Trivia
        with Inline;
      --  Append an entry for the current token in the Tokens_To_Trivias
      --  correspondence vector.

      ------------------------
      -- Prepare_For_Trivia --
      ------------------------

      procedure Prepare_For_Trivia is
      begin
         if With_Trivia then
            --  By default, the current token will have no trivia
            Append (TDH.Tokens_To_Trivias, Integer (No_Token_Index));

            --  Reset Last_Token_Was_Trivia so that new trivia is added to the
            --  current token.
            Last_Token_Was_Trivia := False;
         end if;
      end Prepare_For_Trivia;

   begin
      --  The first entry in the Tokens_To_Trivias map is for leading trivias
      Prepare_For_Trivia;

      while Continue loop

         --  Next_Token returns 0 for the last token, which will be our "null"
         --  token.

         Continue := Next_Token (Lexer, Token'Unrestricted_Access) /= 0;


         Token_Id := Token_Kind'Enum_Val (Token.Id);
         Symbol := null;

         case Token_Id is

            when GPR_Package | GPR_Type | GPR_Renames | GPR_Others | GPR_With | GPR_Identifier | GPR_Char | GPR_Comma | GPR_Assign | GPR_Pipe | GPR_Use | GPR_Is | GPR_When | GPR_Project | GPR_Abstract | GPR_Extends | GPR_Par_Close | GPR_Semicolon | GPR_Par_Open | GPR_Amp | GPR_All | GPR_Arrow | GPR_At | GPR_Case | GPR_End | GPR_Null | GPR_For | GPR_Colon | GPR_Tick | GPR_Limited | GPR_Dot =>
               declare
                  Bounded_Text : Text_Type (1 .. Natural (Token.Text_Length))
                     with Address => Token.Text;

                  Symbol_Text  : constant Text_Type :=
                        Bounded_Text;
               begin
                  Symbol := Find (TDH.Symbols, Symbol_Text);
               end;


            when others =>
               null;

         end case;

         --  Special case for the termination token: Quex yields inconsistent
         --  offsets/sizes. Make sure we get the end of the buffer so that the
         --  rest of our machinery (in particular source slices) works well
         --  with it.

         TDH.Tokens.Append
           ((Kind         => Token_Id,
             Source_First => (if Token_Id = GPR_Termination
                              then TDH.Source_Last + 1
                              else Source_First),
             Source_Last  => (if Token_Id = GPR_Termination
                              then TDH.Source_Last
                              else Source_Last),
             Symbol       => Symbol,
             Sloc_Range   => Sloc_Range));


         Prepare_For_Trivia;

      end loop;

   end Process_All_Tokens;

   procedure Process_All_Tokens_With_Trivia is new Process_All_Tokens (True);
   procedure Process_All_Tokens_No_Trivia is new Process_All_Tokens (False);

   -----------------------
   -- Lex_From_Filename --
   -----------------------

   procedure Lex_From_Filename
     (Filename, Charset : String;
      Read_BOM          : Boolean;
      TDH               : in out Token_Data_Handler;
      With_Trivia       : Boolean)
   is
      --  The following call to Open_Read may fail with a Name_Error exception:
      --  just let it propagate to the caller as there is no resource to
      --  release yet here.

      File        : Mapped_File := Open_Read (Filename);

      Region      : Mapped_Region := Read (File);
      Buffer_Addr : constant System.Address := Data (Region).all'Address;

      Buffer      : String (1 .. Last (Region));
      for Buffer'Address use Buffer_Addr;

   begin
      begin
         Lex_From_Buffer (Buffer, Charset, Read_BOM, TDH, With_Trivia);
      exception
         when Unknown_Charset | Invalid_Input =>
            Free (Region);
            Close (File);
            raise;
      end;
      Free (Region);
      Close (File);
   end Lex_From_Filename;

   ---------------------
   -- Lex_From_Buffer --
   ---------------------

   procedure Lex_From_Buffer
     (Buffer, Charset : String;
      Read_BOM        : Boolean;
      TDH             : in out Token_Data_Handler;
      With_Trivia     : Boolean)
   is
      Decoded_Buffer : Text_Access;
      Source_First   : Positive;
      Source_Last    : Natural;
      Lexer          : Lexer_Type;
   begin
      Decode_Buffer
        (Buffer, Charset, Read_BOM, Decoded_Buffer, Source_First, Source_Last);
      Lexer := Lexer_From_Buffer
        (Decoded_Buffer.all'Address,
         size_t (Source_Last - Source_First + 1));

      --  In the case we are reparsing an analysis unit, we want to get rid of
      --  the tokens from the old one.

      Reset (TDH, Decoded_Buffer, Source_First, Source_Last);

      if With_Trivia then
         Process_All_Tokens_With_Trivia (Lexer, TDH);
      else
         Process_All_Tokens_No_Trivia (Lexer, TDH);
      end if;
      Free_Lexer (Lexer);
   end Lex_From_Buffer;

   -------------------
   -- Decode_Buffer --
   -------------------

   procedure Decode_Buffer
     (Buffer, Charset : String;
      Read_BOM        : Boolean;
      Decoded_Buffer  : out Text_Access;
      Source_First    : out Positive;
      Source_Last     : out Natural)
   is
      use GNAT.Byte_Order_Mark;
      use GNATCOLL.Iconv;

      --  In the worst case, we have one character per input byte, so the
      --  following is supposed to be big enough.

      Result : Text_Access :=
         new Text_Type (1 .. Buffer'Length + Quex_Extra_Characters);
      State  : Iconv_T;
      Status : Iconv_Result;
      BOM    : BOM_Kind := Unknown;

      Input_Index, Output_Index : Positive;

      First_Output_Index : constant Positive :=
         1 + Quex_Leading_Characters * 4;
      --  Index of the first byte in Result at which Iconv must decode Buffer

      Output : Byte_Sequence (1 .. 4 * Buffer'Size);
      for Output'Address use Result.all'Address;
      --  Iconv works on mere strings, so this is a kind of a view conversion

   begin
      Decoded_Buffer := Result;
      Source_First := Result'First + Quex_Leading_Characters;

      --  GNATCOLL.Iconv raises a Constraint_Error for empty strings: handle
      --  them here.

      if Buffer'Length = 0 then
         Source_Last := Source_First - 1;
         return;
      end if;

      --  If we have a byte order mark, it overrides the requested Charset

      Input_Index := Buffer'First;
      if Read_BOM then
         declare
            Len : Natural;
         begin
            GNAT.Byte_Order_Mark.Read_BOM (Buffer, Len, BOM);
            Input_Index := Input_Index + Len;
         end;
      end if;

      --  Create the Iconv converter. We will notice unknown charsets here

      declare
         use System;

         To_Code : constant String :=
           (if Default_Bit_Order = Low_Order_First
            then UTF32LE
            else UTF32BE);

         BOM_Kind_To_Charset : constant
            array (UTF8_All .. UTF32_BE) of String_Access :=
           (UTF8_All => UTF8'Unrestricted_Access,
            UTF16_LE => UTF16LE'Unrestricted_Access,
            UTF16_BE => UTF16BE'Unrestricted_Access,
            UTF32_LE => UTF32LE'Unrestricted_Access,
            UTF32_BE => UTF32BE'Unrestricted_Access);

         Actual_Charset : constant String :=
           (if BOM in UTF8_All .. UTF32_BE
            then BOM_Kind_To_Charset (BOM).all
            else Charset);
      begin
         State := Iconv_Open (To_Code, Actual_Charset);
      exception
         when Unsupported_Conversion =>
            Free (Result);
            raise Unknown_Charset;
      end;

      --  Perform the conversion itself

      Output_Index := First_Output_Index;
      Iconv (State,
             Buffer, Input_Index,
             Output (Output_Index .. Output'Last), Output_Index,
             Status);
      Source_Last := (Output_Index - 1 - Output'First) / 4 + Result'First;

      --  Raise an error if the input was invalid

      case Status is
         when Invalid_Multibyte_Sequence | Incomplete_Multibyte_Sequence =>
            --  TODO??? It may be more helpful to actually perform lexing on an
            --  incomplete buffer. The user would get both a diagnostic for the
            --  charset error and a best-effort list of tokens.

            Free (Result);
            Iconv_Close (State);
            raise Invalid_Input;

         when Full_Buffer =>

            --  This is not supposed to happen: we allocated Result to be big
            --  enough in all cases.

            raise Program_Error;

         when Success =>
            null;
      end case;

      --  Clear the bytes we left for Quex

      declare
         Nul : constant Wide_Wide_Character := Wide_Wide_Character'Val (0);
      begin
         Result (1) := Nul;
         Result (2) := Nul;
         Result (Buffer'Length + 3) := Nul;
      end;

      Iconv_Close (State);
   end Decode_Buffer;

   Token_Kind_Names : constant array (Token_Kind) of String_Access := (
          GPR_End =>
             new String'("End")
              ,
          GPR_For =>
             new String'("For")
              ,
          GPR_When =>
             new String'("When")
              ,
          GPR_Use =>
             new String'("Use")
              ,
          GPR_Label =>
             new String'("Label")
              ,
          GPR_Extends =>
             new String'("Extends")
              ,
          GPR_Type =>
             new String'("Type")
              ,
          GPR_Colon =>
             new String'("Colon")
              ,
          GPR_String =>
             new String'("String")
              ,
          GPR_Others =>
             new String'("Others")
              ,
          GPR_Amp =>
             new String'("Amp")
              ,
          GPR_Tick =>
             new String'("Tick")
              ,
          GPR_With =>
             new String'("With")
              ,
          GPR_Case =>
             new String'("Case")
              ,
          GPR_Renames =>
             new String'("Renames")
              ,
          GPR_Package =>
             new String'("Package")
              ,
          GPR_All =>
             new String'("All")
              ,
          GPR_Project =>
             new String'("Project")
              ,
          GPR_Arrow =>
             new String'("Arrow")
              ,
          GPR_Identifier =>
             new String'("Identifier")
              ,
          GPR_Assign =>
             new String'("Assign")
              ,
          GPR_Dot =>
             new String'("Dot")
              ,
          GPR_Limited =>
             new String'("Limited")
              ,
          GPR_Par_Open =>
             new String'("Par_Open")
              ,
          GPR_Null =>
             new String'("Null")
              ,
          GPR_Semicolon =>
             new String'("Semicolon")
              ,
          GPR_Pipe =>
             new String'("Pipe")
              ,
          GPR_Abstract =>
             new String'("Abstract")
              ,
          GPR_Number =>
             new String'("Number")
              ,
          GPR_Char =>
             new String'("Char")
              ,
          GPR_Comma =>
             new String'("Comma")
              ,
          GPR_At =>
             new String'("At")
              ,
          GPR_Par_Close =>
             new String'("Par_Close")
              ,
          GPR_Is =>
             new String'("Is")
              ,
          GPR_Lexing_Failure =>
             new String'("Lexing_Failure")
              ,
          GPR_Termination =>
             new String'("Termination")
   );

   Token_Kind_To_Literals : constant array (Token_Kind) of String_Access := (
   

       GPR_Limited => new String'("limited")
       
           ,
       GPR_All => new String'("all")
       
           ,
       GPR_Abstract => new String'("abstract")
       
           ,
       GPR_Assign => new String'(":=")
       
           ,
       GPR_At => new String'("at")
       
           ,
       GPR_Null => new String'("null")
       
           ,
       GPR_Use => new String'("use")
       
           ,
       GPR_End => new String'("end")
       
           ,
       GPR_For => new String'("for")
       
           ,
       GPR_Amp => new String'("&")
       
           ,
       GPR_Par_Close => new String'(")")
       
           ,
       GPR_Par_Open => new String'("(")
       
           ,
       GPR_When => new String'("when")
       
           ,
       GPR_Comma => new String'(",")
       
           ,
       GPR_Dot => new String'(".")
       
           ,
       GPR_Extends => new String'("extends")
       
           ,
       GPR_Semicolon => new String'(";")
       
           ,
       GPR_Colon => new String'(":")
       
           ,
       GPR_Type => new String'("type")
       
           ,
       GPR_Is => new String'("is")
       
           ,
       GPR_Arrow => new String'("=>")
       
           ,
       GPR_Others => new String'("others")
       
           ,
       GPR_With => new String'("with")
       
           ,
       GPR_Case => new String'("case")
       
           ,
       GPR_Tick => new String'("'")
       
           ,
       GPR_Renames => new String'("renames")
       
           ,
       GPR_Package => new String'("package")
       
           ,
       GPR_Project => new String'("project")
       
           ,
       GPR_Pipe => new String'("|")
       
           ,
      others => new String'("")
   );

   ---------------------
   -- Token_Kind_Name --
   ---------------------

   function Token_Kind_Name (Token_Id : Token_Kind) return String is
     (Token_Kind_Names (Token_Id).all);

   ------------------------
   -- Token_Kind_Literal --
   ------------------------

   function Token_Kind_Literal (Token_Id : Token_Kind) return String is
     (Token_Kind_To_Literals (Token_Id).all);

   -----------------------
   -- Token_Error_Image --
   -----------------------

   function Token_Error_Image (Token_Id : Token_Kind) return String is
      Literal : constant String := Token_Kind_Literal (Token_Id);
   begin
      return (if Literal /= ""
              then "'" & Literal & "'"
              else Token_Kind_Name (Token_Id));
   end Token_Error_Image;

   ------------------
   -- Force_Symbol --
   ------------------

   function Force_Symbol
     (TDH : Token_Data_Handler;
      T   : in out Token_Data_Type) return Symbol_Type is
   begin
      if T.Symbol = null then
         declare
            Text : Text_Type renames
               TDH.Source_Buffer (T.Source_First ..  T.Source_Last);
         begin
            T.Symbol := Find
              (TDH.Symbols,
                  Text
               );
         end;
      end if;
      return T.Symbol;
   end Force_Symbol;

end GPR_Parser.Lexer;
