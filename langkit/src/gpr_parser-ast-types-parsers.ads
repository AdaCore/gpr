
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2016, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE


with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;

with Interfaces; use Interfaces;

with Langkit_Support.Diagnostics;        use Langkit_Support.Diagnostics;
with Langkit_Support.Token_Data_Handler; use Langkit_Support.Token_Data_Handler;

--  This package provides types and primitives to parse buffers and files and
--  get AST out of them.
--
--  TODO??? For now, consider that this package is not part of the public API.
--  Please use the Analysis package to parse source files.

package GPR_Parser.AST.Types.Parsers is

   type Fail_Info is record
      Pos               : Integer := -1;
      Expected_Token_Id : Unsigned_16;
      Found_Token_Id    : Unsigned_16;
   end record;

   type Parser_Type is record
      Current_Pos : Integer := 0;
      Last_Fail   : Fail_Info;
      Diagnostics : Diagnostics_Vectors.Vector;
      TDH         : Token_Data_Handler_Access;
      Mem_Pool    : Bump_Ptr_Pool;
   end record;

   function Create_From_File
     (Filename, Charset : String;
      TDH               : Token_Data_Handler_Access;
      With_Trivia       : Boolean := False) return Parser_type;
   --  Create a parser to parse the source in Filename, decoding it using
   --  Charset. The resulting tokens (and trivia if With_Trivia) are stored
   --  into TDH.
   --
   --  This can raise Lexer.Unknown_Charset or Lexer.Invalid_Input exceptions
   --  if the lexer has trouble decoding the input.

   function Create_From_Buffer
     (Buffer, Charset : String;
      TDH             : Token_Data_Handler_Access;
      With_Trivia     : Boolean := False) return Parser_type;
   --  Create a parser to parse the source in Buffer, decoding it using
   --  Charset. The resulting tokens (and trivia if With_Trivia) are stored
   --  into TDH.
   --
   --  This can raise Lexer.Unknown_Charset or Lexer.Invalid_Input exceptions
   --  if the lexer has trouble decoding the input.

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True) return GPR_Node
     with Inline_Always => True;
   --  Do the actual parsing using the main parsing rule.  If Check_Complete,
   --  consider the case when the parser could not consume all the input tokens
   --  as an error.

      function Parse_Abstract_Present
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Abstract_Present;
      --  Do the actual parsing using the abstract_present parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Associative_Array_Index
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return GPR_Node;
      --  Do the actual parsing using the associative_array_index parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Attribute_Decl
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Attribute_Decl;
      --  Do the actual parsing using the attribute_decl parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Attribute_Reference
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Attribute_Reference;
      --  Do the actual parsing using the attribute_reference parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Case_Construction
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Case_Construction;
      --  Do the actual parsing using the case_construction parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Case_Item
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Case_Item;
      --  Do the actual parsing using the case_item parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Choice
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return GPR_Node;
      --  Do the actual parsing using the choice parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Compilation_Unit
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Compilation_Unit;
      --  Do the actual parsing using the compilation_unit parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Context_Clauses
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return List_With_Decl;
      --  Do the actual parsing using the context_clauses parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Declarative_Item
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return GPR_Node;
      --  Do the actual parsing using the declarative_item parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Declarative_Items
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return List_GPR_Node;
      --  Do the actual parsing using the declarative_items parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Discrete_Choice_List
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return List_GPR_Node;
      --  Do the actual parsing using the discrete_choice_list parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Empty_Declaration
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Empty_Decl;
      --  Do the actual parsing using the empty_declaration parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Expression
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Term_List;
      --  Do the actual parsing using the expression parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Expression_List
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Expr_List;
      --  Do the actual parsing using the expression_list parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_External
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return External;
      --  Do the actual parsing using the external parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_External_As_List
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return External_As_List;
      --  Do the actual parsing using the external_as_list parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_External_Name
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return External_Name;
      --  Do the actual parsing using the external_name parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_External_Reference
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return External_Reference;
      --  Do the actual parsing using the external_reference parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Identifier
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Identifier;
      --  Do the actual parsing using the identifier parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Num_Literal
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Num_Literal;
      --  Do the actual parsing using the num_literal parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Others_Designator
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Others_Designator;
      --  Do the actual parsing using the others_designator parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Package_Decl
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Package_Decl;
      --  Do the actual parsing using the package_decl parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Package_Extension
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Package_Extension;
      --  Do the actual parsing using the package_extension parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Package_Renaming
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Package_Renaming;
      --  Do the actual parsing using the package_renaming parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Package_Spec
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Package_Spec;
      --  Do the actual parsing using the package_spec parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Project
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Project;
      --  Do the actual parsing using the project parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Project_Declaration
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Project_Declaration;
      --  Do the actual parsing using the project_declaration parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Project_Extension
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Project_Extension;
      --  Do the actual parsing using the project_extension parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Project_Qualifier
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Project_Qualifier;
      --  Do the actual parsing using the project_qualifier parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Project_Reference
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Project_Reference;
      --  Do the actual parsing using the project_reference parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Qualifier_Names
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Qualifier_Names;
      --  Do the actual parsing using the qualifier_names parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Simple_Declarative_Item
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return GPR_Node;
      --  Do the actual parsing using the simple_declarative_item parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Simple_Declarative_Items
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return List_GPR_Node;
      --  Do the actual parsing using the simple_declarative_items parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Static_Name
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Expr;
      --  Do the actual parsing using the static_name parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_String_Literal
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return String_Literal;
      --  Do the actual parsing using the string_literal parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_String_Literal_At
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return String_Literal_At;
      --  Do the actual parsing using the string_literal_at parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Term
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return GPR_Node;
      --  Do the actual parsing using the term parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Typed_String_Decl
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Typed_String_Decl;
      --  Do the actual parsing using the typed_string_decl parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Variable_Decl
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Variable_Decl;
      --  Do the actual parsing using the variable_decl parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_Variable_Reference
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return Variable_Reference;
      --  Do the actual parsing using the variable_reference parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.
      function Parse_With_Decl
        (Parser         : in out Parser_Type;
         Check_Complete : Boolean := True)
         return With_Decl;
      --  Do the actual parsing using the with_decl parsing rule.  If
      --  Check_Complete, consider the case when the parser could not consume
      --  all the input tokens as an error.

   procedure Clean_All_Memos;
   --  TODO??? We want to allow multiple parsers to run at the same time so
   --  memos should be stored in Parser_Type. In the end, this should be turned
   --  into a Parser_Type finalizer.

end GPR_Parser.AST.Types.Parsers;
