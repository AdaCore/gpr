
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2016, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE


with Ada.Strings.Wide_Wide_Unbounded; use Ada.Strings.Wide_Wide_Unbounded;

with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Packrat;
with Langkit_Support.Text;    use Langkit_Support.Text;

with GPR_Parser.Lexer;
use GPR_Parser.Lexer;

package body GPR_Parser.AST.Types.Parsers is

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists).


      package GPR_Node_Memos is new Langkit_Support.Packrat
        (GPR_Node, Token_Index);
      use GPR_Node_Memos;

         package List_GPR_Node_Memos is new Langkit_Support.Packrat
           (List_GPR_Node, Token_Index);
         use List_GPR_Node_Memos;
      package Abstract_Present_Memos is new Langkit_Support.Packrat
        (Abstract_Present, Token_Index);
      use Abstract_Present_Memos;

      package Attribute_Decl_Memos is new Langkit_Support.Packrat
        (Attribute_Decl, Token_Index);
      use Attribute_Decl_Memos;

      package Attribute_Reference_Memos is new Langkit_Support.Packrat
        (Attribute_Reference, Token_Index);
      use Attribute_Reference_Memos;

      package Builtin_Function_Call_Memos is new Langkit_Support.Packrat
        (Builtin_Function_Call, Token_Index);
      use Builtin_Function_Call_Memos;

      package Case_Construction_Memos is new Langkit_Support.Packrat
        (Case_Construction, Token_Index);
      use Case_Construction_Memos;

      package Case_Item_Memos is new Langkit_Support.Packrat
        (Case_Item, Token_Index);
      use Case_Item_Memos;

         package List_Case_Item_Memos is new Langkit_Support.Packrat
           (List_Case_Item, Token_Index);
         use List_Case_Item_Memos;
      package Compilation_Unit_Memos is new Langkit_Support.Packrat
        (Compilation_Unit, Token_Index);
      use Compilation_Unit_Memos;

      package Empty_Decl_Memos is new Langkit_Support.Packrat
        (Empty_Decl, Token_Index);
      use Empty_Decl_Memos;

      package Expr_Memos is new Langkit_Support.Packrat
        (Expr, Token_Index);
      use Expr_Memos;

      package Prefix_Memos is new Langkit_Support.Packrat
        (Prefix, Token_Index);
      use Prefix_Memos;

      package Single_Tok_Node_Memos is new Langkit_Support.Packrat
        (Single_Tok_Node, Token_Index);
      use Single_Tok_Node_Memos;

      package Identifier_Memos is new Langkit_Support.Packrat
        (Identifier, Token_Index);
      use Identifier_Memos;

      package Num_Literal_Memos is new Langkit_Support.Packrat
        (Num_Literal, Token_Index);
      use Num_Literal_Memos;

      package String_Literal_Memos is new Langkit_Support.Packrat
        (String_Literal, Token_Index);
      use String_Literal_Memos;

         package List_String_Literal_Memos is new Langkit_Support.Packrat
           (List_String_Literal, Token_Index);
         use List_String_Literal_Memos;
      package Expr_List_Memos is new Langkit_Support.Packrat
        (Expr_List, Token_Index);
      use Expr_List_Memos;

      package Others_Designator_Memos is new Langkit_Support.Packrat
        (Others_Designator, Token_Index);
      use Others_Designator_Memos;

      package Package_Decl_Memos is new Langkit_Support.Packrat
        (Package_Decl, Token_Index);
      use Package_Decl_Memos;

      package Package_Extension_Memos is new Langkit_Support.Packrat
        (Package_Extension, Token_Index);
      use Package_Extension_Memos;

      package Package_Renaming_Memos is new Langkit_Support.Packrat
        (Package_Renaming, Token_Index);
      use Package_Renaming_Memos;

      package Package_Spec_Memos is new Langkit_Support.Packrat
        (Package_Spec, Token_Index);
      use Package_Spec_Memos;

      package Project_Memos is new Langkit_Support.Packrat
        (Project, Token_Index);
      use Project_Memos;

      package Project_Declaration_Memos is new Langkit_Support.Packrat
        (Project_Declaration, Token_Index);
      use Project_Declaration_Memos;

      package Project_Extension_Memos is new Langkit_Support.Packrat
        (Project_Extension, Token_Index);
      use Project_Extension_Memos;

      package Project_Qualifier_Memos is new Langkit_Support.Packrat
        (Project_Qualifier, Token_Index);
      use Project_Qualifier_Memos;

      package Project_Reference_Memos is new Langkit_Support.Packrat
        (Project_Reference, Token_Index);
      use Project_Reference_Memos;

      package Qualifier_Names_Memos is new Langkit_Support.Packrat
        (Qualifier_Names, Token_Index);
      use Qualifier_Names_Memos;

      package String_Literal_At_Memos is new Langkit_Support.Packrat
        (String_Literal_At, Token_Index);
      use String_Literal_At_Memos;

      package Term_List_Memos is new Langkit_Support.Packrat
        (Term_List, Token_Index);
      use Term_List_Memos;

         package List_Term_List_Memos is new Langkit_Support.Packrat
           (List_Term_List, Token_Index);
         use List_Term_List_Memos;
      package Typed_String_Decl_Memos is new Langkit_Support.Packrat
        (Typed_String_Decl, Token_Index);
      use Typed_String_Decl_Memos;

      package Variable_Decl_Memos is new Langkit_Support.Packrat
        (Variable_Decl, Token_Index);
      use Variable_Decl_Memos;

      package Variable_Reference_Memos is new Langkit_Support.Packrat
        (Variable_Reference, Token_Index);
      use Variable_Reference_Memos;

      package With_Decl_Memos is new Langkit_Support.Packrat
        (With_Decl, Token_Index);
      use With_Decl_Memos;

         package List_With_Decl_Memos is new Langkit_Support.Packrat
           (List_With_Decl, Token_Index);
         use List_With_Decl_Memos;

   
function Identifier_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Identifier;

   
function Others_Designator_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Others_Designator;

   
function String_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return String_Literal;

   
function Attribute_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Attribute_Reference;

   
function Project_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Reference;

   
function Static_Name_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Expr;

   
function Package_Renaming_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Renaming;

   
function Num_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Num_Literal;

   
function String_Literal_At_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return String_Literal_At;

   
function Variable_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Variable_Reference;

   
function Term_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node;

   
function Expression_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Term_List;

   
function Expression_List_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Expr_List;

   
function Builtin_Function_Call_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Builtin_Function_Call;

   
function Package_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Extension;

   
function Variable_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Variable_Decl;

   
function Associative_Array_Index_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node;

   
function Attribute_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Attribute_Decl;

   
function Choice_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node;

   
function Discrete_Choice_List_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node;

   
function Case_Item_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Case_Item;

   
function Case_Construction_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Case_Construction;

   
function Empty_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Empty_Decl;

   
function Simple_Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node;

   
function Simple_Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node;

   
function Package_Spec_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Spec;

   
function Package_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Decl;

   
function Typed_String_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Typed_String_Decl;

   
function Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node;

   
function With_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return With_Decl;

   
function Context_Clauses_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_With_Decl;

   
function Abstract_Present_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Abstract_Present;

   
function Qualifier_Names_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Qualifier_Names;

   
function Project_Qualifier_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Qualifier;

   
function Project_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Extension;

   
function Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node;

   
function Project_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Declaration;

   
function Project_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project;

   
function Compilation_Unit_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Compilation_Unit;


   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse. If
   --  the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   ----------------------
   -- Create_From_File --
   ----------------------

   function Create_From_File
     (Filename, Charset : String;
      Unit              : Analysis_Unit_Interface;
      With_Trivia       : Boolean := False)
      return Parser_type
   is
      TDH : Token_Data_Handler renames Unit.Token_Data.all;
   begin
      Lex_From_Filename (Filename, Charset, TDH, With_Trivia);
      return (Unit => Unit, TDH => Unit.Token_Data, others => <>);
   end Create_From_File;

   ------------------------
   -- Create_From_Buffer --
   ------------------------

   function Create_From_Buffer
     (Buffer, Charset : String;
      Unit            : Analysis_Unit_Interface;
      With_Trivia     : Boolean := False)
      return Parser_type
   is
      TDH : Token_Data_Handler renames Unit.Token_Data.all;
   begin
      Lex_From_Buffer (Buffer, Charset, TDH, With_Trivia);
      return (Unit => Unit, TDH => Unit.Token_Data, others => <>);
   end Create_From_Buffer;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True)
   is

      procedure Add_Last_Fail_Diagnostic is
         Last_Token : Token_Data_Type renames
            Get_Token (Parser.TDH.all, Parser.Last_Fail.Pos);
         D : constant Diagnostic :=
           (Sloc_Range => Last_Token.Sloc_Range,
            Message    => To_Unbounded_Wide_Wide_String (To_Text
              ("Expected """
               & Token_Kind_Name (Parser.Last_Fail.Expected_Token_Id)
               & """, got """
               & Token_Kind_Name (Parser.Last_Fail.Found_Token_Id)
               & """")));
      begin
         Parser.Diagnostics.Append (D);
      end Add_Last_Fail_Diagnostic;

   begin

      if Parser.Current_Pos = No_Token_Index then
         Add_Last_Fail_Diagnostic;
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser, it means
         --  that the longest parse is the correct result, and that we have
         --  some garbage afterwards.
         if Parser.Current_Pos = Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Token_Data_Type renames
                  Get_Token (Parser.TDH.all, Parser.Current_Pos);
               D                   : constant Diagnostic :=
                 (Sloc_Range => First_Garbage_Token.Sloc_Range,
                  Message    => To_Unbounded_Wide_Wide_String (To_Text
                    ("End of input expected, got """
                     & Token_Kind_Name (First_Garbage_Token.Kind)
                     & """")));
            begin
               Parser.Diagnostics.Append (D);
            end;
         --  Else, the last fail pos is further down the line, and we want to
         --  have the diagnostic of what exactly failed.
         else
            pragma Assert (Parser.Current_Pos < Parser.Last_Fail.Pos);
            Add_Last_Fail_Diagnostic;
         end if;
      end if;
   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True;
      Rule           : Grammar_Rule)
      return GPR_Node
   is
      Result : GPR_Node;
   begin
      case Rule is
         when Abstract_Present_Rule =>
            Result := GPR_Node
              (Abstract_Present_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Associative_Array_Index_Rule =>
            Result := GPR_Node
              (Associative_Array_Index_Or_Parse_0
                 (Parser, First_Token_Index));
         when Attribute_Decl_Rule =>
            Result := GPR_Node
              (Attribute_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Attribute_Reference_Rule =>
            Result := GPR_Node
              (Attribute_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Builtin_Function_Call_Rule =>
            Result := GPR_Node
              (Builtin_Function_Call_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Case_Construction_Rule =>
            Result := GPR_Node
              (Case_Construction_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Case_Item_Rule =>
            Result := GPR_Node
              (Case_Item_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Choice_Rule =>
            Result := GPR_Node
              (Choice_Or_Parse_0
                 (Parser, First_Token_Index));
         when Compilation_Unit_Rule =>
            Result := GPR_Node
              (Compilation_Unit_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Context_Clauses_Rule =>
            Result := GPR_Node
              (Context_Clauses_List_Parse_0
                 (Parser, First_Token_Index));
         when Declarative_Item_Rule =>
            Result := GPR_Node
              (Declarative_Item_Or_Parse_0
                 (Parser, First_Token_Index));
         when Declarative_Items_Rule =>
            Result := GPR_Node
              (Declarative_Items_List_Parse_0
                 (Parser, First_Token_Index));
         when Discrete_Choice_List_Rule =>
            Result := GPR_Node
              (Discrete_Choice_List_List_Parse_0
                 (Parser, First_Token_Index));
         when Empty_Declaration_Rule =>
            Result := GPR_Node
              (Empty_Declaration_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Expression_Rule =>
            Result := GPR_Node
              (Expression_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Expression_List_Rule =>
            Result := GPR_Node
              (Expression_List_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Identifier_Rule =>
            Result := GPR_Node
              (Identifier_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Num_Literal_Rule =>
            Result := GPR_Node
              (Num_Literal_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Others_Designator_Rule =>
            Result := GPR_Node
              (Others_Designator_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Decl_Rule =>
            Result := GPR_Node
              (Package_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Extension_Rule =>
            Result := GPR_Node
              (Package_Extension_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Renaming_Rule =>
            Result := GPR_Node
              (Package_Renaming_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Spec_Rule =>
            Result := GPR_Node
              (Package_Spec_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Rule =>
            Result := GPR_Node
              (Project_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Declaration_Rule =>
            Result := GPR_Node
              (Project_Declaration_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Extension_Rule =>
            Result := GPR_Node
              (Project_Extension_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Qualifier_Rule =>
            Result := GPR_Node
              (Project_Qualifier_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Reference_Rule =>
            Result := GPR_Node
              (Project_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Qualifier_Names_Rule =>
            Result := GPR_Node
              (Qualifier_Names_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Simple_Declarative_Item_Rule =>
            Result := GPR_Node
              (Simple_Declarative_Item_Or_Parse_0
                 (Parser, First_Token_Index));
         when Simple_Declarative_Items_Rule =>
            Result := GPR_Node
              (Simple_Declarative_Items_List_Parse_0
                 (Parser, First_Token_Index));
         when Static_Name_Rule =>
            Result := GPR_Node
              (Static_Name_List_Parse_0
                 (Parser, First_Token_Index));
         when String_Literal_Rule =>
            Result := GPR_Node
              (String_Literal_Transform_Parse_0
                 (Parser, First_Token_Index));
         when String_Literal_At_Rule =>
            Result := GPR_Node
              (String_Literal_At_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Term_Rule =>
            Result := GPR_Node
              (Term_Or_Parse_0
                 (Parser, First_Token_Index));
         when Typed_String_Decl_Rule =>
            Result := GPR_Node
              (Typed_String_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Variable_Decl_Rule =>
            Result := GPR_Node
              (Variable_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Variable_Reference_Rule =>
            Result := GPR_Node
              (Variable_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when With_Decl_Rule =>
            Result := GPR_Node
              (With_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Clean_All_Memos;
      return Result;
   end Parse;

   


Identifier_Transform_Parse_0_Memo : Identifier_Memos.Memo_Type;

function Identifier_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Identifier
is
      Tk_Pos_2 : Token_Index
         := No_Token_Index;
      Tk_Res_2 : Token_Index
         := No_Token_Index;
      Transform_Res_0 : Identifier
         := null;


   M : Identifier_Memos.Memo_Entry := Get (Identifier_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_0 := M.Instance;
      return Transform_Res_0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tk_Res_2 := pos;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_2));
begin
   if T.Kind /= GPR_Identifier then
       Tk_Pos_2 := No_Token_Index;

       if Parser.Last_Fail.Pos <= pos then
           Parser.Last_Fail.Pos := pos;
           Parser.Last_Fail.Expected_Token_Id := GPR_Identifier;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_2 := pos + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_2 /= No_Token_Index then

   Transform_Res_0 := Identifier
     (Identifier_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_0.Unit := Parser.Unit;
   Transform_Res_0.Token_Start := pos;
   Transform_Res_0.Token_End := (if Tk_Pos_2 = pos
                        then pos
                        else Tk_Pos_2 - 1);

      Transform_Res_0.F_Tok :=
            Tk_Res_2;


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Identifier_Transform_Parse_0_Memo,
        Tk_Pos_2 /= No_Token_Index,
        Transform_Res_0,
        Pos,
        Tk_Pos_2);


   Parser.Current_Pos := Tk_Pos_2;

   return Transform_Res_0;
end Identifier_Transform_Parse_0;

   


Others_Designator_Transform_Parse_0_Memo : Others_Designator_Memos.Memo_Type;

function Others_Designator_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Others_Designator
is
      Tk_Pos_4 : Token_Index
         := No_Token_Index;
      Tk_Res_4 : Token_Index
         := No_Token_Index;
      Transform_Res_1 : Others_Designator
         := null;


   M : Others_Designator_Memos.Memo_Entry := Get (Others_Designator_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_1 := M.Instance;
      return Transform_Res_1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_1;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tk_Res_4 := pos;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_4));
begin
   if T.Kind /= GPR_Others then
       Tk_Pos_4 := No_Token_Index;

       if Parser.Last_Fail.Pos <= pos then
           Parser.Last_Fail.Pos := pos;
           Parser.Last_Fail.Expected_Token_Id := GPR_Others;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_4 := pos + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_4 /= No_Token_Index then

   Transform_Res_1 := Others_Designator
     (Others_Designator_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_1.Unit := Parser.Unit;
   Transform_Res_1.Token_Start := pos;
   Transform_Res_1.Token_End := (if Tk_Pos_4 = pos
                        then pos
                        else Tk_Pos_4 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Others_Designator_Transform_Parse_0_Memo,
        Tk_Pos_4 /= No_Token_Index,
        Transform_Res_1,
        Pos,
        Tk_Pos_4);


   Parser.Current_Pos := Tk_Pos_4;

   return Transform_Res_1;
end Others_Designator_Transform_Parse_0;

   


String_Literal_Transform_Parse_0_Memo : String_Literal_Memos.Memo_Type;

function String_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return String_Literal
is
      Tk_Pos_5 : Token_Index
         := No_Token_Index;
      Tk_Res_5 : Token_Index
         := No_Token_Index;
      Transform_Res_2 : String_Literal
         := null;


   M : String_Literal_Memos.Memo_Entry := Get (String_Literal_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_2 := M.Instance;
      return Transform_Res_2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tk_Res_5 := pos;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_5));
begin
   if T.Kind /= GPR_String then
       Tk_Pos_5 := No_Token_Index;

       if Parser.Last_Fail.Pos <= pos then
           Parser.Last_Fail.Pos := pos;
           Parser.Last_Fail.Expected_Token_Id := GPR_String;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_5 := pos + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_5 /= No_Token_Index then

   Transform_Res_2 := String_Literal
     (String_Literal_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_2.Unit := Parser.Unit;
   Transform_Res_2.Token_Start := pos;
   Transform_Res_2.Token_End := (if Tk_Pos_5 = pos
                        then pos
                        else Tk_Pos_5 - 1);

      Transform_Res_2.F_Tok :=
            Tk_Res_5;


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (String_Literal_Transform_Parse_0_Memo,
        Tk_Pos_5 /= No_Token_Index,
        Transform_Res_2,
        Pos,
        Tk_Pos_5);


   Parser.Current_Pos := Tk_Pos_5;

   return Transform_Res_2;
end String_Literal_Transform_Parse_0;

   


Attribute_Reference_Transform_Parse_0_Memo : Attribute_Reference_Memos.Memo_Type;

function Attribute_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Attribute_Reference
is
      Row_Pos_1 : Token_Index
         := No_Token_Index;
      Fncall_Pos_0 : Token_Index
         := No_Token_Index;
      Fncall_Res_0 : Identifier
         := null;
      Row_Subres_0_1 : Identifier
         := null;
      Row_Pos_2 : Token_Index
         := No_Token_Index;
      Tk_Pos_3 : Token_Index
         := No_Token_Index;
      Tk_Res_3 : Token_Index
         := No_Token_Index;
      Or_Pos_0 : Token_Index
         := No_Token_Index;
      Or_Res_0 : GPR_Node
         := null;
      Fncall_Pos_1 : Token_Index
         := No_Token_Index;
      Fncall_Res_1 : Others_Designator
         := null;
      Fncall_Pos_2 : Token_Index
         := No_Token_Index;
      Fncall_Res_2 : String_Literal
         := null;
      Row_Subres_1_2 : GPR_Node
         := null;
      Tk_Pos_6 : Token_Index
         := No_Token_Index;
      Tk_Res_6 : Token_Index
         := No_Token_Index;
      Row_Subres_1_1 : GPR_Node
         := null;
      Transform_Res_3 : Attribute_Reference
         := null;


   M : Attribute_Reference_Memos.Memo_Entry := Get (Attribute_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_3 := M.Instance;
      return Transform_Res_3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_1 := pos;


--  Start row_submatch


Fncall_Res_0 := Identifier_Transform_Parse_0(Parser, Row_Pos_1);
Fncall_Pos_0 := Parser.Current_Pos;


if Fncall_Pos_0 /= No_Token_Index then

   Row_Pos_1 := Fncall_Pos_0;

      Row_Subres_0_1 := Fncall_Res_0;

else
   Row_Pos_1 := No_Token_Index;
   goto Row_Exit_Label_1_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_2 := Row_Pos_1;


--  Start row_submatch


--  Start tok_code

Tk_Res_3 := Row_Pos_2;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_3));
begin
   if T.Kind /= GPR_Par_Open then
       Tk_Pos_3 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_2 then
           Parser.Last_Fail.Pos := Row_Pos_2;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Open;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_3 := Row_Pos_2 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_3 /= No_Token_Index then

   Row_Pos_2 := Tk_Pos_3;


else
   Row_Pos_2 := No_Token_Index;
   goto Row_Exit_Label_2_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start or_code

Or_Pos_0 := No_Token_Index;
Or_Res_0 := null;
    
Fncall_Res_1 := Others_Designator_Transform_Parse_0(Parser, Row_Pos_2);
Fncall_Pos_1 := Parser.Current_Pos;

    if Fncall_Pos_1 /= No_Token_Index then
        Or_Pos_0 := Fncall_Pos_1;
        Or_Res_0 := GPR_Node
          (Fncall_Res_1);
        goto Exit_Or_0;
    end if;
    
Fncall_Res_2 := String_Literal_Transform_Parse_0(Parser, Row_Pos_2);
Fncall_Pos_2 := Parser.Current_Pos;

    if Fncall_Pos_2 /= No_Token_Index then
        Or_Pos_0 := Fncall_Pos_2;
        Or_Res_0 := GPR_Node
          (Fncall_Res_2);
        goto Exit_Or_0;
    end if;
<<Exit_Or_0>>

--  End or_code


if Or_Pos_0 /= No_Token_Index then

   Row_Pos_2 := Or_Pos_0;

      Row_Subres_1_2 := Or_Res_0;

else
   Row_Pos_2 := No_Token_Index;
   goto Row_Exit_Label_2_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_6 := Row_Pos_2;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_6));
begin
   if T.Kind /= GPR_Par_Close then
       Tk_Pos_6 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_2 then
           Parser.Last_Fail.Pos := Row_Pos_2;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Close;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_6 := Row_Pos_2 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_6 /= No_Token_Index then

   Row_Pos_2 := Tk_Pos_6;


else
   Row_Pos_2 := No_Token_Index;
   goto Row_Exit_Label_2_0;

end if;

--  End row_submatch


<<Row_Exit_Label_2_0>>

--  End row_code



if Row_Pos_2 = No_Token_Index then
        Row_Subres_1_2 :=
           null;


    Row_Pos_2 := Row_Pos_1;
end if;

--  End opt_code


if Row_Pos_2 /= No_Token_Index then

   Row_Pos_1 := Row_Pos_2;

      Row_Subres_1_1 := Row_Subres_1_2;

else
   Row_Pos_1 := No_Token_Index;
   goto Row_Exit_Label_1_0;

end if;

--  End row_submatch


<<Row_Exit_Label_1_0>>

--  End row_code


if Row_Pos_1 /= No_Token_Index then

   Transform_Res_3 := Attribute_Reference
     (Attribute_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_3.Unit := Parser.Unit;
   Transform_Res_3.Token_Start := pos;
   Transform_Res_3.Token_End := (if Row_Pos_1 = pos
                        then pos
                        else Row_Pos_1 - 1);

      Transform_Res_3.F_Attribute_Name :=
            Identifier (Row_Subres_0_1);

         if Row_Subres_0_1 /= null then
            Row_Subres_0_1.Parent := GPR_Node (Transform_Res_3);
         end if;
      Transform_Res_3.F_Attribute_Index :=
            GPR_Node (Row_Subres_1_1);

         if Row_Subres_1_1 /= null then
            Row_Subres_1_1.Parent := GPR_Node (Transform_Res_3);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Attribute_Reference_Transform_Parse_0_Memo,
        Row_Pos_1 /= No_Token_Index,
        Transform_Res_3,
        Pos,
        Row_Pos_1);


   Parser.Current_Pos := Row_Pos_1;

   return Transform_Res_3;
end Attribute_Reference_Transform_Parse_0;

   


Project_Reference_Transform_Parse_0_Memo : Project_Reference_Memos.Memo_Type;

function Project_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Reference
is
      Row_Pos_0 : Token_Index
         := No_Token_Index;
      Tk_Pos_0 : Token_Index
         := No_Token_Index;
      Tk_Res_0 : Token_Index
         := No_Token_Index;
      Tk_Pos_1 : Token_Index
         := No_Token_Index;
      Tk_Res_1 : Token_Index
         := No_Token_Index;
      Fncall_Pos_3 : Token_Index
         := No_Token_Index;
      Fncall_Res_3 : Attribute_Reference
         := null;
      Row_Subres_2_0 : Attribute_Reference
         := null;
      Transform_Res_4 : Project_Reference
         := null;


   M : Project_Reference_Memos.Memo_Entry := Get (Project_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_4 := M.Instance;
      return Transform_Res_4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_0 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_0 := Row_Pos_0;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_0));
begin
   if T.Kind /= GPR_Project then
       Tk_Pos_0 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_0 then
           Parser.Last_Fail.Pos := Row_Pos_0;
           Parser.Last_Fail.Expected_Token_Id := GPR_Project;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_0 := Row_Pos_0 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_0 /= No_Token_Index then

   Row_Pos_0 := Tk_Pos_0;


else
   Row_Pos_0 := No_Token_Index;
   goto Row_Exit_Label_0_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_1 := Row_Pos_0;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_1));
begin
   if T.Kind /= GPR_Tick then
       Tk_Pos_1 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_0 then
           Parser.Last_Fail.Pos := Row_Pos_0;
           Parser.Last_Fail.Expected_Token_Id := GPR_Tick;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_1 := Row_Pos_0 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_1 /= No_Token_Index then

   Row_Pos_0 := Tk_Pos_1;


else
   Row_Pos_0 := No_Token_Index;
   goto Row_Exit_Label_0_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_3 := Attribute_Reference_Transform_Parse_0(Parser, Row_Pos_0);
Fncall_Pos_3 := Parser.Current_Pos;


if Fncall_Pos_3 /= No_Token_Index then

   Row_Pos_0 := Fncall_Pos_3;

      Row_Subres_2_0 := Fncall_Res_3;

else
   Row_Pos_0 := No_Token_Index;
   goto Row_Exit_Label_0_0;

end if;

--  End row_submatch


<<Row_Exit_Label_0_0>>

--  End row_code


if Row_Pos_0 /= No_Token_Index then

   Transform_Res_4 := Project_Reference
     (Project_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_4.Unit := Parser.Unit;
   Transform_Res_4.Token_Start := pos;
   Transform_Res_4.Token_End := (if Row_Pos_0 = pos
                        then pos
                        else Row_Pos_0 - 1);

      Transform_Res_4.F_Attr_Ref :=
            Attribute_Reference (Row_Subres_2_0);

         if Row_Subres_2_0 /= null then
            Row_Subres_2_0.Parent := GPR_Node (Transform_Res_4);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Project_Reference_Transform_Parse_0_Memo,
        Row_Pos_0 /= No_Token_Index,
        Transform_Res_4,
        Pos,
        Row_Pos_0);


   Parser.Current_Pos := Row_Pos_0;

   return Transform_Res_4;
end Project_Reference_Transform_Parse_0;

   


Static_Name_List_Parse_0_Memo : Expr_Memos.Memo_Type;

function Static_Name_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Expr
is
      Lst_Pos_0 : Token_Index
         := No_Token_Index;
      Lst_Res_0 : Expr
         := null;
      Lst_Cpos_0 : Token_Index
         := No_Token_Index;
      Fncall_Pos_4 : Token_Index
         := No_Token_Index;
      Fncall_Res_4 : Identifier
         := null;
      Tk_Pos_7 : Token_Index
         := No_Token_Index;
      Tk_Res_7 : Token_Index
         := No_Token_Index;


   M : Expr_Memos.Memo_Entry := Get (Static_Name_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Lst_Res_0 := M.Instance;
      return Lst_Res_0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Lst_Res_0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    Lst_Pos_0 := No_Token_Index;

Lst_Res_0 := null;
Lst_Cpos_0 := pos;

loop
   
Fncall_Res_4 := Identifier_Transform_Parse_0(Parser, Lst_Cpos_0);
Fncall_Pos_4 := Parser.Current_Pos;


   exit when Fncall_Pos_4 = No_Token_Index;

   Lst_Pos_0 := Fncall_Pos_4;
   Lst_Cpos_0 := Fncall_Pos_4;



      if Lst_Res_0 = null then
         Lst_Res_0 := Expr (Fncall_Res_4);

      else
         declare
            

            New_Res : Prefix := Prefix
              (Prefix_Alloc.Alloc (Parser.Mem_Pool));
         begin
            
            New_Res.F_Prefix := Expr (Lst_Res_0);

            New_Res.F_Suffix :=
              Expr (Fncall_Res_4);

            Lst_Res_0.Parent := GPR_Node (New_Res);
            Fncall_Res_4.Parent :=
              GPR_Node (New_Res);

            Lst_Res_0 := Expr (New_Res);
         end;

         Lst_Res_0.Unit := Parser.Unit;
         Lst_Res_0.Token_Start := pos;
         Lst_Res_0.Token_End := (if Lst_Cpos_0 = pos
                              then pos
                              else Lst_Cpos_0 - 1);
      end if;


      
--  Start tok_code

Tk_Res_7 := Lst_Cpos_0;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_7));
begin
   if T.Kind /= GPR_Dot then
       Tk_Pos_7 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_0 then
           Parser.Last_Fail.Pos := Lst_Cpos_0;
           Parser.Last_Fail.Expected_Token_Id := GPR_Dot;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_7 := Lst_Cpos_0 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_7 /= No_Token_Index then
          Lst_Cpos_0 := Tk_Pos_7;
      else
         exit;
      end if;

end loop;

if Lst_Res_0 /= null then
   Lst_Res_0.Unit := Parser.Unit;
   Lst_Res_0.Token_Start := pos;
   Lst_Res_0.Token_End := (if Lst_Cpos_0 = pos
                        then pos
                        else Lst_Cpos_0 - 1);
end if;


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Static_Name_List_Parse_0_Memo,
        Lst_Pos_0 /= No_Token_Index,
        Lst_Res_0,
        Pos,
        Lst_Pos_0);


   Parser.Current_Pos := Lst_Pos_0;

   return Lst_Res_0;
end Static_Name_List_Parse_0;

   


Package_Renaming_Transform_Parse_0_Memo : Package_Renaming_Memos.Memo_Type;

function Package_Renaming_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Renaming
is
      Row_Pos_3 : Token_Index
         := No_Token_Index;
      Tk_Pos_8 : Token_Index
         := No_Token_Index;
      Tk_Res_8 : Token_Index
         := No_Token_Index;
      Fncall_Pos_5 : Token_Index
         := No_Token_Index;
      Fncall_Res_5 : Identifier
         := null;
      Row_Subres_1_3 : Identifier
         := null;
      Tk_Pos_9 : Token_Index
         := No_Token_Index;
      Tk_Res_9 : Token_Index
         := No_Token_Index;
      Fncall_Pos_6 : Token_Index
         := No_Token_Index;
      Fncall_Res_6 : Identifier
         := null;
      Row_Subres_3_0 : Identifier
         := null;
      Transform_Res_5 : Package_Renaming
         := null;


   M : Package_Renaming_Memos.Memo_Entry := Get (Package_Renaming_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_5 := M.Instance;
      return Transform_Res_5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_3 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_8 := Row_Pos_3;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_8));
begin
   if T.Kind /= GPR_Renames then
       Tk_Pos_8 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_3 then
           Parser.Last_Fail.Pos := Row_Pos_3;
           Parser.Last_Fail.Expected_Token_Id := GPR_Renames;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_8 := Row_Pos_3 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_8 /= No_Token_Index then

   Row_Pos_3 := Tk_Pos_8;


else
   Row_Pos_3 := No_Token_Index;
   goto Row_Exit_Label_3_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_5 := Identifier_Transform_Parse_0(Parser, Row_Pos_3);
Fncall_Pos_5 := Parser.Current_Pos;


if Fncall_Pos_5 /= No_Token_Index then

   Row_Pos_3 := Fncall_Pos_5;

      Row_Subres_1_3 := Fncall_Res_5;

else
   Row_Pos_3 := No_Token_Index;
   goto Row_Exit_Label_3_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_9 := Row_Pos_3;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_9));
begin
   if T.Kind /= GPR_Dot then
       Tk_Pos_9 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_3 then
           Parser.Last_Fail.Pos := Row_Pos_3;
           Parser.Last_Fail.Expected_Token_Id := GPR_Dot;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_9 := Row_Pos_3 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_9 /= No_Token_Index then

   Row_Pos_3 := Tk_Pos_9;


else
   Row_Pos_3 := No_Token_Index;
   goto Row_Exit_Label_3_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_6 := Identifier_Transform_Parse_0(Parser, Row_Pos_3);
Fncall_Pos_6 := Parser.Current_Pos;


if Fncall_Pos_6 /= No_Token_Index then

   Row_Pos_3 := Fncall_Pos_6;

      Row_Subres_3_0 := Fncall_Res_6;

else
   Row_Pos_3 := No_Token_Index;
   goto Row_Exit_Label_3_0;

end if;

--  End row_submatch


<<Row_Exit_Label_3_0>>

--  End row_code


if Row_Pos_3 /= No_Token_Index then

   Transform_Res_5 := Package_Renaming
     (Package_Renaming_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_5.Unit := Parser.Unit;
   Transform_Res_5.Token_Start := pos;
   Transform_Res_5.Token_End := (if Row_Pos_3 = pos
                        then pos
                        else Row_Pos_3 - 1);

      Transform_Res_5.F_Prj_Name :=
            Identifier (Row_Subres_1_3);

         if Row_Subres_1_3 /= null then
            Row_Subres_1_3.Parent := GPR_Node (Transform_Res_5);
         end if;
      Transform_Res_5.F_Pkg_Name :=
            Identifier (Row_Subres_3_0);

         if Row_Subres_3_0 /= null then
            Row_Subres_3_0.Parent := GPR_Node (Transform_Res_5);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Package_Renaming_Transform_Parse_0_Memo,
        Row_Pos_3 /= No_Token_Index,
        Transform_Res_5,
        Pos,
        Row_Pos_3);


   Parser.Current_Pos := Row_Pos_3;

   return Transform_Res_5;
end Package_Renaming_Transform_Parse_0;

   


Num_Literal_Transform_Parse_0_Memo : Num_Literal_Memos.Memo_Type;

function Num_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Num_Literal
is
      Tk_Pos_12 : Token_Index
         := No_Token_Index;
      Tk_Res_12 : Token_Index
         := No_Token_Index;
      Transform_Res_6 : Num_Literal
         := null;


   M : Num_Literal_Memos.Memo_Entry := Get (Num_Literal_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_6 := M.Instance;
      return Transform_Res_6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tk_Res_12 := pos;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_12));
begin
   if T.Kind /= GPR_Number then
       Tk_Pos_12 := No_Token_Index;

       if Parser.Last_Fail.Pos <= pos then
           Parser.Last_Fail.Pos := pos;
           Parser.Last_Fail.Expected_Token_Id := GPR_Number;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_12 := pos + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_12 /= No_Token_Index then

   Transform_Res_6 := Num_Literal
     (Num_Literal_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_6.Unit := Parser.Unit;
   Transform_Res_6.Token_Start := pos;
   Transform_Res_6.Token_End := (if Tk_Pos_12 = pos
                        then pos
                        else Tk_Pos_12 - 1);

      Transform_Res_6.F_Tok :=
            Tk_Res_12;


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Num_Literal_Transform_Parse_0_Memo,
        Tk_Pos_12 /= No_Token_Index,
        Transform_Res_6,
        Pos,
        Tk_Pos_12);


   Parser.Current_Pos := Tk_Pos_12;

   return Transform_Res_6;
end Num_Literal_Transform_Parse_0;

   


String_Literal_At_Transform_Parse_0_Memo : String_Literal_At_Memos.Memo_Type;

function String_Literal_At_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return String_Literal_At
is
      Row_Pos_6 : Token_Index
         := No_Token_Index;
      Fncall_Pos_9 : Token_Index
         := No_Token_Index;
      Fncall_Res_9 : String_Literal
         := null;
      Row_Subres_0_6 : String_Literal
         := null;
      Row_Pos_7 : Token_Index
         := No_Token_Index;
      Tk_Pos_11 : Token_Index
         := No_Token_Index;
      Tk_Res_11 : Token_Index
         := No_Token_Index;
      Fncall_Pos_10 : Token_Index
         := No_Token_Index;
      Fncall_Res_10 : Num_Literal
         := null;
      Row_Subres_1_7 : Num_Literal
         := null;
      Row_Subres_1_6 : Num_Literal
         := null;
      Transform_Res_7 : String_Literal_At
         := null;


   M : String_Literal_At_Memos.Memo_Entry := Get (String_Literal_At_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_7 := M.Instance;
      return Transform_Res_7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_7;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_6 := pos;


--  Start row_submatch


Fncall_Res_9 := String_Literal_Transform_Parse_0(Parser, Row_Pos_6);
Fncall_Pos_9 := Parser.Current_Pos;


if Fncall_Pos_9 /= No_Token_Index then

   Row_Pos_6 := Fncall_Pos_9;

      Row_Subres_0_6 := Fncall_Res_9;

else
   Row_Pos_6 := No_Token_Index;
   goto Row_Exit_Label_6_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_7 := Row_Pos_6;


--  Start row_submatch


--  Start tok_code

Tk_Res_11 := Row_Pos_7;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_11));
begin
   if T.Kind /= GPR_At then
       Tk_Pos_11 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_7 then
           Parser.Last_Fail.Pos := Row_Pos_7;
           Parser.Last_Fail.Expected_Token_Id := GPR_At;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_11 := Row_Pos_7 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_11 /= No_Token_Index then

   Row_Pos_7 := Tk_Pos_11;


else
   Row_Pos_7 := No_Token_Index;
   goto Row_Exit_Label_7_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_10 := Num_Literal_Transform_Parse_0(Parser, Row_Pos_7);
Fncall_Pos_10 := Parser.Current_Pos;


if Fncall_Pos_10 /= No_Token_Index then

   Row_Pos_7 := Fncall_Pos_10;

      Row_Subres_1_7 := Fncall_Res_10;

else
   Row_Pos_7 := No_Token_Index;
   goto Row_Exit_Label_7_0;

end if;

--  End row_submatch


<<Row_Exit_Label_7_0>>

--  End row_code



if Row_Pos_7 = No_Token_Index then
        Row_Subres_1_7 :=
           null;


    Row_Pos_7 := Row_Pos_6;
end if;

--  End opt_code


if Row_Pos_7 /= No_Token_Index then

   Row_Pos_6 := Row_Pos_7;

      Row_Subres_1_6 := Row_Subres_1_7;

else
   Row_Pos_6 := No_Token_Index;
   goto Row_Exit_Label_6_0;

end if;

--  End row_submatch


<<Row_Exit_Label_6_0>>

--  End row_code


if Row_Pos_6 /= No_Token_Index then

   Transform_Res_7 := String_Literal_At
     (String_Literal_At_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_7.Unit := Parser.Unit;
   Transform_Res_7.Token_Start := pos;
   Transform_Res_7.Token_End := (if Row_Pos_6 = pos
                        then pos
                        else Row_Pos_6 - 1);

      Transform_Res_7.F_Str_Lit :=
            String_Literal (Row_Subres_0_6);

         if Row_Subres_0_6 /= null then
            Row_Subres_0_6.Parent := GPR_Node (Transform_Res_7);
         end if;
      Transform_Res_7.F_At_Lit :=
            Num_Literal (Row_Subres_1_6);

         if Row_Subres_1_6 /= null then
            Row_Subres_1_6.Parent := GPR_Node (Transform_Res_7);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (String_Literal_At_Transform_Parse_0_Memo,
        Row_Pos_6 /= No_Token_Index,
        Transform_Res_7,
        Pos,
        Row_Pos_6);


   Parser.Current_Pos := Row_Pos_6;

   return Transform_Res_7;
end String_Literal_At_Transform_Parse_0;

   


Variable_Reference_Transform_Parse_0_Memo : Variable_Reference_Memos.Memo_Type;

function Variable_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Variable_Reference
is
      Row_Pos_8 : Token_Index
         := No_Token_Index;
      Fncall_Pos_13 : Token_Index
         := No_Token_Index;
      Fncall_Res_13 : Identifier
         := null;
      Row_Subres_0_8 : Identifier
         := null;
      Row_Pos_9 : Token_Index
         := No_Token_Index;
      Tk_Pos_13 : Token_Index
         := No_Token_Index;
      Tk_Res_13 : Token_Index
         := No_Token_Index;
      Fncall_Pos_14 : Token_Index
         := No_Token_Index;
      Fncall_Res_14 : Identifier
         := null;
      Row_Subres_1_9 : Identifier
         := null;
      Row_Subres_1_8 : Identifier
         := null;
      Row_Pos_10 : Token_Index
         := No_Token_Index;
      Tk_Pos_14 : Token_Index
         := No_Token_Index;
      Tk_Res_14 : Token_Index
         := No_Token_Index;
      Fncall_Pos_15 : Token_Index
         := No_Token_Index;
      Fncall_Res_15 : Attribute_Reference
         := null;
      Row_Subres_1_10 : Attribute_Reference
         := null;
      Row_Subres_2_4 : Attribute_Reference
         := null;
      Transform_Res_8 : Variable_Reference
         := null;


   M : Variable_Reference_Memos.Memo_Entry := Get (Variable_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_8 := M.Instance;
      return Transform_Res_8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_8 := pos;


--  Start row_submatch


Fncall_Res_13 := Identifier_Transform_Parse_0(Parser, Row_Pos_8);
Fncall_Pos_13 := Parser.Current_Pos;


if Fncall_Pos_13 /= No_Token_Index then

   Row_Pos_8 := Fncall_Pos_13;

      Row_Subres_0_8 := Fncall_Res_13;

else
   Row_Pos_8 := No_Token_Index;
   goto Row_Exit_Label_8_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_9 := Row_Pos_8;


--  Start row_submatch


--  Start tok_code

Tk_Res_13 := Row_Pos_9;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_13));
begin
   if T.Kind /= GPR_Dot then
       Tk_Pos_13 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_9 then
           Parser.Last_Fail.Pos := Row_Pos_9;
           Parser.Last_Fail.Expected_Token_Id := GPR_Dot;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_13 := Row_Pos_9 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_13 /= No_Token_Index then

   Row_Pos_9 := Tk_Pos_13;


else
   Row_Pos_9 := No_Token_Index;
   goto Row_Exit_Label_9_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_14 := Identifier_Transform_Parse_0(Parser, Row_Pos_9);
Fncall_Pos_14 := Parser.Current_Pos;


if Fncall_Pos_14 /= No_Token_Index then

   Row_Pos_9 := Fncall_Pos_14;

      Row_Subres_1_9 := Fncall_Res_14;

else
   Row_Pos_9 := No_Token_Index;
   goto Row_Exit_Label_9_0;

end if;

--  End row_submatch


<<Row_Exit_Label_9_0>>

--  End row_code



if Row_Pos_9 = No_Token_Index then
        Row_Subres_1_9 :=
           null;


    Row_Pos_9 := Row_Pos_8;
end if;

--  End opt_code


if Row_Pos_9 /= No_Token_Index then

   Row_Pos_8 := Row_Pos_9;

      Row_Subres_1_8 := Row_Subres_1_9;

else
   Row_Pos_8 := No_Token_Index;
   goto Row_Exit_Label_8_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_10 := Row_Pos_8;


--  Start row_submatch


--  Start tok_code

Tk_Res_14 := Row_Pos_10;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_14));
begin
   if T.Kind /= GPR_Tick then
       Tk_Pos_14 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_10 then
           Parser.Last_Fail.Pos := Row_Pos_10;
           Parser.Last_Fail.Expected_Token_Id := GPR_Tick;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_14 := Row_Pos_10 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_14 /= No_Token_Index then

   Row_Pos_10 := Tk_Pos_14;


else
   Row_Pos_10 := No_Token_Index;
   goto Row_Exit_Label_10_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_15 := Attribute_Reference_Transform_Parse_0(Parser, Row_Pos_10);
Fncall_Pos_15 := Parser.Current_Pos;


if Fncall_Pos_15 /= No_Token_Index then

   Row_Pos_10 := Fncall_Pos_15;

      Row_Subres_1_10 := Fncall_Res_15;

else
   Row_Pos_10 := No_Token_Index;
   goto Row_Exit_Label_10_0;

end if;

--  End row_submatch


<<Row_Exit_Label_10_0>>

--  End row_code



if Row_Pos_10 = No_Token_Index then
        Row_Subres_1_10 :=
           null;


    Row_Pos_10 := Row_Pos_8;
end if;

--  End opt_code


if Row_Pos_10 /= No_Token_Index then

   Row_Pos_8 := Row_Pos_10;

      Row_Subres_2_4 := Row_Subres_1_10;

else
   Row_Pos_8 := No_Token_Index;
   goto Row_Exit_Label_8_0;

end if;

--  End row_submatch


<<Row_Exit_Label_8_0>>

--  End row_code


if Row_Pos_8 /= No_Token_Index then

   Transform_Res_8 := Variable_Reference
     (Variable_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_8.Unit := Parser.Unit;
   Transform_Res_8.Token_Start := pos;
   Transform_Res_8.Token_End := (if Row_Pos_8 = pos
                        then pos
                        else Row_Pos_8 - 1);

      Transform_Res_8.F_Variable_Name1 :=
            Identifier (Row_Subres_0_8);

         if Row_Subres_0_8 /= null then
            Row_Subres_0_8.Parent := GPR_Node (Transform_Res_8);
         end if;
      Transform_Res_8.F_Variable_Name2 :=
            Identifier (Row_Subres_1_8);

         if Row_Subres_1_8 /= null then
            Row_Subres_1_8.Parent := GPR_Node (Transform_Res_8);
         end if;
      Transform_Res_8.F_Attribute_Ref :=
            Attribute_Reference (Row_Subres_2_4);

         if Row_Subres_2_4 /= null then
            Row_Subres_2_4.Parent := GPR_Node (Transform_Res_8);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Variable_Reference_Transform_Parse_0_Memo,
        Row_Pos_8 /= No_Token_Index,
        Transform_Res_8,
        Pos,
        Row_Pos_8);


   Parser.Current_Pos := Row_Pos_8;

   return Transform_Res_8;
end Variable_Reference_Transform_Parse_0;

   


Term_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;

function Term_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node
is
      Or_Pos_1 : Token_Index
         := No_Token_Index;
      Or_Res_1 : GPR_Node
         := null;
      Fncall_Pos_8 : Token_Index
         := No_Token_Index;
      Fncall_Res_8 : Expr_List
         := null;
      Fncall_Pos_11 : Token_Index
         := No_Token_Index;
      Fncall_Res_11 : String_Literal_At
         := null;
      Fncall_Pos_12 : Token_Index
         := No_Token_Index;
      Fncall_Res_12 : Builtin_Function_Call
         := null;
      Fncall_Pos_16 : Token_Index
         := No_Token_Index;
      Fncall_Res_16 : Variable_Reference
         := null;
      Fncall_Pos_17 : Token_Index
         := No_Token_Index;
      Fncall_Res_17 : Project_Reference
         := null;


   M : GPR_Node_Memos.Memo_Entry := Get (Term_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_1 := M.Instance;
      return Or_Res_1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_1;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_1 := No_Token_Index;
Or_Res_1 := null;
    
Fncall_Res_8 := Expression_List_Transform_Parse_0(Parser, pos);
Fncall_Pos_8 := Parser.Current_Pos;

    if Fncall_Pos_8 /= No_Token_Index then
        Or_Pos_1 := Fncall_Pos_8;
        Or_Res_1 := GPR_Node
          (Fncall_Res_8);
        goto Exit_Or_1;
    end if;
    
Fncall_Res_11 := String_Literal_At_Transform_Parse_0(Parser, pos);
Fncall_Pos_11 := Parser.Current_Pos;

    if Fncall_Pos_11 /= No_Token_Index then
        Or_Pos_1 := Fncall_Pos_11;
        Or_Res_1 := GPR_Node
          (Fncall_Res_11);
        goto Exit_Or_1;
    end if;
    
Fncall_Res_12 := Builtin_Function_Call_Transform_Parse_0(Parser, pos);
Fncall_Pos_12 := Parser.Current_Pos;

    if Fncall_Pos_12 /= No_Token_Index then
        Or_Pos_1 := Fncall_Pos_12;
        Or_Res_1 := GPR_Node
          (Fncall_Res_12);
        goto Exit_Or_1;
    end if;
    
Fncall_Res_16 := Variable_Reference_Transform_Parse_0(Parser, pos);
Fncall_Pos_16 := Parser.Current_Pos;

    if Fncall_Pos_16 /= No_Token_Index then
        Or_Pos_1 := Fncall_Pos_16;
        Or_Res_1 := GPR_Node
          (Fncall_Res_16);
        goto Exit_Or_1;
    end if;
    
Fncall_Res_17 := Project_Reference_Transform_Parse_0(Parser, pos);
Fncall_Pos_17 := Parser.Current_Pos;

    if Fncall_Pos_17 /= No_Token_Index then
        Or_Pos_1 := Fncall_Pos_17;
        Or_Res_1 := GPR_Node
          (Fncall_Res_17);
        goto Exit_Or_1;
    end if;
<<Exit_Or_1>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Term_Or_Parse_0_Memo,
        Or_Pos_1 /= No_Token_Index,
        Or_Res_1,
        Pos,
        Or_Pos_1);


   Parser.Current_Pos := Or_Pos_1;

   return Or_Res_1;
end Term_Or_Parse_0;

   


Expression_Transform_Parse_0_Memo : Term_List_Memos.Memo_Type;

function Expression_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Term_List
is
      Lst_Pos_1 : Token_Index
         := No_Token_Index;
      Lst_Res_1 : List_GPR_Node
         := null;
      Lst_Cpos_2 : Token_Index
         := No_Token_Index;
      Fncall_Pos_18 : Token_Index
         := No_Token_Index;
      Fncall_Res_18 : GPR_Node
         := null;
      Tk_Pos_15 : Token_Index
         := No_Token_Index;
      Tk_Res_15 : Token_Index
         := No_Token_Index;
      Transform_Res_9 : Term_List
         := null;


   M : Term_List_Memos.Memo_Entry := Get (Expression_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_9 := M.Instance;
      return Transform_Res_9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_9;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start list_code

    Lst_Pos_1 := No_Token_Index;

Lst_Res_1 := null;
Lst_Cpos_2 := pos;

loop
   
Fncall_Res_18 := Term_Or_Parse_0(Parser, Lst_Cpos_2);
Fncall_Pos_18 := Parser.Current_Pos;


   exit when Fncall_Pos_18 = No_Token_Index;

   Lst_Pos_1 := Fncall_Pos_18;
   Lst_Cpos_2 := Fncall_Pos_18;



      

      if Lst_Res_1 = null then
         Lst_Res_1 := List_GPR_Node
           (List_GPR_Node_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_1.Vec :=
           Lists_GPR_Node.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_GPR_Node.Node_Vectors.Append
        (Lst_Res_1.Vec, Fncall_Res_18);

         if Fncall_Res_18 /= null then
            Fncall_Res_18.Parent :=
              GPR_Node (Lst_Res_1);
         end if;

      
--  Start tok_code

Tk_Res_15 := Lst_Cpos_2;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_15));
begin
   if T.Kind /= GPR_Amp then
       Tk_Pos_15 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_2 then
           Parser.Last_Fail.Pos := Lst_Cpos_2;
           Parser.Last_Fail.Expected_Token_Id := GPR_Amp;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_15 := Lst_Cpos_2 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_15 /= No_Token_Index then
          Lst_Cpos_2 := Tk_Pos_15;
      else
         exit;
      end if;

end loop;

if Lst_Res_1 /= null then
   Lst_Res_1.Unit := Parser.Unit;
   Lst_Res_1.Token_Start := pos;
   Lst_Res_1.Token_End := (if Lst_Cpos_2 = pos
                        then pos
                        else Lst_Cpos_2 - 1);
end if;


--  End list_code


if Lst_Pos_1 /= No_Token_Index then

   Transform_Res_9 := Term_List
     (Term_List_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_9.Unit := Parser.Unit;
   Transform_Res_9.Token_Start := pos;
   Transform_Res_9.Token_End := (if Lst_Pos_1 = pos
                        then pos
                        else Lst_Pos_1 - 1);

      Transform_Res_9.F_Terms :=
            List_GPR_Node (Lst_Res_1);

         if Lst_Res_1 /= null then
            Lst_Res_1.Parent := GPR_Node (Transform_Res_9);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Expression_Transform_Parse_0_Memo,
        Lst_Pos_1 /= No_Token_Index,
        Transform_Res_9,
        Pos,
        Lst_Pos_1);


   Parser.Current_Pos := Lst_Pos_1;

   return Transform_Res_9;
end Expression_Transform_Parse_0;

   


Expression_List_Transform_Parse_0_Memo : Expr_List_Memos.Memo_Type;

function Expression_List_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Expr_List
is
      Row_Pos_5 : Token_Index
         := No_Token_Index;
      Tk_Pos_10 : Token_Index
         := No_Token_Index;
      Tk_Res_10 : Token_Index
         := No_Token_Index;
      Lst_Pos_2 : Token_Index
         := No_Token_Index;
      Lst_Res_2 : List_Term_List
         := null;
      Lst_Cpos_1 : Token_Index
         := No_Token_Index;
      Fncall_Pos_19 : Token_Index
         := No_Token_Index;
      Fncall_Res_19 : Term_List
         := null;
      Tk_Pos_16 : Token_Index
         := No_Token_Index;
      Tk_Res_16 : Token_Index
         := No_Token_Index;
      Row_Subres_1_5 : List_Term_List
         := null;
      Tk_Pos_17 : Token_Index
         := No_Token_Index;
      Tk_Res_17 : Token_Index
         := No_Token_Index;
      Transform_Res_10 : Expr_List
         := null;


   M : Expr_List_Memos.Memo_Entry := Get (Expression_List_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_10 := M.Instance;
      return Transform_Res_10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_10;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_5 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_10 := Row_Pos_5;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_10));
begin
   if T.Kind /= GPR_Par_Open then
       Tk_Pos_10 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_5 then
           Parser.Last_Fail.Pos := Row_Pos_5;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Open;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_10 := Row_Pos_5 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_10 /= No_Token_Index then

   Row_Pos_5 := Tk_Pos_10;


else
   Row_Pos_5 := No_Token_Index;
   goto Row_Exit_Label_5_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start list_code

    Lst_Pos_2 := Row_Pos_5;

Lst_Res_2 := null;
Lst_Cpos_1 := Row_Pos_5;

loop
   
Fncall_Res_19 := Expression_Transform_Parse_0(Parser, Lst_Cpos_1);
Fncall_Pos_19 := Parser.Current_Pos;


   exit when Fncall_Pos_19 = No_Token_Index;

   Lst_Pos_2 := Fncall_Pos_19;
   Lst_Cpos_1 := Fncall_Pos_19;



      

      if Lst_Res_2 = null then
         Lst_Res_2 := List_Term_List
           (List_Term_List_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_2.Vec :=
           Lists_Term_List.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_Term_List.Node_Vectors.Append
        (Lst_Res_2.Vec, Fncall_Res_19);

         if Fncall_Res_19 /= null then
            Fncall_Res_19.Parent :=
              GPR_Node (Lst_Res_2);
         end if;

      
--  Start tok_code

Tk_Res_16 := Lst_Cpos_1;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_16));
begin
   if T.Kind /= GPR_Comma then
       Tk_Pos_16 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_1 then
           Parser.Last_Fail.Pos := Lst_Cpos_1;
           Parser.Last_Fail.Expected_Token_Id := GPR_Comma;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_16 := Lst_Cpos_1 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_16 /= No_Token_Index then
          Lst_Cpos_1 := Tk_Pos_16;
      else
         exit;
      end if;

end loop;

if Lst_Res_2 /= null then
   Lst_Res_2.Unit := Parser.Unit;
   Lst_Res_2.Token_Start := Row_Pos_5;
   Lst_Res_2.Token_End := (if Lst_Cpos_1 = Row_Pos_5
                        then Row_Pos_5
                        else Lst_Cpos_1 - 1);
end if;


--  End list_code


if Lst_Pos_2 /= No_Token_Index then

   Row_Pos_5 := Lst_Pos_2;

      Row_Subres_1_5 := Lst_Res_2;

else
   Row_Pos_5 := No_Token_Index;
   goto Row_Exit_Label_5_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_17 := Row_Pos_5;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_17));
begin
   if T.Kind /= GPR_Par_Close then
       Tk_Pos_17 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_5 then
           Parser.Last_Fail.Pos := Row_Pos_5;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Close;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_17 := Row_Pos_5 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_17 /= No_Token_Index then

   Row_Pos_5 := Tk_Pos_17;


else
   Row_Pos_5 := No_Token_Index;
   goto Row_Exit_Label_5_0;

end if;

--  End row_submatch


<<Row_Exit_Label_5_0>>

--  End row_code


if Row_Pos_5 /= No_Token_Index then

   Transform_Res_10 := Expr_List
     (Expr_List_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_10.Unit := Parser.Unit;
   Transform_Res_10.Token_Start := pos;
   Transform_Res_10.Token_End := (if Row_Pos_5 = pos
                        then pos
                        else Row_Pos_5 - 1);

      Transform_Res_10.F_Exprs :=
            List_Term_List (Row_Subres_1_5);

         if Row_Subres_1_5 /= null then
            Row_Subres_1_5.Parent := GPR_Node (Transform_Res_10);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Expression_List_Transform_Parse_0_Memo,
        Row_Pos_5 /= No_Token_Index,
        Transform_Res_10,
        Pos,
        Row_Pos_5);


   Parser.Current_Pos := Row_Pos_5;

   return Transform_Res_10;
end Expression_List_Transform_Parse_0;

   


Builtin_Function_Call_Transform_Parse_0_Memo : Builtin_Function_Call_Memos.Memo_Type;

function Builtin_Function_Call_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Builtin_Function_Call
is
      Row_Pos_4 : Token_Index
         := No_Token_Index;
      Fncall_Pos_7 : Token_Index
         := No_Token_Index;
      Fncall_Res_7 : Identifier
         := null;
      Row_Subres_0_4 : Identifier
         := null;
      Fncall_Pos_20 : Token_Index
         := No_Token_Index;
      Fncall_Res_20 : Expr_List
         := null;
      Row_Subres_1_4 : Expr_List
         := null;
      Transform_Res_11 : Builtin_Function_Call
         := null;


   M : Builtin_Function_Call_Memos.Memo_Entry := Get (Builtin_Function_Call_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_11 := M.Instance;
      return Transform_Res_11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_11;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_4 := pos;


--  Start row_submatch


Fncall_Res_7 := Identifier_Transform_Parse_0(Parser, Row_Pos_4);
Fncall_Pos_7 := Parser.Current_Pos;


if Fncall_Pos_7 /= No_Token_Index then

   Row_Pos_4 := Fncall_Pos_7;

      Row_Subres_0_4 := Fncall_Res_7;

else
   Row_Pos_4 := No_Token_Index;
   goto Row_Exit_Label_4_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_20 := Expression_List_Transform_Parse_0(Parser, Row_Pos_4);
Fncall_Pos_20 := Parser.Current_Pos;


if Fncall_Pos_20 /= No_Token_Index then

   Row_Pos_4 := Fncall_Pos_20;

      Row_Subres_1_4 := Fncall_Res_20;

else
   Row_Pos_4 := No_Token_Index;
   goto Row_Exit_Label_4_0;

end if;

--  End row_submatch


<<Row_Exit_Label_4_0>>

--  End row_code


if Row_Pos_4 /= No_Token_Index then

   Transform_Res_11 := Builtin_Function_Call
     (Builtin_Function_Call_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_11.Unit := Parser.Unit;
   Transform_Res_11.Token_Start := pos;
   Transform_Res_11.Token_End := (if Row_Pos_4 = pos
                        then pos
                        else Row_Pos_4 - 1);

      Transform_Res_11.F_Function_Name :=
            Identifier (Row_Subres_0_4);

         if Row_Subres_0_4 /= null then
            Row_Subres_0_4.Parent := GPR_Node (Transform_Res_11);
         end if;
      Transform_Res_11.F_Parameters :=
            Expr_List (Row_Subres_1_4);

         if Row_Subres_1_4 /= null then
            Row_Subres_1_4.Parent := GPR_Node (Transform_Res_11);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Builtin_Function_Call_Transform_Parse_0_Memo,
        Row_Pos_4 /= No_Token_Index,
        Transform_Res_11,
        Pos,
        Row_Pos_4);


   Parser.Current_Pos := Row_Pos_4;

   return Transform_Res_11;
end Builtin_Function_Call_Transform_Parse_0;

   


Package_Extension_Transform_Parse_0_Memo : Package_Extension_Memos.Memo_Type;

function Package_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Extension
is
      Row_Pos_13 : Token_Index
         := No_Token_Index;
      Tk_Pos_19 : Token_Index
         := No_Token_Index;
      Tk_Res_19 : Token_Index
         := No_Token_Index;
      Fncall_Pos_23 : Token_Index
         := No_Token_Index;
      Fncall_Res_23 : Identifier
         := null;
      Row_Subres_1_13 : Identifier
         := null;
      Tk_Pos_20 : Token_Index
         := No_Token_Index;
      Tk_Res_20 : Token_Index
         := No_Token_Index;
      Fncall_Pos_24 : Token_Index
         := No_Token_Index;
      Fncall_Res_24 : Identifier
         := null;
      Row_Subres_3_2 : Identifier
         := null;
      Transform_Res_12 : Package_Extension
         := null;


   M : Package_Extension_Memos.Memo_Entry := Get (Package_Extension_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_12 := M.Instance;
      return Transform_Res_12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_12;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_13 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_19 := Row_Pos_13;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_19));
begin
   if T.Kind /= GPR_Extends then
       Tk_Pos_19 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_13 then
           Parser.Last_Fail.Pos := Row_Pos_13;
           Parser.Last_Fail.Expected_Token_Id := GPR_Extends;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_19 := Row_Pos_13 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_19 /= No_Token_Index then

   Row_Pos_13 := Tk_Pos_19;


else
   Row_Pos_13 := No_Token_Index;
   goto Row_Exit_Label_13_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_23 := Identifier_Transform_Parse_0(Parser, Row_Pos_13);
Fncall_Pos_23 := Parser.Current_Pos;


if Fncall_Pos_23 /= No_Token_Index then

   Row_Pos_13 := Fncall_Pos_23;

      Row_Subres_1_13 := Fncall_Res_23;

else
   Row_Pos_13 := No_Token_Index;
   goto Row_Exit_Label_13_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_20 := Row_Pos_13;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_20));
begin
   if T.Kind /= GPR_Dot then
       Tk_Pos_20 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_13 then
           Parser.Last_Fail.Pos := Row_Pos_13;
           Parser.Last_Fail.Expected_Token_Id := GPR_Dot;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_20 := Row_Pos_13 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_20 /= No_Token_Index then

   Row_Pos_13 := Tk_Pos_20;


else
   Row_Pos_13 := No_Token_Index;
   goto Row_Exit_Label_13_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_24 := Identifier_Transform_Parse_0(Parser, Row_Pos_13);
Fncall_Pos_24 := Parser.Current_Pos;


if Fncall_Pos_24 /= No_Token_Index then

   Row_Pos_13 := Fncall_Pos_24;

      Row_Subres_3_2 := Fncall_Res_24;

else
   Row_Pos_13 := No_Token_Index;
   goto Row_Exit_Label_13_0;

end if;

--  End row_submatch


<<Row_Exit_Label_13_0>>

--  End row_code


if Row_Pos_13 /= No_Token_Index then

   Transform_Res_12 := Package_Extension
     (Package_Extension_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_12.Unit := Parser.Unit;
   Transform_Res_12.Token_Start := pos;
   Transform_Res_12.Token_End := (if Row_Pos_13 = pos
                        then pos
                        else Row_Pos_13 - 1);

      Transform_Res_12.F_Prj_Name :=
            Identifier (Row_Subres_1_13);

         if Row_Subres_1_13 /= null then
            Row_Subres_1_13.Parent := GPR_Node (Transform_Res_12);
         end if;
      Transform_Res_12.F_Pkg_Name :=
            Identifier (Row_Subres_3_2);

         if Row_Subres_3_2 /= null then
            Row_Subres_3_2.Parent := GPR_Node (Transform_Res_12);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Package_Extension_Transform_Parse_0_Memo,
        Row_Pos_13 /= No_Token_Index,
        Transform_Res_12,
        Pos,
        Row_Pos_13);


   Parser.Current_Pos := Row_Pos_13;

   return Transform_Res_12;
end Package_Extension_Transform_Parse_0;

   


Variable_Decl_Transform_Parse_0_Memo : Variable_Decl_Memos.Memo_Type;

function Variable_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Variable_Decl
is
      Row_Pos_15 : Token_Index
         := No_Token_Index;
      Fncall_Pos_26 : Token_Index
         := No_Token_Index;
      Fncall_Res_26 : Identifier
         := null;
      Row_Subres_0_15 : Identifier
         := null;
      Row_Pos_16 : Token_Index
         := No_Token_Index;
      Tk_Pos_22 : Token_Index
         := No_Token_Index;
      Tk_Res_22 : Token_Index
         := No_Token_Index;
      Fncall_Pos_27 : Token_Index
         := No_Token_Index;
      Fncall_Res_27 : Expr
         := null;
      Row_Subres_1_16 : Expr
         := null;
      Row_Subres_1_15 : Expr
         := null;
      Tk_Pos_23 : Token_Index
         := No_Token_Index;
      Tk_Res_23 : Token_Index
         := No_Token_Index;
      Fncall_Pos_28 : Token_Index
         := No_Token_Index;
      Fncall_Res_28 : Term_List
         := null;
      Row_Subres_3_3 : Term_List
         := null;
      Transform_Res_13 : Variable_Decl
         := null;


   M : Variable_Decl_Memos.Memo_Entry := Get (Variable_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_13 := M.Instance;
      return Transform_Res_13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_13;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_15 := pos;


--  Start row_submatch


Fncall_Res_26 := Identifier_Transform_Parse_0(Parser, Row_Pos_15);
Fncall_Pos_26 := Parser.Current_Pos;


if Fncall_Pos_26 /= No_Token_Index then

   Row_Pos_15 := Fncall_Pos_26;

      Row_Subres_0_15 := Fncall_Res_26;

else
   Row_Pos_15 := No_Token_Index;
   goto Row_Exit_Label_15_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_16 := Row_Pos_15;


--  Start row_submatch


--  Start tok_code

Tk_Res_22 := Row_Pos_16;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_22));
begin
   if T.Kind /= GPR_Colon then
       Tk_Pos_22 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_16 then
           Parser.Last_Fail.Pos := Row_Pos_16;
           Parser.Last_Fail.Expected_Token_Id := GPR_Colon;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_22 := Row_Pos_16 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_22 /= No_Token_Index then

   Row_Pos_16 := Tk_Pos_22;


else
   Row_Pos_16 := No_Token_Index;
   goto Row_Exit_Label_16_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_27 := Static_Name_List_Parse_0(Parser, Row_Pos_16);
Fncall_Pos_27 := Parser.Current_Pos;


if Fncall_Pos_27 /= No_Token_Index then

   Row_Pos_16 := Fncall_Pos_27;

      Row_Subres_1_16 := Fncall_Res_27;

else
   Row_Pos_16 := No_Token_Index;
   goto Row_Exit_Label_16_0;

end if;

--  End row_submatch


<<Row_Exit_Label_16_0>>

--  End row_code



if Row_Pos_16 = No_Token_Index then
        Row_Subres_1_16 :=
           null;


    Row_Pos_16 := Row_Pos_15;
end if;

--  End opt_code


if Row_Pos_16 /= No_Token_Index then

   Row_Pos_15 := Row_Pos_16;

      Row_Subres_1_15 := Row_Subres_1_16;

else
   Row_Pos_15 := No_Token_Index;
   goto Row_Exit_Label_15_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_23 := Row_Pos_15;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_23));
begin
   if T.Kind /= GPR_Assign then
       Tk_Pos_23 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_15 then
           Parser.Last_Fail.Pos := Row_Pos_15;
           Parser.Last_Fail.Expected_Token_Id := GPR_Assign;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_23 := Row_Pos_15 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_23 /= No_Token_Index then

   Row_Pos_15 := Tk_Pos_23;


else
   Row_Pos_15 := No_Token_Index;
   goto Row_Exit_Label_15_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_28 := Expression_Transform_Parse_0(Parser, Row_Pos_15);
Fncall_Pos_28 := Parser.Current_Pos;


if Fncall_Pos_28 /= No_Token_Index then

   Row_Pos_15 := Fncall_Pos_28;

      Row_Subres_3_3 := Fncall_Res_28;

else
   Row_Pos_15 := No_Token_Index;
   goto Row_Exit_Label_15_0;

end if;

--  End row_submatch


<<Row_Exit_Label_15_0>>

--  End row_code


if Row_Pos_15 /= No_Token_Index then

   Transform_Res_13 := Variable_Decl
     (Variable_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_13.Unit := Parser.Unit;
   Transform_Res_13.Token_Start := pos;
   Transform_Res_13.Token_End := (if Row_Pos_15 = pos
                        then pos
                        else Row_Pos_15 - 1);

      Transform_Res_13.F_Var_Name :=
            Identifier (Row_Subres_0_15);

         if Row_Subres_0_15 /= null then
            Row_Subres_0_15.Parent := GPR_Node (Transform_Res_13);
         end if;
      Transform_Res_13.F_Var_Type :=
            Expr (Row_Subres_1_15);

         if Row_Subres_1_15 /= null then
            Row_Subres_1_15.Parent := GPR_Node (Transform_Res_13);
         end if;
      Transform_Res_13.F_Expr :=
            Term_List (Row_Subres_3_3);

         if Row_Subres_3_3 /= null then
            Row_Subres_3_3.Parent := GPR_Node (Transform_Res_13);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Variable_Decl_Transform_Parse_0_Memo,
        Row_Pos_15 /= No_Token_Index,
        Transform_Res_13,
        Pos,
        Row_Pos_15);


   Parser.Current_Pos := Row_Pos_15;

   return Transform_Res_13;
end Variable_Decl_Transform_Parse_0;

   


Associative_Array_Index_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;

function Associative_Array_Index_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node
is
      Or_Pos_4 : Token_Index
         := No_Token_Index;
      Or_Res_4 : GPR_Node
         := null;
      Fncall_Pos_31 : Token_Index
         := No_Token_Index;
      Fncall_Res_31 : Others_Designator
         := null;
      Fncall_Pos_32 : Token_Index
         := No_Token_Index;
      Fncall_Res_32 : String_Literal_At
         := null;


   M : GPR_Node_Memos.Memo_Entry := Get (Associative_Array_Index_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_4 := M.Instance;
      return Or_Res_4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_4 := No_Token_Index;
Or_Res_4 := null;
    
Fncall_Res_31 := Others_Designator_Transform_Parse_0(Parser, pos);
Fncall_Pos_31 := Parser.Current_Pos;

    if Fncall_Pos_31 /= No_Token_Index then
        Or_Pos_4 := Fncall_Pos_31;
        Or_Res_4 := GPR_Node
          (Fncall_Res_31);
        goto Exit_Or_2;
    end if;
    
Fncall_Res_32 := String_Literal_At_Transform_Parse_0(Parser, pos);
Fncall_Pos_32 := Parser.Current_Pos;

    if Fncall_Pos_32 /= No_Token_Index then
        Or_Pos_4 := Fncall_Pos_32;
        Or_Res_4 := GPR_Node
          (Fncall_Res_32);
        goto Exit_Or_2;
    end if;
<<Exit_Or_2>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Associative_Array_Index_Or_Parse_0_Memo,
        Or_Pos_4 /= No_Token_Index,
        Or_Res_4,
        Pos,
        Or_Pos_4);


   Parser.Current_Pos := Or_Pos_4;

   return Or_Res_4;
end Associative_Array_Index_Or_Parse_0;

   


Attribute_Decl_Transform_Parse_0_Memo : Attribute_Decl_Memos.Memo_Type;

function Attribute_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Attribute_Decl
is
      Row_Pos_17 : Token_Index
         := No_Token_Index;
      Tk_Pos_24 : Token_Index
         := No_Token_Index;
      Tk_Res_24 : Token_Index
         := No_Token_Index;
      Fncall_Pos_30 : Token_Index
         := No_Token_Index;
      Fncall_Res_30 : Identifier
         := null;
      Row_Subres_1_17 : Identifier
         := null;
      Row_Pos_18 : Token_Index
         := No_Token_Index;
      Tk_Pos_25 : Token_Index
         := No_Token_Index;
      Tk_Res_25 : Token_Index
         := No_Token_Index;
      Fncall_Pos_33 : Token_Index
         := No_Token_Index;
      Fncall_Res_33 : GPR_Node
         := null;
      Row_Subres_1_18 : GPR_Node
         := null;
      Tk_Pos_26 : Token_Index
         := No_Token_Index;
      Tk_Res_26 : Token_Index
         := No_Token_Index;
      Row_Subres_2_9 : GPR_Node
         := null;
      Tk_Pos_27 : Token_Index
         := No_Token_Index;
      Tk_Res_27 : Token_Index
         := No_Token_Index;
      Fncall_Pos_34 : Token_Index
         := No_Token_Index;
      Fncall_Res_34 : Term_List
         := null;
      Row_Subres_4_1 : Term_List
         := null;
      Transform_Res_14 : Attribute_Decl
         := null;


   M : Attribute_Decl_Memos.Memo_Entry := Get (Attribute_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_14 := M.Instance;
      return Transform_Res_14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_14;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_17 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_24 := Row_Pos_17;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_24));
begin
   if T.Kind /= GPR_For then
       Tk_Pos_24 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_17 then
           Parser.Last_Fail.Pos := Row_Pos_17;
           Parser.Last_Fail.Expected_Token_Id := GPR_For;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_24 := Row_Pos_17 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_24 /= No_Token_Index then

   Row_Pos_17 := Tk_Pos_24;


else
   Row_Pos_17 := No_Token_Index;
   goto Row_Exit_Label_17_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_30 := Identifier_Transform_Parse_0(Parser, Row_Pos_17);
Fncall_Pos_30 := Parser.Current_Pos;


if Fncall_Pos_30 /= No_Token_Index then

   Row_Pos_17 := Fncall_Pos_30;

      Row_Subres_1_17 := Fncall_Res_30;

else
   Row_Pos_17 := No_Token_Index;
   goto Row_Exit_Label_17_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start row_code

Row_Pos_18 := Row_Pos_17;


--  Start row_submatch


--  Start tok_code

Tk_Res_25 := Row_Pos_18;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_25));
begin
   if T.Kind /= GPR_Par_Open then
       Tk_Pos_25 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_18 then
           Parser.Last_Fail.Pos := Row_Pos_18;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Open;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_25 := Row_Pos_18 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_25 /= No_Token_Index then

   Row_Pos_18 := Tk_Pos_25;


else
   Row_Pos_18 := No_Token_Index;
   goto Row_Exit_Label_18_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_33 := Associative_Array_Index_Or_Parse_0(Parser, Row_Pos_18);
Fncall_Pos_33 := Parser.Current_Pos;


if Fncall_Pos_33 /= No_Token_Index then

   Row_Pos_18 := Fncall_Pos_33;

      Row_Subres_1_18 := Fncall_Res_33;

else
   Row_Pos_18 := No_Token_Index;
   goto Row_Exit_Label_18_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_26 := Row_Pos_18;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_26));
begin
   if T.Kind /= GPR_Par_Close then
       Tk_Pos_26 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_18 then
           Parser.Last_Fail.Pos := Row_Pos_18;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Close;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_26 := Row_Pos_18 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_26 /= No_Token_Index then

   Row_Pos_18 := Tk_Pos_26;


else
   Row_Pos_18 := No_Token_Index;
   goto Row_Exit_Label_18_0;

end if;

--  End row_submatch


<<Row_Exit_Label_18_0>>

--  End row_code



if Row_Pos_18 = No_Token_Index then
        Row_Subres_1_18 :=
           null;


    Row_Pos_18 := Row_Pos_17;
end if;

--  End opt_code


if Row_Pos_18 /= No_Token_Index then

   Row_Pos_17 := Row_Pos_18;

      Row_Subres_2_9 := Row_Subres_1_18;

else
   Row_Pos_17 := No_Token_Index;
   goto Row_Exit_Label_17_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_27 := Row_Pos_17;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_27));
begin
   if T.Kind /= GPR_Use then
       Tk_Pos_27 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_17 then
           Parser.Last_Fail.Pos := Row_Pos_17;
           Parser.Last_Fail.Expected_Token_Id := GPR_Use;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_27 := Row_Pos_17 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_27 /= No_Token_Index then

   Row_Pos_17 := Tk_Pos_27;


else
   Row_Pos_17 := No_Token_Index;
   goto Row_Exit_Label_17_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_34 := Expression_Transform_Parse_0(Parser, Row_Pos_17);
Fncall_Pos_34 := Parser.Current_Pos;


if Fncall_Pos_34 /= No_Token_Index then

   Row_Pos_17 := Fncall_Pos_34;

      Row_Subres_4_1 := Fncall_Res_34;

else
   Row_Pos_17 := No_Token_Index;
   goto Row_Exit_Label_17_0;

end if;

--  End row_submatch


<<Row_Exit_Label_17_0>>

--  End row_code


if Row_Pos_17 /= No_Token_Index then

   Transform_Res_14 := Attribute_Decl
     (Attribute_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_14.Unit := Parser.Unit;
   Transform_Res_14.Token_Start := pos;
   Transform_Res_14.Token_End := (if Row_Pos_17 = pos
                        then pos
                        else Row_Pos_17 - 1);

      Transform_Res_14.F_Attr_Name :=
            Identifier (Row_Subres_1_17);

         if Row_Subres_1_17 /= null then
            Row_Subres_1_17.Parent := GPR_Node (Transform_Res_14);
         end if;
      Transform_Res_14.F_Attr_Index :=
            GPR_Node (Row_Subres_2_9);

         if Row_Subres_2_9 /= null then
            Row_Subres_2_9.Parent := GPR_Node (Transform_Res_14);
         end if;
      Transform_Res_14.F_Expr :=
            Term_List (Row_Subres_4_1);

         if Row_Subres_4_1 /= null then
            Row_Subres_4_1.Parent := GPR_Node (Transform_Res_14);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Attribute_Decl_Transform_Parse_0_Memo,
        Row_Pos_17 /= No_Token_Index,
        Transform_Res_14,
        Pos,
        Row_Pos_17);


   Parser.Current_Pos := Row_Pos_17;

   return Transform_Res_14;
end Attribute_Decl_Transform_Parse_0;

   


Choice_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;

function Choice_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node
is
      Or_Pos_5 : Token_Index
         := No_Token_Index;
      Or_Res_5 : GPR_Node
         := null;
      Fncall_Pos_37 : Token_Index
         := No_Token_Index;
      Fncall_Res_37 : String_Literal
         := null;
      Fncall_Pos_38 : Token_Index
         := No_Token_Index;
      Fncall_Res_38 : Others_Designator
         := null;


   M : GPR_Node_Memos.Memo_Entry := Get (Choice_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_5 := M.Instance;
      return Or_Res_5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_5 := No_Token_Index;
Or_Res_5 := null;
    
Fncall_Res_37 := String_Literal_Transform_Parse_0(Parser, pos);
Fncall_Pos_37 := Parser.Current_Pos;

    if Fncall_Pos_37 /= No_Token_Index then
        Or_Pos_5 := Fncall_Pos_37;
        Or_Res_5 := GPR_Node
          (Fncall_Res_37);
        goto Exit_Or_3;
    end if;
    
Fncall_Res_38 := Others_Designator_Transform_Parse_0(Parser, pos);
Fncall_Pos_38 := Parser.Current_Pos;

    if Fncall_Pos_38 /= No_Token_Index then
        Or_Pos_5 := Fncall_Pos_38;
        Or_Res_5 := GPR_Node
          (Fncall_Res_38);
        goto Exit_Or_3;
    end if;
<<Exit_Or_3>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Choice_Or_Parse_0_Memo,
        Or_Pos_5 /= No_Token_Index,
        Or_Res_5,
        Pos,
        Or_Pos_5);


   Parser.Current_Pos := Or_Pos_5;

   return Or_Res_5;
end Choice_Or_Parse_0;

   


Discrete_Choice_List_List_Parse_0_Memo : List_GPR_Node_Memos.Memo_Type;

function Discrete_Choice_List_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node
is
      Lst_Pos_3 : Token_Index
         := No_Token_Index;
      Lst_Res_3 : List_GPR_Node
         := null;
      Lst_Cpos_5 : Token_Index
         := No_Token_Index;
      Fncall_Pos_39 : Token_Index
         := No_Token_Index;
      Fncall_Res_39 : GPR_Node
         := null;
      Tk_Pos_31 : Token_Index
         := No_Token_Index;
      Tk_Res_31 : Token_Index
         := No_Token_Index;


   M : List_GPR_Node_Memos.Memo_Entry := Get (Discrete_Choice_List_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Lst_Res_3 := M.Instance;
      return Lst_Res_3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Lst_Res_3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    Lst_Pos_3 := No_Token_Index;

Lst_Res_3 := null;
Lst_Cpos_5 := pos;

loop
   
Fncall_Res_39 := Choice_Or_Parse_0(Parser, Lst_Cpos_5);
Fncall_Pos_39 := Parser.Current_Pos;


   exit when Fncall_Pos_39 = No_Token_Index;

   Lst_Pos_3 := Fncall_Pos_39;
   Lst_Cpos_5 := Fncall_Pos_39;



      

      if Lst_Res_3 = null then
         Lst_Res_3 := List_GPR_Node
           (List_GPR_Node_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_3.Vec :=
           Lists_GPR_Node.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_GPR_Node.Node_Vectors.Append
        (Lst_Res_3.Vec, Fncall_Res_39);

         if Fncall_Res_39 /= null then
            Fncall_Res_39.Parent :=
              GPR_Node (Lst_Res_3);
         end if;

      
--  Start tok_code

Tk_Res_31 := Lst_Cpos_5;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_31));
begin
   if T.Kind /= GPR_Pipe then
       Tk_Pos_31 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_5 then
           Parser.Last_Fail.Pos := Lst_Cpos_5;
           Parser.Last_Fail.Expected_Token_Id := GPR_Pipe;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_31 := Lst_Cpos_5 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_31 /= No_Token_Index then
          Lst_Cpos_5 := Tk_Pos_31;
      else
         exit;
      end if;

end loop;

if Lst_Res_3 /= null then
   Lst_Res_3.Unit := Parser.Unit;
   Lst_Res_3.Token_Start := pos;
   Lst_Res_3.Token_End := (if Lst_Cpos_5 = pos
                        then pos
                        else Lst_Cpos_5 - 1);
end if;


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Discrete_Choice_List_List_Parse_0_Memo,
        Lst_Pos_3 /= No_Token_Index,
        Lst_Res_3,
        Pos,
        Lst_Pos_3);


   Parser.Current_Pos := Lst_Pos_3;

   return Lst_Res_3;
end Discrete_Choice_List_List_Parse_0;

   


Case_Item_Transform_Parse_0_Memo : Case_Item_Memos.Memo_Type;

function Case_Item_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Case_Item
is
      Row_Pos_20 : Token_Index
         := No_Token_Index;
      Tk_Pos_30 : Token_Index
         := No_Token_Index;
      Tk_Res_30 : Token_Index
         := No_Token_Index;
      Fncall_Pos_40 : Token_Index
         := No_Token_Index;
      Fncall_Res_40 : List_GPR_Node
         := null;
      Row_Subres_1_20 : List_GPR_Node
         := null;
      Tk_Pos_32 : Token_Index
         := No_Token_Index;
      Tk_Res_32 : Token_Index
         := No_Token_Index;
      Fncall_Pos_41 : Token_Index
         := No_Token_Index;
      Fncall_Res_41 : List_GPR_Node
         := null;
      Row_Subres_3_6 : List_GPR_Node
         := null;
      Transform_Res_15 : Case_Item
         := null;


   M : Case_Item_Memos.Memo_Entry := Get (Case_Item_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_15 := M.Instance;
      return Transform_Res_15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_15;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_20 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_30 := Row_Pos_20;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_30));
begin
   if T.Kind /= GPR_When then
       Tk_Pos_30 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
           Parser.Last_Fail.Pos := Row_Pos_20;
           Parser.Last_Fail.Expected_Token_Id := GPR_When;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_30 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_30 /= No_Token_Index then

   Row_Pos_20 := Tk_Pos_30;


else
   Row_Pos_20 := No_Token_Index;
   goto Row_Exit_Label_20_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_40 := Discrete_Choice_List_List_Parse_0(Parser, Row_Pos_20);
Fncall_Pos_40 := Parser.Current_Pos;


if Fncall_Pos_40 /= No_Token_Index then

   Row_Pos_20 := Fncall_Pos_40;

      Row_Subres_1_20 := Fncall_Res_40;

else
   Row_Pos_20 := No_Token_Index;
   goto Row_Exit_Label_20_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_32 := Row_Pos_20;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_32));
begin
   if T.Kind /= GPR_Arrow then
       Tk_Pos_32 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
           Parser.Last_Fail.Pos := Row_Pos_20;
           Parser.Last_Fail.Expected_Token_Id := GPR_Arrow;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_32 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_32 /= No_Token_Index then

   Row_Pos_20 := Tk_Pos_32;


else
   Row_Pos_20 := No_Token_Index;
   goto Row_Exit_Label_20_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_41 := Simple_Declarative_Items_List_Parse_0(Parser, Row_Pos_20);
Fncall_Pos_41 := Parser.Current_Pos;


if Fncall_Pos_41 /= No_Token_Index then

   Row_Pos_20 := Fncall_Pos_41;

      Row_Subres_3_6 := Fncall_Res_41;

else
   Row_Pos_20 := No_Token_Index;
   goto Row_Exit_Label_20_0;

end if;

--  End row_submatch


<<Row_Exit_Label_20_0>>

--  End row_code


if Row_Pos_20 /= No_Token_Index then

   Transform_Res_15 := Case_Item
     (Case_Item_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_15.Unit := Parser.Unit;
   Transform_Res_15.Token_Start := pos;
   Transform_Res_15.Token_End := (if Row_Pos_20 = pos
                        then pos
                        else Row_Pos_20 - 1);

      Transform_Res_15.F_Choice :=
            List_GPR_Node (Row_Subres_1_20);

         if Row_Subres_1_20 /= null then
            Row_Subres_1_20.Parent := GPR_Node (Transform_Res_15);
         end if;
      Transform_Res_15.F_Decls :=
            List_GPR_Node (Row_Subres_3_6);

         if Row_Subres_3_6 /= null then
            Row_Subres_3_6.Parent := GPR_Node (Transform_Res_15);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Case_Item_Transform_Parse_0_Memo,
        Row_Pos_20 /= No_Token_Index,
        Transform_Res_15,
        Pos,
        Row_Pos_20);


   Parser.Current_Pos := Row_Pos_20;

   return Transform_Res_15;
end Case_Item_Transform_Parse_0;

   


Case_Construction_Transform_Parse_0_Memo : Case_Construction_Memos.Memo_Type;

function Case_Construction_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Case_Construction
is
      Row_Pos_19 : Token_Index
         := No_Token_Index;
      Tk_Pos_28 : Token_Index
         := No_Token_Index;
      Tk_Res_28 : Token_Index
         := No_Token_Index;
      Fncall_Pos_36 : Token_Index
         := No_Token_Index;
      Fncall_Res_36 : Variable_Reference
         := null;
      Row_Subres_1_19 : Variable_Reference
         := null;
      Tk_Pos_29 : Token_Index
         := No_Token_Index;
      Tk_Res_29 : Token_Index
         := No_Token_Index;
      Lst_Pos_4 : Token_Index
         := No_Token_Index;
      Lst_Res_4 : List_Case_Item
         := null;
      Lst_Cpos_4 : Token_Index
         := No_Token_Index;
      Fncall_Pos_42 : Token_Index
         := No_Token_Index;
      Fncall_Res_42 : Case_Item
         := null;
      Row_Subres_3_5 : List_Case_Item
         := null;
      Tk_Pos_33 : Token_Index
         := No_Token_Index;
      Tk_Res_33 : Token_Index
         := No_Token_Index;
      Tk_Pos_34 : Token_Index
         := No_Token_Index;
      Tk_Res_34 : Token_Index
         := No_Token_Index;
      Transform_Res_16 : Case_Construction
         := null;


   M : Case_Construction_Memos.Memo_Entry := Get (Case_Construction_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_16 := M.Instance;
      return Transform_Res_16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_16;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_19 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_28 := Row_Pos_19;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_28));
begin
   if T.Kind /= GPR_Case then
       Tk_Pos_28 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
           Parser.Last_Fail.Pos := Row_Pos_19;
           Parser.Last_Fail.Expected_Token_Id := GPR_Case;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_28 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_28 /= No_Token_Index then

   Row_Pos_19 := Tk_Pos_28;


else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_36 := Variable_Reference_Transform_Parse_0(Parser, Row_Pos_19);
Fncall_Pos_36 := Parser.Current_Pos;


if Fncall_Pos_36 /= No_Token_Index then

   Row_Pos_19 := Fncall_Pos_36;

      Row_Subres_1_19 := Fncall_Res_36;

else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_29 := Row_Pos_19;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_29));
begin
   if T.Kind /= GPR_Is then
       Tk_Pos_29 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
           Parser.Last_Fail.Pos := Row_Pos_19;
           Parser.Last_Fail.Expected_Token_Id := GPR_Is;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_29 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_29 /= No_Token_Index then

   Row_Pos_19 := Tk_Pos_29;


else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start list_code

    Lst_Pos_4 := Row_Pos_19;

Lst_Res_4 := null;
Lst_Cpos_4 := Row_Pos_19;

loop
   
Fncall_Res_42 := Case_Item_Transform_Parse_0(Parser, Lst_Cpos_4);
Fncall_Pos_42 := Parser.Current_Pos;


   exit when Fncall_Pos_42 = No_Token_Index;

   Lst_Pos_4 := Fncall_Pos_42;
   Lst_Cpos_4 := Fncall_Pos_42;



      

      if Lst_Res_4 = null then
         Lst_Res_4 := List_Case_Item
           (List_Case_Item_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_4.Vec :=
           Lists_Case_Item.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_Case_Item.Node_Vectors.Append
        (Lst_Res_4.Vec, Fncall_Res_42);

         if Fncall_Res_42 /= null then
            Fncall_Res_42.Parent :=
              GPR_Node (Lst_Res_4);
         end if;


end loop;

if Lst_Res_4 /= null then
   Lst_Res_4.Unit := Parser.Unit;
   Lst_Res_4.Token_Start := Row_Pos_19;
   Lst_Res_4.Token_End := (if Lst_Cpos_4 = Row_Pos_19
                        then Row_Pos_19
                        else Lst_Cpos_4 - 1);
end if;


--  End list_code


if Lst_Pos_4 /= No_Token_Index then

   Row_Pos_19 := Lst_Pos_4;

      Row_Subres_3_5 := Lst_Res_4;

else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_33 := Row_Pos_19;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_33));
begin
   if T.Kind /= GPR_End then
       Tk_Pos_33 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
           Parser.Last_Fail.Pos := Row_Pos_19;
           Parser.Last_Fail.Expected_Token_Id := GPR_End;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_33 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_33 /= No_Token_Index then

   Row_Pos_19 := Tk_Pos_33;


else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_34 := Row_Pos_19;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_34));
begin
   if T.Kind /= GPR_Case then
       Tk_Pos_34 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
           Parser.Last_Fail.Pos := Row_Pos_19;
           Parser.Last_Fail.Expected_Token_Id := GPR_Case;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_34 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_34 /= No_Token_Index then

   Row_Pos_19 := Tk_Pos_34;


else
   Row_Pos_19 := No_Token_Index;
   goto Row_Exit_Label_19_0;

end if;

--  End row_submatch


<<Row_Exit_Label_19_0>>

--  End row_code


if Row_Pos_19 /= No_Token_Index then

   Transform_Res_16 := Case_Construction
     (Case_Construction_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_16.Unit := Parser.Unit;
   Transform_Res_16.Token_Start := pos;
   Transform_Res_16.Token_End := (if Row_Pos_19 = pos
                        then pos
                        else Row_Pos_19 - 1);

      Transform_Res_16.F_Var_Ref :=
            Variable_Reference (Row_Subres_1_19);

         if Row_Subres_1_19 /= null then
            Row_Subres_1_19.Parent := GPR_Node (Transform_Res_16);
         end if;
      Transform_Res_16.F_Items :=
            List_Case_Item (Row_Subres_3_5);

         if Row_Subres_3_5 /= null then
            Row_Subres_3_5.Parent := GPR_Node (Transform_Res_16);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Case_Construction_Transform_Parse_0_Memo,
        Row_Pos_19 /= No_Token_Index,
        Transform_Res_16,
        Pos,
        Row_Pos_19);


   Parser.Current_Pos := Row_Pos_19;

   return Transform_Res_16;
end Case_Construction_Transform_Parse_0;

   


Empty_Declaration_Transform_Parse_0_Memo : Empty_Decl_Memos.Memo_Type;

function Empty_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Empty_Decl
is
      Row_Pos_21 : Token_Index
         := No_Token_Index;
      Tk_Pos_35 : Token_Index
         := No_Token_Index;
      Tk_Res_35 : Token_Index
         := No_Token_Index;
      Transform_Res_17 : Empty_Decl
         := null;


   M : Empty_Decl_Memos.Memo_Entry := Get (Empty_Declaration_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_17 := M.Instance;
      return Transform_Res_17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_17;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_21 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_35 := Row_Pos_21;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_35));
begin
   if T.Kind /= GPR_Null then
       Tk_Pos_35 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_21 then
           Parser.Last_Fail.Pos := Row_Pos_21;
           Parser.Last_Fail.Expected_Token_Id := GPR_Null;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_35 := Row_Pos_21 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_35 /= No_Token_Index then

   Row_Pos_21 := Tk_Pos_35;


else
   Row_Pos_21 := No_Token_Index;
   goto Row_Exit_Label_21_0;

end if;

--  End row_submatch


<<Row_Exit_Label_21_0>>

--  End row_code


if Row_Pos_21 /= No_Token_Index then

   Transform_Res_17 := Empty_Decl
     (Empty_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_17.Unit := Parser.Unit;
   Transform_Res_17.Token_Start := pos;
   Transform_Res_17.Token_End := (if Row_Pos_21 = pos
                        then pos
                        else Row_Pos_21 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Empty_Declaration_Transform_Parse_0_Memo,
        Row_Pos_21 /= No_Token_Index,
        Transform_Res_17,
        Pos,
        Row_Pos_21);


   Parser.Current_Pos := Row_Pos_21;

   return Transform_Res_17;
end Empty_Declaration_Transform_Parse_0;

   


Simple_Declarative_Item_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;

function Simple_Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node
is
      Or_Pos_3 : Token_Index
         := No_Token_Index;
      Or_Res_3 : GPR_Node
         := null;
      Fncall_Pos_29 : Token_Index
         := No_Token_Index;
      Fncall_Res_29 : Variable_Decl
         := null;
      Fncall_Pos_35 : Token_Index
         := No_Token_Index;
      Fncall_Res_35 : Attribute_Decl
         := null;
      Fncall_Pos_43 : Token_Index
         := No_Token_Index;
      Fncall_Res_43 : Case_Construction
         := null;
      Fncall_Pos_44 : Token_Index
         := No_Token_Index;
      Fncall_Res_44 : Empty_Decl
         := null;


   M : GPR_Node_Memos.Memo_Entry := Get (Simple_Declarative_Item_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_3 := M.Instance;
      return Or_Res_3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_3 := No_Token_Index;
Or_Res_3 := null;
    
Fncall_Res_29 := Variable_Decl_Transform_Parse_0(Parser, pos);
Fncall_Pos_29 := Parser.Current_Pos;

    if Fncall_Pos_29 /= No_Token_Index then
        Or_Pos_3 := Fncall_Pos_29;
        Or_Res_3 := GPR_Node
          (Fncall_Res_29);
        goto Exit_Or_4;
    end if;
    
Fncall_Res_35 := Attribute_Decl_Transform_Parse_0(Parser, pos);
Fncall_Pos_35 := Parser.Current_Pos;

    if Fncall_Pos_35 /= No_Token_Index then
        Or_Pos_3 := Fncall_Pos_35;
        Or_Res_3 := GPR_Node
          (Fncall_Res_35);
        goto Exit_Or_4;
    end if;
    
Fncall_Res_43 := Case_Construction_Transform_Parse_0(Parser, pos);
Fncall_Pos_43 := Parser.Current_Pos;

    if Fncall_Pos_43 /= No_Token_Index then
        Or_Pos_3 := Fncall_Pos_43;
        Or_Res_3 := GPR_Node
          (Fncall_Res_43);
        goto Exit_Or_4;
    end if;
    
Fncall_Res_44 := Empty_Declaration_Transform_Parse_0(Parser, pos);
Fncall_Pos_44 := Parser.Current_Pos;

    if Fncall_Pos_44 /= No_Token_Index then
        Or_Pos_3 := Fncall_Pos_44;
        Or_Res_3 := GPR_Node
          (Fncall_Res_44);
        goto Exit_Or_4;
    end if;
<<Exit_Or_4>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Simple_Declarative_Item_Or_Parse_0_Memo,
        Or_Pos_3 /= No_Token_Index,
        Or_Res_3,
        Pos,
        Or_Pos_3);


   Parser.Current_Pos := Or_Pos_3;

   return Or_Res_3;
end Simple_Declarative_Item_Or_Parse_0;

   


Simple_Declarative_Items_List_Parse_0_Memo : List_GPR_Node_Memos.Memo_Type;

function Simple_Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node
is
      Lst_Pos_5 : Token_Index
         := No_Token_Index;
      Lst_Res_5 : List_GPR_Node
         := null;
      Lst_Cpos_3 : Token_Index
         := No_Token_Index;
      Row_Pos_14 : Token_Index
         := No_Token_Index;
      Fncall_Pos_45 : Token_Index
         := No_Token_Index;
      Fncall_Res_45 : GPR_Node
         := null;
      Row_Subres_0_14 : GPR_Node
         := null;
      Tk_Pos_36 : Token_Index
         := No_Token_Index;
      Tk_Res_36 : Token_Index
         := No_Token_Index;


   M : List_GPR_Node_Memos.Memo_Entry := Get (Simple_Declarative_Items_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Lst_Res_5 := M.Instance;
      return Lst_Res_5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Lst_Res_5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    Lst_Pos_5 := pos;

Lst_Res_5 := null;
Lst_Cpos_3 := pos;

loop
   
--  Start row_code

Row_Pos_14 := Lst_Cpos_3;


--  Start row_submatch


Fncall_Res_45 := Simple_Declarative_Item_Or_Parse_0(Parser, Row_Pos_14);
Fncall_Pos_45 := Parser.Current_Pos;


if Fncall_Pos_45 /= No_Token_Index then

   Row_Pos_14 := Fncall_Pos_45;

      Row_Subres_0_14 := Fncall_Res_45;

else
   Row_Pos_14 := No_Token_Index;
   goto Row_Exit_Label_14_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_36 := Row_Pos_14;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_36));
begin
   if T.Kind /= GPR_Semicolon then
       Tk_Pos_36 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_14 then
           Parser.Last_Fail.Pos := Row_Pos_14;
           Parser.Last_Fail.Expected_Token_Id := GPR_Semicolon;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_36 := Row_Pos_14 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_36 /= No_Token_Index then

   Row_Pos_14 := Tk_Pos_36;


else
   Row_Pos_14 := No_Token_Index;
   goto Row_Exit_Label_14_0;

end if;

--  End row_submatch


<<Row_Exit_Label_14_0>>

--  End row_code


   exit when Row_Pos_14 = No_Token_Index;

   Lst_Pos_5 := Row_Pos_14;
   Lst_Cpos_3 := Row_Pos_14;



      

      if Lst_Res_5 = null then
         Lst_Res_5 := List_GPR_Node
           (List_GPR_Node_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_5.Vec :=
           Lists_GPR_Node.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_GPR_Node.Node_Vectors.Append
        (Lst_Res_5.Vec, Row_Subres_0_14);

         if Row_Subres_0_14 /= null then
            Row_Subres_0_14.Parent :=
              GPR_Node (Lst_Res_5);
         end if;


end loop;

if Lst_Res_5 /= null then
   Lst_Res_5.Unit := Parser.Unit;
   Lst_Res_5.Token_Start := pos;
   Lst_Res_5.Token_End := (if Lst_Cpos_3 = pos
                        then pos
                        else Lst_Cpos_3 - 1);
end if;


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Simple_Declarative_Items_List_Parse_0_Memo,
        Lst_Pos_5 /= No_Token_Index,
        Lst_Res_5,
        Pos,
        Lst_Pos_5);


   Parser.Current_Pos := Lst_Pos_5;

   return Lst_Res_5;
end Simple_Declarative_Items_List_Parse_0;

   


Package_Spec_Transform_Parse_0_Memo : Package_Spec_Memos.Memo_Type;

function Package_Spec_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Spec
is
      Row_Pos_12 : Token_Index
         := No_Token_Index;
      Fncall_Pos_25 : Token_Index
         := No_Token_Index;
      Fncall_Res_25 : Package_Extension
         := null;
      Row_Subres_0_12 : Package_Extension
         := null;
      Tk_Pos_21 : Token_Index
         := No_Token_Index;
      Tk_Res_21 : Token_Index
         := No_Token_Index;
      Fncall_Pos_46 : Token_Index
         := No_Token_Index;
      Fncall_Res_46 : List_GPR_Node
         := null;
      Row_Subres_2_6 : List_GPR_Node
         := null;
      Tk_Pos_37 : Token_Index
         := No_Token_Index;
      Tk_Res_37 : Token_Index
         := No_Token_Index;
      Fncall_Pos_47 : Token_Index
         := No_Token_Index;
      Fncall_Res_47 : Identifier
         := null;
      Row_Subres_4_0 : Identifier
         := null;
      Transform_Res_18 : Package_Spec
         := null;


   M : Package_Spec_Memos.Memo_Entry := Get (Package_Spec_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_18 := M.Instance;
      return Transform_Res_18;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_18;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_12 := pos;


--  Start row_submatch


--  Start opt_code


Fncall_Res_25 := Package_Extension_Transform_Parse_0(Parser, Row_Pos_12);
Fncall_Pos_25 := Parser.Current_Pos;



if Fncall_Pos_25 = No_Token_Index then
        Fncall_Res_25 :=
           null;


    Fncall_Pos_25 := Row_Pos_12;
end if;

--  End opt_code


if Fncall_Pos_25 /= No_Token_Index then

   Row_Pos_12 := Fncall_Pos_25;

      Row_Subres_0_12 := Fncall_Res_25;

else
   Row_Pos_12 := No_Token_Index;
   goto Row_Exit_Label_12_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_21 := Row_Pos_12;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_21));
begin
   if T.Kind /= GPR_Is then
       Tk_Pos_21 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_12 then
           Parser.Last_Fail.Pos := Row_Pos_12;
           Parser.Last_Fail.Expected_Token_Id := GPR_Is;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_21 := Row_Pos_12 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_21 /= No_Token_Index then

   Row_Pos_12 := Tk_Pos_21;


else
   Row_Pos_12 := No_Token_Index;
   goto Row_Exit_Label_12_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_46 := Simple_Declarative_Items_List_Parse_0(Parser, Row_Pos_12);
Fncall_Pos_46 := Parser.Current_Pos;


if Fncall_Pos_46 /= No_Token_Index then

   Row_Pos_12 := Fncall_Pos_46;

      Row_Subres_2_6 := Fncall_Res_46;

else
   Row_Pos_12 := No_Token_Index;
   goto Row_Exit_Label_12_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_37 := Row_Pos_12;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_37));
begin
   if T.Kind /= GPR_End then
       Tk_Pos_37 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_12 then
           Parser.Last_Fail.Pos := Row_Pos_12;
           Parser.Last_Fail.Expected_Token_Id := GPR_End;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_37 := Row_Pos_12 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_37 /= No_Token_Index then

   Row_Pos_12 := Tk_Pos_37;


else
   Row_Pos_12 := No_Token_Index;
   goto Row_Exit_Label_12_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_47 := Identifier_Transform_Parse_0(Parser, Row_Pos_12);
Fncall_Pos_47 := Parser.Current_Pos;


if Fncall_Pos_47 /= No_Token_Index then

   Row_Pos_12 := Fncall_Pos_47;

      Row_Subres_4_0 := Fncall_Res_47;

else
   Row_Pos_12 := No_Token_Index;
   goto Row_Exit_Label_12_0;

end if;

--  End row_submatch


<<Row_Exit_Label_12_0>>

--  End row_code


if Row_Pos_12 /= No_Token_Index then

   Transform_Res_18 := Package_Spec
     (Package_Spec_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_18.Unit := Parser.Unit;
   Transform_Res_18.Token_Start := pos;
   Transform_Res_18.Token_End := (if Row_Pos_12 = pos
                        then pos
                        else Row_Pos_12 - 1);

      Transform_Res_18.F_Extension :=
            Package_Extension (Row_Subres_0_12);

         if Row_Subres_0_12 /= null then
            Row_Subres_0_12.Parent := GPR_Node (Transform_Res_18);
         end if;
      Transform_Res_18.F_Decls :=
            List_GPR_Node (Row_Subres_2_6);

         if Row_Subres_2_6 /= null then
            Row_Subres_2_6.Parent := GPR_Node (Transform_Res_18);
         end if;
      Transform_Res_18.F_End_Name :=
            Identifier (Row_Subres_4_0);

         if Row_Subres_4_0 /= null then
            Row_Subres_4_0.Parent := GPR_Node (Transform_Res_18);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Package_Spec_Transform_Parse_0_Memo,
        Row_Pos_12 /= No_Token_Index,
        Transform_Res_18,
        Pos,
        Row_Pos_12);


   Parser.Current_Pos := Row_Pos_12;

   return Transform_Res_18;
end Package_Spec_Transform_Parse_0;

   


Package_Decl_Transform_Parse_0_Memo : Package_Decl_Memos.Memo_Type;

function Package_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Package_Decl
is
      Row_Pos_11 : Token_Index
         := No_Token_Index;
      Tk_Pos_18 : Token_Index
         := No_Token_Index;
      Tk_Res_18 : Token_Index
         := No_Token_Index;
      Fncall_Pos_21 : Token_Index
         := No_Token_Index;
      Fncall_Res_21 : Identifier
         := null;
      Row_Subres_1_11 : Identifier
         := null;
      Or_Pos_2 : Token_Index
         := No_Token_Index;
      Or_Res_2 : GPR_Node
         := null;
      Fncall_Pos_22 : Token_Index
         := No_Token_Index;
      Fncall_Res_22 : Package_Renaming
         := null;
      Fncall_Pos_48 : Token_Index
         := No_Token_Index;
      Fncall_Res_48 : Package_Spec
         := null;
      Row_Subres_2_5 : GPR_Node
         := null;
      Transform_Res_19 : Package_Decl
         := null;


   M : Package_Decl_Memos.Memo_Entry := Get (Package_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_19 := M.Instance;
      return Transform_Res_19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_11 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_18 := Row_Pos_11;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_18));
begin
   if T.Kind /= GPR_Package then
       Tk_Pos_18 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_11 then
           Parser.Last_Fail.Pos := Row_Pos_11;
           Parser.Last_Fail.Expected_Token_Id := GPR_Package;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_18 := Row_Pos_11 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_18 /= No_Token_Index then

   Row_Pos_11 := Tk_Pos_18;


else
   Row_Pos_11 := No_Token_Index;
   goto Row_Exit_Label_11_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_21 := Identifier_Transform_Parse_0(Parser, Row_Pos_11);
Fncall_Pos_21 := Parser.Current_Pos;


if Fncall_Pos_21 /= No_Token_Index then

   Row_Pos_11 := Fncall_Pos_21;

      Row_Subres_1_11 := Fncall_Res_21;

else
   Row_Pos_11 := No_Token_Index;
   goto Row_Exit_Label_11_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start or_code

Or_Pos_2 := No_Token_Index;
Or_Res_2 := null;
    
Fncall_Res_22 := Package_Renaming_Transform_Parse_0(Parser, Row_Pos_11);
Fncall_Pos_22 := Parser.Current_Pos;

    if Fncall_Pos_22 /= No_Token_Index then
        Or_Pos_2 := Fncall_Pos_22;
        Or_Res_2 := GPR_Node
          (Fncall_Res_22);
        goto Exit_Or_5;
    end if;
    
Fncall_Res_48 := Package_Spec_Transform_Parse_0(Parser, Row_Pos_11);
Fncall_Pos_48 := Parser.Current_Pos;

    if Fncall_Pos_48 /= No_Token_Index then
        Or_Pos_2 := Fncall_Pos_48;
        Or_Res_2 := GPR_Node
          (Fncall_Res_48);
        goto Exit_Or_5;
    end if;
<<Exit_Or_5>>

--  End or_code


if Or_Pos_2 /= No_Token_Index then

   Row_Pos_11 := Or_Pos_2;

      Row_Subres_2_5 := Or_Res_2;

else
   Row_Pos_11 := No_Token_Index;
   goto Row_Exit_Label_11_0;

end if;

--  End row_submatch


<<Row_Exit_Label_11_0>>

--  End row_code


if Row_Pos_11 /= No_Token_Index then

   Transform_Res_19 := Package_Decl
     (Package_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_19.Unit := Parser.Unit;
   Transform_Res_19.Token_Start := pos;
   Transform_Res_19.Token_End := (if Row_Pos_11 = pos
                        then pos
                        else Row_Pos_11 - 1);

      Transform_Res_19.F_Pkg_Name :=
            Identifier (Row_Subres_1_11);

         if Row_Subres_1_11 /= null then
            Row_Subres_1_11.Parent := GPR_Node (Transform_Res_19);
         end if;
      Transform_Res_19.F_Pkg_Spec :=
            GPR_Node (Row_Subres_2_5);

         if Row_Subres_2_5 /= null then
            Row_Subres_2_5.Parent := GPR_Node (Transform_Res_19);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Package_Decl_Transform_Parse_0_Memo,
        Row_Pos_11 /= No_Token_Index,
        Transform_Res_19,
        Pos,
        Row_Pos_11);


   Parser.Current_Pos := Row_Pos_11;

   return Transform_Res_19;
end Package_Decl_Transform_Parse_0;

   


Typed_String_Decl_Transform_Parse_0_Memo : Typed_String_Decl_Memos.Memo_Type;

function Typed_String_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Typed_String_Decl
is
      Row_Pos_22 : Token_Index
         := No_Token_Index;
      Tk_Pos_38 : Token_Index
         := No_Token_Index;
      Tk_Res_38 : Token_Index
         := No_Token_Index;
      Fncall_Pos_50 : Token_Index
         := No_Token_Index;
      Fncall_Res_50 : Identifier
         := null;
      Row_Subres_1_21 : Identifier
         := null;
      Tk_Pos_39 : Token_Index
         := No_Token_Index;
      Tk_Res_39 : Token_Index
         := No_Token_Index;
      Tk_Pos_40 : Token_Index
         := No_Token_Index;
      Tk_Res_40 : Token_Index
         := No_Token_Index;
      Lst_Pos_6 : Token_Index
         := No_Token_Index;
      Lst_Res_6 : List_String_Literal
         := null;
      Lst_Cpos_6 : Token_Index
         := No_Token_Index;
      Fncall_Pos_51 : Token_Index
         := No_Token_Index;
      Fncall_Res_51 : String_Literal
         := null;
      Tk_Pos_41 : Token_Index
         := No_Token_Index;
      Tk_Res_41 : Token_Index
         := No_Token_Index;
      Row_Subres_4_3 : List_String_Literal
         := null;
      Tk_Pos_42 : Token_Index
         := No_Token_Index;
      Tk_Res_42 : Token_Index
         := No_Token_Index;
      Transform_Res_20 : Typed_String_Decl
         := null;


   M : Typed_String_Decl_Memos.Memo_Entry := Get (Typed_String_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_20 := M.Instance;
      return Transform_Res_20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_20;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_22 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_38 := Row_Pos_22;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_38));
begin
   if T.Kind /= GPR_Type then
       Tk_Pos_38 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_22 then
           Parser.Last_Fail.Pos := Row_Pos_22;
           Parser.Last_Fail.Expected_Token_Id := GPR_Type;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_38 := Row_Pos_22 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_38 /= No_Token_Index then

   Row_Pos_22 := Tk_Pos_38;


else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_50 := Identifier_Transform_Parse_0(Parser, Row_Pos_22);
Fncall_Pos_50 := Parser.Current_Pos;


if Fncall_Pos_50 /= No_Token_Index then

   Row_Pos_22 := Fncall_Pos_50;

      Row_Subres_1_21 := Fncall_Res_50;

else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_39 := Row_Pos_22;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_39));
begin
   if T.Kind /= GPR_Is then
       Tk_Pos_39 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_22 then
           Parser.Last_Fail.Pos := Row_Pos_22;
           Parser.Last_Fail.Expected_Token_Id := GPR_Is;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_39 := Row_Pos_22 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_39 /= No_Token_Index then

   Row_Pos_22 := Tk_Pos_39;


else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_40 := Row_Pos_22;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_40));
begin
   if T.Kind /= GPR_Par_Open then
       Tk_Pos_40 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_22 then
           Parser.Last_Fail.Pos := Row_Pos_22;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Open;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_40 := Row_Pos_22 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_40 /= No_Token_Index then

   Row_Pos_22 := Tk_Pos_40;


else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start list_code

    Lst_Pos_6 := No_Token_Index;

Lst_Res_6 := null;
Lst_Cpos_6 := Row_Pos_22;

loop
   
Fncall_Res_51 := String_Literal_Transform_Parse_0(Parser, Lst_Cpos_6);
Fncall_Pos_51 := Parser.Current_Pos;


   exit when Fncall_Pos_51 = No_Token_Index;

   Lst_Pos_6 := Fncall_Pos_51;
   Lst_Cpos_6 := Fncall_Pos_51;



      

      if Lst_Res_6 = null then
         Lst_Res_6 := List_String_Literal
           (List_String_Literal_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_6.Vec :=
           Lists_String_Literal.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_String_Literal.Node_Vectors.Append
        (Lst_Res_6.Vec, Fncall_Res_51);

         if Fncall_Res_51 /= null then
            Fncall_Res_51.Parent :=
              GPR_Node (Lst_Res_6);
         end if;

      
--  Start tok_code

Tk_Res_41 := Lst_Cpos_6;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_41));
begin
   if T.Kind /= GPR_Comma then
       Tk_Pos_41 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_6 then
           Parser.Last_Fail.Pos := Lst_Cpos_6;
           Parser.Last_Fail.Expected_Token_Id := GPR_Comma;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_41 := Lst_Cpos_6 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_41 /= No_Token_Index then
          Lst_Cpos_6 := Tk_Pos_41;
      else
         exit;
      end if;

end loop;

if Lst_Res_6 /= null then
   Lst_Res_6.Unit := Parser.Unit;
   Lst_Res_6.Token_Start := Row_Pos_22;
   Lst_Res_6.Token_End := (if Lst_Cpos_6 = Row_Pos_22
                        then Row_Pos_22
                        else Lst_Cpos_6 - 1);
end if;


--  End list_code


if Lst_Pos_6 /= No_Token_Index then

   Row_Pos_22 := Lst_Pos_6;

      Row_Subres_4_3 := Lst_Res_6;

else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_42 := Row_Pos_22;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_42));
begin
   if T.Kind /= GPR_Par_Close then
       Tk_Pos_42 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_22 then
           Parser.Last_Fail.Pos := Row_Pos_22;
           Parser.Last_Fail.Expected_Token_Id := GPR_Par_Close;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_42 := Row_Pos_22 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_42 /= No_Token_Index then

   Row_Pos_22 := Tk_Pos_42;


else
   Row_Pos_22 := No_Token_Index;
   goto Row_Exit_Label_22_0;

end if;

--  End row_submatch


<<Row_Exit_Label_22_0>>

--  End row_code


if Row_Pos_22 /= No_Token_Index then

   Transform_Res_20 := Typed_String_Decl
     (Typed_String_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_20.Unit := Parser.Unit;
   Transform_Res_20.Token_Start := pos;
   Transform_Res_20.Token_End := (if Row_Pos_22 = pos
                        then pos
                        else Row_Pos_22 - 1);

      Transform_Res_20.F_Type_Id :=
            Identifier (Row_Subres_1_21);

         if Row_Subres_1_21 /= null then
            Row_Subres_1_21.Parent := GPR_Node (Transform_Res_20);
         end if;
      Transform_Res_20.F_String_Literals :=
            List_String_Literal (Row_Subres_4_3);

         if Row_Subres_4_3 /= null then
            Row_Subres_4_3.Parent := GPR_Node (Transform_Res_20);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Typed_String_Decl_Transform_Parse_0_Memo,
        Row_Pos_22 /= No_Token_Index,
        Transform_Res_20,
        Pos,
        Row_Pos_22);


   Parser.Current_Pos := Row_Pos_22;

   return Transform_Res_20;
end Typed_String_Decl_Transform_Parse_0;

   


Declarative_Item_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;

function Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return GPR_Node
is
      Or_Pos_6 : Token_Index
         := No_Token_Index;
      Or_Res_6 : GPR_Node
         := null;
      Fncall_Pos_49 : Token_Index
         := No_Token_Index;
      Fncall_Res_49 : GPR_Node
         := null;
      Fncall_Pos_52 : Token_Index
         := No_Token_Index;
      Fncall_Res_52 : Typed_String_Decl
         := null;
      Fncall_Pos_53 : Token_Index
         := No_Token_Index;
      Fncall_Res_53 : Package_Decl
         := null;


   M : GPR_Node_Memos.Memo_Entry := Get (Declarative_Item_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_6 := M.Instance;
      return Or_Res_6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_6 := No_Token_Index;
Or_Res_6 := null;
    
Fncall_Res_49 := Simple_Declarative_Item_Or_Parse_0(Parser, pos);
Fncall_Pos_49 := Parser.Current_Pos;

    if Fncall_Pos_49 /= No_Token_Index then
        Or_Pos_6 := Fncall_Pos_49;
        Or_Res_6 := GPR_Node
          (Fncall_Res_49);
        goto Exit_Or_6;
    end if;
    
Fncall_Res_52 := Typed_String_Decl_Transform_Parse_0(Parser, pos);
Fncall_Pos_52 := Parser.Current_Pos;

    if Fncall_Pos_52 /= No_Token_Index then
        Or_Pos_6 := Fncall_Pos_52;
        Or_Res_6 := GPR_Node
          (Fncall_Res_52);
        goto Exit_Or_6;
    end if;
    
Fncall_Res_53 := Package_Decl_Transform_Parse_0(Parser, pos);
Fncall_Pos_53 := Parser.Current_Pos;

    if Fncall_Pos_53 /= No_Token_Index then
        Or_Pos_6 := Fncall_Pos_53;
        Or_Res_6 := GPR_Node
          (Fncall_Res_53);
        goto Exit_Or_6;
    end if;
<<Exit_Or_6>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Declarative_Item_Or_Parse_0_Memo,
        Or_Pos_6 /= No_Token_Index,
        Or_Res_6,
        Pos,
        Or_Pos_6);


   Parser.Current_Pos := Or_Pos_6;

   return Or_Res_6;
end Declarative_Item_Or_Parse_0;

   


With_Decl_Transform_Parse_0_Memo : With_Decl_Memos.Memo_Type;

function With_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return With_Decl
is
      Row_Pos_24 : Token_Index
         := No_Token_Index;
      Tk_Pos_43 : Token_Index
         := No_Token_Index;
      Tk_Res_43 : Token_Index
         := No_Token_Index;
      Opt_Bool_Res_7 : Boolean
         := false;
      Row_Subres_0_24 : Boolean
         := false;
      Tk_Pos_44 : Token_Index
         := No_Token_Index;
      Tk_Res_44 : Token_Index
         := No_Token_Index;
      Lst_Pos_7 : Token_Index
         := No_Token_Index;
      Lst_Res_7 : List_String_Literal
         := null;
      Lst_Cpos_8 : Token_Index
         := No_Token_Index;
      Fncall_Pos_54 : Token_Index
         := No_Token_Index;
      Fncall_Res_54 : String_Literal
         := null;
      Tk_Pos_45 : Token_Index
         := No_Token_Index;
      Tk_Res_45 : Token_Index
         := No_Token_Index;
      Row_Subres_2_14 : List_String_Literal
         := null;
      Transform_Res_21 : With_Decl
         := null;


   M : With_Decl_Memos.Memo_Entry := Get (With_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_21 := M.Instance;
      return Transform_Res_21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_21;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_24 := pos;


--  Start row_submatch


--  Start opt_code


--  Start tok_code

Tk_Res_43 := Row_Pos_24;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_43));
begin
   if T.Kind /= GPR_Limited then
       Tk_Pos_43 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_24 then
           Parser.Last_Fail.Pos := Row_Pos_24;
           Parser.Last_Fail.Expected_Token_Id := GPR_Limited;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_43 := Row_Pos_24 + 1;
   end if;
end;

--  End tok_code


    Opt_Bool_Res_7 := True;

if Tk_Pos_43 = No_Token_Index then
        Opt_Bool_Res_7 := False;


    Tk_Pos_43 := Row_Pos_24;
end if;

--  End opt_code


if Tk_Pos_43 /= No_Token_Index then

   Row_Pos_24 := Tk_Pos_43;

      Row_Subres_0_24 := Opt_Bool_Res_7;

else
   Row_Pos_24 := No_Token_Index;
   goto Row_Exit_Label_24_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_44 := Row_Pos_24;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_44));
begin
   if T.Kind /= GPR_With then
       Tk_Pos_44 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_24 then
           Parser.Last_Fail.Pos := Row_Pos_24;
           Parser.Last_Fail.Expected_Token_Id := GPR_With;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_44 := Row_Pos_24 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_44 /= No_Token_Index then

   Row_Pos_24 := Tk_Pos_44;


else
   Row_Pos_24 := No_Token_Index;
   goto Row_Exit_Label_24_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start list_code

    Lst_Pos_7 := No_Token_Index;

Lst_Res_7 := null;
Lst_Cpos_8 := Row_Pos_24;

loop
   
Fncall_Res_54 := String_Literal_Transform_Parse_0(Parser, Lst_Cpos_8);
Fncall_Pos_54 := Parser.Current_Pos;


   exit when Fncall_Pos_54 = No_Token_Index;

   Lst_Pos_7 := Fncall_Pos_54;
   Lst_Cpos_8 := Fncall_Pos_54;



      

      if Lst_Res_7 = null then
         Lst_Res_7 := List_String_Literal
           (List_String_Literal_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_7.Vec :=
           Lists_String_Literal.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_String_Literal.Node_Vectors.Append
        (Lst_Res_7.Vec, Fncall_Res_54);

         if Fncall_Res_54 /= null then
            Fncall_Res_54.Parent :=
              GPR_Node (Lst_Res_7);
         end if;

      
--  Start tok_code

Tk_Res_45 := Lst_Cpos_8;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_45));
begin
   if T.Kind /= GPR_Comma then
       Tk_Pos_45 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_8 then
           Parser.Last_Fail.Pos := Lst_Cpos_8;
           Parser.Last_Fail.Expected_Token_Id := GPR_Comma;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_45 := Lst_Cpos_8 + 1;
   end if;
end;

--  End tok_code

      if Tk_Pos_45 /= No_Token_Index then
          Lst_Cpos_8 := Tk_Pos_45;
      else
         exit;
      end if;

end loop;

if Lst_Res_7 /= null then
   Lst_Res_7.Unit := Parser.Unit;
   Lst_Res_7.Token_Start := Row_Pos_24;
   Lst_Res_7.Token_End := (if Lst_Cpos_8 = Row_Pos_24
                        then Row_Pos_24
                        else Lst_Cpos_8 - 1);
end if;


--  End list_code


if Lst_Pos_7 /= No_Token_Index then

   Row_Pos_24 := Lst_Pos_7;

      Row_Subres_2_14 := Lst_Res_7;

else
   Row_Pos_24 := No_Token_Index;
   goto Row_Exit_Label_24_0;

end if;

--  End row_submatch


<<Row_Exit_Label_24_0>>

--  End row_code


if Row_Pos_24 /= No_Token_Index then

   Transform_Res_21 := With_Decl
     (With_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_21.Unit := Parser.Unit;
   Transform_Res_21.Token_Start := pos;
   Transform_Res_21.Token_End := (if Row_Pos_24 = pos
                        then pos
                        else Row_Pos_24 - 1);

      Transform_Res_21.F_Is_Limited :=
            Row_Subres_0_24;

      Transform_Res_21.F_Path_Names :=
            List_String_Literal (Row_Subres_2_14);

         if Row_Subres_2_14 /= null then
            Row_Subres_2_14.Parent := GPR_Node (Transform_Res_21);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (With_Decl_Transform_Parse_0_Memo,
        Row_Pos_24 /= No_Token_Index,
        Transform_Res_21,
        Pos,
        Row_Pos_24);


   Parser.Current_Pos := Row_Pos_24;

   return Transform_Res_21;
end With_Decl_Transform_Parse_0;

   


Context_Clauses_List_Parse_0_Memo : List_With_Decl_Memos.Memo_Type;

function Context_Clauses_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_With_Decl
is
      Lst_Pos_8 : Token_Index
         := No_Token_Index;
      Lst_Res_8 : List_With_Decl
         := null;
      Lst_Cpos_7 : Token_Index
         := No_Token_Index;
      Row_Pos_23 : Token_Index
         := No_Token_Index;
      Fncall_Pos_55 : Token_Index
         := No_Token_Index;
      Fncall_Res_55 : With_Decl
         := null;
      Row_Subres_0_23 : With_Decl
         := null;
      Tk_Pos_46 : Token_Index
         := No_Token_Index;
      Tk_Res_46 : Token_Index
         := No_Token_Index;


   M : List_With_Decl_Memos.Memo_Entry := Get (Context_Clauses_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Lst_Res_8 := M.Instance;
      return Lst_Res_8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Lst_Res_8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    Lst_Pos_8 := pos;

Lst_Res_8 := null;
Lst_Cpos_7 := pos;

loop
   
--  Start row_code

Row_Pos_23 := Lst_Cpos_7;


--  Start row_submatch


Fncall_Res_55 := With_Decl_Transform_Parse_0(Parser, Row_Pos_23);
Fncall_Pos_55 := Parser.Current_Pos;


if Fncall_Pos_55 /= No_Token_Index then

   Row_Pos_23 := Fncall_Pos_55;

      Row_Subres_0_23 := Fncall_Res_55;

else
   Row_Pos_23 := No_Token_Index;
   goto Row_Exit_Label_23_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_46 := Row_Pos_23;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_46));
begin
   if T.Kind /= GPR_Semicolon then
       Tk_Pos_46 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_23 then
           Parser.Last_Fail.Pos := Row_Pos_23;
           Parser.Last_Fail.Expected_Token_Id := GPR_Semicolon;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_46 := Row_Pos_23 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_46 /= No_Token_Index then

   Row_Pos_23 := Tk_Pos_46;


else
   Row_Pos_23 := No_Token_Index;
   goto Row_Exit_Label_23_0;

end if;

--  End row_submatch


<<Row_Exit_Label_23_0>>

--  End row_code


   exit when Row_Pos_23 = No_Token_Index;

   Lst_Pos_8 := Row_Pos_23;
   Lst_Cpos_7 := Row_Pos_23;



      

      if Lst_Res_8 = null then
         Lst_Res_8 := List_With_Decl
           (List_With_Decl_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_8.Vec :=
           Lists_With_Decl.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_With_Decl.Node_Vectors.Append
        (Lst_Res_8.Vec, Row_Subres_0_23);

         if Row_Subres_0_23 /= null then
            Row_Subres_0_23.Parent :=
              GPR_Node (Lst_Res_8);
         end if;


end loop;

if Lst_Res_8 /= null then
   Lst_Res_8.Unit := Parser.Unit;
   Lst_Res_8.Token_Start := pos;
   Lst_Res_8.Token_End := (if Lst_Cpos_7 = pos
                        then pos
                        else Lst_Cpos_7 - 1);
end if;


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Context_Clauses_List_Parse_0_Memo,
        Lst_Pos_8 /= No_Token_Index,
        Lst_Res_8,
        Pos,
        Lst_Pos_8);


   Parser.Current_Pos := Lst_Pos_8;

   return Lst_Res_8;
end Context_Clauses_List_Parse_0;

   


Abstract_Present_Transform_Parse_0_Memo : Abstract_Present_Memos.Memo_Type;

function Abstract_Present_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Abstract_Present
is
      Row_Pos_25 : Token_Index
         := No_Token_Index;
      Tk_Pos_47 : Token_Index
         := No_Token_Index;
      Tk_Res_47 : Token_Index
         := No_Token_Index;
      Transform_Res_22 : Abstract_Present
         := null;


   M : Abstract_Present_Memos.Memo_Entry := Get (Abstract_Present_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_22 := M.Instance;
      return Transform_Res_22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_22;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_25 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_47 := Row_Pos_25;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_47));
begin
   if T.Kind /= GPR_Abstract then
       Tk_Pos_47 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_25 then
           Parser.Last_Fail.Pos := Row_Pos_25;
           Parser.Last_Fail.Expected_Token_Id := GPR_Abstract;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_47 := Row_Pos_25 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_47 /= No_Token_Index then

   Row_Pos_25 := Tk_Pos_47;


else
   Row_Pos_25 := No_Token_Index;
   goto Row_Exit_Label_25_0;

end if;

--  End row_submatch


<<Row_Exit_Label_25_0>>

--  End row_code


if Row_Pos_25 /= No_Token_Index then

   Transform_Res_22 := Abstract_Present
     (Abstract_Present_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_22.Unit := Parser.Unit;
   Transform_Res_22.Token_Start := pos;
   Transform_Res_22.Token_End := (if Row_Pos_25 = pos
                        then pos
                        else Row_Pos_25 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Abstract_Present_Transform_Parse_0_Memo,
        Row_Pos_25 /= No_Token_Index,
        Transform_Res_22,
        Pos,
        Row_Pos_25);


   Parser.Current_Pos := Row_Pos_25;

   return Transform_Res_22;
end Abstract_Present_Transform_Parse_0;

   


Qualifier_Names_Transform_Parse_0_Memo : Qualifier_Names_Memos.Memo_Type;

function Qualifier_Names_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Qualifier_Names
is
      Row_Pos_26 : Token_Index
         := No_Token_Index;
      Fncall_Pos_57 : Token_Index
         := No_Token_Index;
      Fncall_Res_57 : Identifier
         := null;
      Row_Subres_0_26 : Identifier
         := null;
      Fncall_Pos_58 : Token_Index
         := No_Token_Index;
      Fncall_Res_58 : Identifier
         := null;
      Row_Subres_1_24 : Identifier
         := null;
      Transform_Res_23 : Qualifier_Names
         := null;


   M : Qualifier_Names_Memos.Memo_Entry := Get (Qualifier_Names_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_23 := M.Instance;
      return Transform_Res_23;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_23;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_26 := pos;


--  Start row_submatch


Fncall_Res_57 := Identifier_Transform_Parse_0(Parser, Row_Pos_26);
Fncall_Pos_57 := Parser.Current_Pos;


if Fncall_Pos_57 /= No_Token_Index then

   Row_Pos_26 := Fncall_Pos_57;

      Row_Subres_0_26 := Fncall_Res_57;

else
   Row_Pos_26 := No_Token_Index;
   goto Row_Exit_Label_26_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


Fncall_Res_58 := Identifier_Transform_Parse_0(Parser, Row_Pos_26);
Fncall_Pos_58 := Parser.Current_Pos;



if Fncall_Pos_58 = No_Token_Index then
        Fncall_Res_58 :=
           null;


    Fncall_Pos_58 := Row_Pos_26;
end if;

--  End opt_code


if Fncall_Pos_58 /= No_Token_Index then

   Row_Pos_26 := Fncall_Pos_58;

      Row_Subres_1_24 := Fncall_Res_58;

else
   Row_Pos_26 := No_Token_Index;
   goto Row_Exit_Label_26_0;

end if;

--  End row_submatch


<<Row_Exit_Label_26_0>>

--  End row_code


if Row_Pos_26 /= No_Token_Index then

   Transform_Res_23 := Qualifier_Names
     (Qualifier_Names_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_23.Unit := Parser.Unit;
   Transform_Res_23.Token_Start := pos;
   Transform_Res_23.Token_End := (if Row_Pos_26 = pos
                        then pos
                        else Row_Pos_26 - 1);

      Transform_Res_23.F_Qualifier_Id1 :=
            Identifier (Row_Subres_0_26);

         if Row_Subres_0_26 /= null then
            Row_Subres_0_26.Parent := GPR_Node (Transform_Res_23);
         end if;
      Transform_Res_23.F_Qualifier_Id2 :=
            Identifier (Row_Subres_1_24);

         if Row_Subres_1_24 /= null then
            Row_Subres_1_24.Parent := GPR_Node (Transform_Res_23);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Qualifier_Names_Transform_Parse_0_Memo,
        Row_Pos_26 /= No_Token_Index,
        Transform_Res_23,
        Pos,
        Row_Pos_26);


   Parser.Current_Pos := Row_Pos_26;

   return Transform_Res_23;
end Qualifier_Names_Transform_Parse_0;

   


Project_Qualifier_Transform_Parse_0_Memo : Project_Qualifier_Memos.Memo_Type;

function Project_Qualifier_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Qualifier
is
      Or_Pos_7 : Token_Index
         := No_Token_Index;
      Or_Res_7 : GPR_Node
         := null;
      Fncall_Pos_56 : Token_Index
         := No_Token_Index;
      Fncall_Res_56 : Abstract_Present
         := null;
      Fncall_Pos_59 : Token_Index
         := No_Token_Index;
      Fncall_Res_59 : Qualifier_Names
         := null;
      Transform_Res_24 : Project_Qualifier
         := null;


   M : Project_Qualifier_Memos.Memo_Entry := Get (Project_Qualifier_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_24 := M.Instance;
      return Transform_Res_24;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_24;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start or_code

Or_Pos_7 := No_Token_Index;
Or_Res_7 := null;
    
Fncall_Res_56 := Abstract_Present_Transform_Parse_0(Parser, pos);
Fncall_Pos_56 := Parser.Current_Pos;

    if Fncall_Pos_56 /= No_Token_Index then
        Or_Pos_7 := Fncall_Pos_56;
        Or_Res_7 := GPR_Node
          (Fncall_Res_56);
        goto Exit_Or_7;
    end if;
    
Fncall_Res_59 := Qualifier_Names_Transform_Parse_0(Parser, pos);
Fncall_Pos_59 := Parser.Current_Pos;

    if Fncall_Pos_59 /= No_Token_Index then
        Or_Pos_7 := Fncall_Pos_59;
        Or_Res_7 := GPR_Node
          (Fncall_Res_59);
        goto Exit_Or_7;
    end if;
<<Exit_Or_7>>

--  End or_code


if Or_Pos_7 /= No_Token_Index then

   Transform_Res_24 := Project_Qualifier
     (Project_Qualifier_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_24.Unit := Parser.Unit;
   Transform_Res_24.Token_Start := pos;
   Transform_Res_24.Token_End := (if Or_Pos_7 = pos
                        then pos
                        else Or_Pos_7 - 1);

      Transform_Res_24.F_Qualifier :=
            GPR_Node (Or_Res_7);

         if Or_Res_7 /= null then
            Or_Res_7.Parent := GPR_Node (Transform_Res_24);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Project_Qualifier_Transform_Parse_0_Memo,
        Or_Pos_7 /= No_Token_Index,
        Transform_Res_24,
        Pos,
        Or_Pos_7);


   Parser.Current_Pos := Or_Pos_7;

   return Transform_Res_24;
end Project_Qualifier_Transform_Parse_0;

   


Project_Extension_Transform_Parse_0_Memo : Project_Extension_Memos.Memo_Type;

function Project_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Extension
is
      Row_Pos_27 : Token_Index
         := No_Token_Index;
      Tk_Pos_48 : Token_Index
         := No_Token_Index;
      Tk_Res_48 : Token_Index
         := No_Token_Index;
      Tk_Pos_49 : Token_Index
         := No_Token_Index;
      Tk_Res_49 : Token_Index
         := No_Token_Index;
      Opt_Bool_Res_9 : Boolean
         := false;
      Row_Subres_1_25 : Boolean
         := false;
      Fncall_Pos_60 : Token_Index
         := No_Token_Index;
      Fncall_Res_60 : String_Literal
         := null;
      Row_Subres_2_15 : String_Literal
         := null;
      Transform_Res_25 : Project_Extension
         := null;


   M : Project_Extension_Memos.Memo_Entry := Get (Project_Extension_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_25 := M.Instance;
      return Transform_Res_25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_27 := pos;


--  Start row_submatch


--  Start tok_code

Tk_Res_48 := Row_Pos_27;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_48));
begin
   if T.Kind /= GPR_Extends then
       Tk_Pos_48 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_27 then
           Parser.Last_Fail.Pos := Row_Pos_27;
           Parser.Last_Fail.Expected_Token_Id := GPR_Extends;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_48 := Row_Pos_27 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_48 /= No_Token_Index then

   Row_Pos_27 := Tk_Pos_48;


else
   Row_Pos_27 := No_Token_Index;
   goto Row_Exit_Label_27_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


--  Start tok_code

Tk_Res_49 := Row_Pos_27;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_49));
begin
   if T.Kind /= GPR_All then
       Tk_Pos_49 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_27 then
           Parser.Last_Fail.Pos := Row_Pos_27;
           Parser.Last_Fail.Expected_Token_Id := GPR_All;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_49 := Row_Pos_27 + 1;
   end if;
end;

--  End tok_code


    Opt_Bool_Res_9 := True;

if Tk_Pos_49 = No_Token_Index then
        Opt_Bool_Res_9 := False;


    Tk_Pos_49 := Row_Pos_27;
end if;

--  End opt_code


if Tk_Pos_49 /= No_Token_Index then

   Row_Pos_27 := Tk_Pos_49;

      Row_Subres_1_25 := Opt_Bool_Res_9;

else
   Row_Pos_27 := No_Token_Index;
   goto Row_Exit_Label_27_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_60 := String_Literal_Transform_Parse_0(Parser, Row_Pos_27);
Fncall_Pos_60 := Parser.Current_Pos;


if Fncall_Pos_60 /= No_Token_Index then

   Row_Pos_27 := Fncall_Pos_60;

      Row_Subres_2_15 := Fncall_Res_60;

else
   Row_Pos_27 := No_Token_Index;
   goto Row_Exit_Label_27_0;

end if;

--  End row_submatch


<<Row_Exit_Label_27_0>>

--  End row_code


if Row_Pos_27 /= No_Token_Index then

   Transform_Res_25 := Project_Extension
     (Project_Extension_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_25.Unit := Parser.Unit;
   Transform_Res_25.Token_Start := pos;
   Transform_Res_25.Token_End := (if Row_Pos_27 = pos
                        then pos
                        else Row_Pos_27 - 1);

      Transform_Res_25.F_Is_All :=
            Row_Subres_1_25;

      Transform_Res_25.F_Path_Name :=
            String_Literal (Row_Subres_2_15);

         if Row_Subres_2_15 /= null then
            Row_Subres_2_15.Parent := GPR_Node (Transform_Res_25);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Project_Extension_Transform_Parse_0_Memo,
        Row_Pos_27 /= No_Token_Index,
        Transform_Res_25,
        Pos,
        Row_Pos_27);


   Parser.Current_Pos := Row_Pos_27;

   return Transform_Res_25;
end Project_Extension_Transform_Parse_0;

   


Declarative_Items_List_Parse_0_Memo : List_GPR_Node_Memos.Memo_Type;

function Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return List_GPR_Node
is
      Lst_Pos_9 : Token_Index
         := No_Token_Index;
      Lst_Res_9 : List_GPR_Node
         := null;
      Lst_Cpos_9 : Token_Index
         := No_Token_Index;
      Row_Pos_31 : Token_Index
         := No_Token_Index;
      Fncall_Pos_65 : Token_Index
         := No_Token_Index;
      Fncall_Res_65 : GPR_Node
         := null;
      Row_Subres_0_31 : GPR_Node
         := null;
      Tk_Pos_52 : Token_Index
         := No_Token_Index;
      Tk_Res_52 : Token_Index
         := No_Token_Index;


   M : List_GPR_Node_Memos.Memo_Entry := Get (Declarative_Items_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Lst_Res_9 := M.Instance;
      return Lst_Res_9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Lst_Res_9;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    Lst_Pos_9 := pos;

Lst_Res_9 := null;
Lst_Cpos_9 := pos;

loop
   
--  Start row_code

Row_Pos_31 := Lst_Cpos_9;


--  Start row_submatch


Fncall_Res_65 := Declarative_Item_Or_Parse_0(Parser, Row_Pos_31);
Fncall_Pos_65 := Parser.Current_Pos;


if Fncall_Pos_65 /= No_Token_Index then

   Row_Pos_31 := Fncall_Pos_65;

      Row_Subres_0_31 := Fncall_Res_65;

else
   Row_Pos_31 := No_Token_Index;
   goto Row_Exit_Label_31_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_52 := Row_Pos_31;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_52));
begin
   if T.Kind /= GPR_Semicolon then
       Tk_Pos_52 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_31 then
           Parser.Last_Fail.Pos := Row_Pos_31;
           Parser.Last_Fail.Expected_Token_Id := GPR_Semicolon;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_52 := Row_Pos_31 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_52 /= No_Token_Index then

   Row_Pos_31 := Tk_Pos_52;


else
   Row_Pos_31 := No_Token_Index;
   goto Row_Exit_Label_31_0;

end if;

--  End row_submatch


<<Row_Exit_Label_31_0>>

--  End row_code


   exit when Row_Pos_31 = No_Token_Index;

   Lst_Pos_9 := Row_Pos_31;
   Lst_Cpos_9 := Row_Pos_31;



      

      if Lst_Res_9 = null then
         Lst_Res_9 := List_GPR_Node
           (List_GPR_Node_Alloc.Alloc (Parser.Mem_Pool));

         Lst_Res_9.Vec :=
           Lists_GPR_Node.Node_Vectors.Create (Parser.Mem_Pool);
      end if;

      Lists_GPR_Node.Node_Vectors.Append
        (Lst_Res_9.Vec, Row_Subres_0_31);

         if Row_Subres_0_31 /= null then
            Row_Subres_0_31.Parent :=
              GPR_Node (Lst_Res_9);
         end if;


end loop;

if Lst_Res_9 /= null then
   Lst_Res_9.Unit := Parser.Unit;
   Lst_Res_9.Token_Start := pos;
   Lst_Res_9.Token_End := (if Lst_Cpos_9 = pos
                        then pos
                        else Lst_Cpos_9 - 1);
end if;


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Declarative_Items_List_Parse_0_Memo,
        Lst_Pos_9 /= No_Token_Index,
        Lst_Res_9,
        Pos,
        Lst_Pos_9);


   Parser.Current_Pos := Lst_Pos_9;

   return Lst_Res_9;
end Declarative_Items_List_Parse_0;

   


Project_Declaration_Transform_Parse_0_Memo : Project_Declaration_Memos.Memo_Type;

function Project_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project_Declaration
is
      Row_Pos_30 : Token_Index
         := No_Token_Index;
      Fncall_Pos_62 : Token_Index
         := No_Token_Index;
      Fncall_Res_62 : Project_Qualifier
         := null;
      Row_Subres_0_30 : Project_Qualifier
         := null;
      Tk_Pos_50 : Token_Index
         := No_Token_Index;
      Tk_Res_50 : Token_Index
         := No_Token_Index;
      Fncall_Pos_63 : Token_Index
         := No_Token_Index;
      Fncall_Res_63 : Expr
         := null;
      Row_Subres_2_16 : Expr
         := null;
      Fncall_Pos_64 : Token_Index
         := No_Token_Index;
      Fncall_Res_64 : Project_Extension
         := null;
      Row_Subres_3_8 : Project_Extension
         := null;
      Tk_Pos_51 : Token_Index
         := No_Token_Index;
      Tk_Res_51 : Token_Index
         := No_Token_Index;
      Fncall_Pos_66 : Token_Index
         := No_Token_Index;
      Fncall_Res_66 : List_GPR_Node
         := null;
      Row_Subres_5_2 : List_GPR_Node
         := null;
      Tk_Pos_53 : Token_Index
         := No_Token_Index;
      Tk_Res_53 : Token_Index
         := No_Token_Index;
      Fncall_Pos_67 : Token_Index
         := No_Token_Index;
      Fncall_Res_67 : Expr
         := null;
      Row_Subres_7_0 : Expr
         := null;
      Tk_Pos_54 : Token_Index
         := No_Token_Index;
      Tk_Res_54 : Token_Index
         := No_Token_Index;
      Transform_Res_26 : Project_Declaration
         := null;


   M : Project_Declaration_Memos.Memo_Entry := Get (Project_Declaration_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_26 := M.Instance;
      return Transform_Res_26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_26;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_30 := pos;


--  Start row_submatch


--  Start opt_code


Fncall_Res_62 := Project_Qualifier_Transform_Parse_0(Parser, Row_Pos_30);
Fncall_Pos_62 := Parser.Current_Pos;



if Fncall_Pos_62 = No_Token_Index then
        Fncall_Res_62 :=
           null;


    Fncall_Pos_62 := Row_Pos_30;
end if;

--  End opt_code


if Fncall_Pos_62 /= No_Token_Index then

   Row_Pos_30 := Fncall_Pos_62;

      Row_Subres_0_30 := Fncall_Res_62;

else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_50 := Row_Pos_30;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_50));
begin
   if T.Kind /= GPR_Project then
       Tk_Pos_50 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_30 then
           Parser.Last_Fail.Pos := Row_Pos_30;
           Parser.Last_Fail.Expected_Token_Id := GPR_Project;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_50 := Row_Pos_30 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_50 /= No_Token_Index then

   Row_Pos_30 := Tk_Pos_50;


else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_63 := Static_Name_List_Parse_0(Parser, Row_Pos_30);
Fncall_Pos_63 := Parser.Current_Pos;


if Fncall_Pos_63 /= No_Token_Index then

   Row_Pos_30 := Fncall_Pos_63;

      Row_Subres_2_16 := Fncall_Res_63;

else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start opt_code


Fncall_Res_64 := Project_Extension_Transform_Parse_0(Parser, Row_Pos_30);
Fncall_Pos_64 := Parser.Current_Pos;



if Fncall_Pos_64 = No_Token_Index then
        Fncall_Res_64 :=
           null;


    Fncall_Pos_64 := Row_Pos_30;
end if;

--  End opt_code


if Fncall_Pos_64 /= No_Token_Index then

   Row_Pos_30 := Fncall_Pos_64;

      Row_Subres_3_8 := Fncall_Res_64;

else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_51 := Row_Pos_30;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_51));
begin
   if T.Kind /= GPR_Is then
       Tk_Pos_51 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_30 then
           Parser.Last_Fail.Pos := Row_Pos_30;
           Parser.Last_Fail.Expected_Token_Id := GPR_Is;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_51 := Row_Pos_30 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_51 /= No_Token_Index then

   Row_Pos_30 := Tk_Pos_51;


else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_66 := Declarative_Items_List_Parse_0(Parser, Row_Pos_30);
Fncall_Pos_66 := Parser.Current_Pos;


if Fncall_Pos_66 /= No_Token_Index then

   Row_Pos_30 := Fncall_Pos_66;

      Row_Subres_5_2 := Fncall_Res_66;

else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_53 := Row_Pos_30;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_53));
begin
   if T.Kind /= GPR_End then
       Tk_Pos_53 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_30 then
           Parser.Last_Fail.Pos := Row_Pos_30;
           Parser.Last_Fail.Expected_Token_Id := GPR_End;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_53 := Row_Pos_30 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_53 /= No_Token_Index then

   Row_Pos_30 := Tk_Pos_53;


else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_67 := Static_Name_List_Parse_0(Parser, Row_Pos_30);
Fncall_Pos_67 := Parser.Current_Pos;


if Fncall_Pos_67 /= No_Token_Index then

   Row_Pos_30 := Fncall_Pos_67;

      Row_Subres_7_0 := Fncall_Res_67;

else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


--  Start row_submatch


--  Start tok_code

Tk_Res_54 := Row_Pos_30;

declare
   T : constant Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tk_Res_54));
begin
   if T.Kind /= GPR_Semicolon then
       Tk_Pos_54 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_30 then
           Parser.Last_Fail.Pos := Row_Pos_30;
           Parser.Last_Fail.Expected_Token_Id := GPR_Semicolon;
           Parser.Last_Fail.Found_Token_Id := T.Kind;
       end if;
   else
          Tk_Pos_54 := Row_Pos_30 + 1;
   end if;
end;

--  End tok_code


if Tk_Pos_54 /= No_Token_Index then

   Row_Pos_30 := Tk_Pos_54;


else
   Row_Pos_30 := No_Token_Index;
   goto Row_Exit_Label_30_0;

end if;

--  End row_submatch


<<Row_Exit_Label_30_0>>

--  End row_code


if Row_Pos_30 /= No_Token_Index then

   Transform_Res_26 := Project_Declaration
     (Project_Declaration_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_26.Unit := Parser.Unit;
   Transform_Res_26.Token_Start := pos;
   Transform_Res_26.Token_End := (if Row_Pos_30 = pos
                        then pos
                        else Row_Pos_30 - 1);

      Transform_Res_26.F_Qualifier :=
            Project_Qualifier (Row_Subres_0_30);

         if Row_Subres_0_30 /= null then
            Row_Subres_0_30.Parent := GPR_Node (Transform_Res_26);
         end if;
      Transform_Res_26.F_Project_Name :=
            Expr (Row_Subres_2_16);

         if Row_Subres_2_16 /= null then
            Row_Subres_2_16.Parent := GPR_Node (Transform_Res_26);
         end if;
      Transform_Res_26.F_Extension :=
            Project_Extension (Row_Subres_3_8);

         if Row_Subres_3_8 /= null then
            Row_Subres_3_8.Parent := GPR_Node (Transform_Res_26);
         end if;
      Transform_Res_26.F_Decls :=
            List_GPR_Node (Row_Subres_5_2);

         if Row_Subres_5_2 /= null then
            Row_Subres_5_2.Parent := GPR_Node (Transform_Res_26);
         end if;
      Transform_Res_26.F_End_Name :=
            Expr (Row_Subres_7_0);

         if Row_Subres_7_0 /= null then
            Row_Subres_7_0.Parent := GPR_Node (Transform_Res_26);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Project_Declaration_Transform_Parse_0_Memo,
        Row_Pos_30 /= No_Token_Index,
        Transform_Res_26,
        Pos,
        Row_Pos_30);


   Parser.Current_Pos := Row_Pos_30;

   return Transform_Res_26;
end Project_Declaration_Transform_Parse_0;

   


Project_Transform_Parse_0_Memo : Project_Memos.Memo_Type;

function Project_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Project
is
      Row_Pos_29 : Token_Index
         := No_Token_Index;
      Fncall_Pos_61 : Token_Index
         := No_Token_Index;
      Fncall_Res_61 : List_With_Decl
         := null;
      Row_Subres_0_29 : List_With_Decl
         := null;
      Fncall_Pos_68 : Token_Index
         := No_Token_Index;
      Fncall_Res_68 : Project_Declaration
         := null;
      Row_Subres_1_26 : Project_Declaration
         := null;
      Transform_Res_27 : Project
         := null;


   M : Project_Memos.Memo_Entry := Get (Project_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_27 := M.Instance;
      return Transform_Res_27;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_27;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_29 := pos;


--  Start row_submatch


Fncall_Res_61 := Context_Clauses_List_Parse_0(Parser, Row_Pos_29);
Fncall_Pos_61 := Parser.Current_Pos;


if Fncall_Pos_61 /= No_Token_Index then

   Row_Pos_29 := Fncall_Pos_61;

      Row_Subres_0_29 := Fncall_Res_61;

else
   Row_Pos_29 := No_Token_Index;
   goto Row_Exit_Label_29_0;

end if;

--  End row_submatch


--  Start row_submatch


Fncall_Res_68 := Project_Declaration_Transform_Parse_0(Parser, Row_Pos_29);
Fncall_Pos_68 := Parser.Current_Pos;


if Fncall_Pos_68 /= No_Token_Index then

   Row_Pos_29 := Fncall_Pos_68;

      Row_Subres_1_26 := Fncall_Res_68;

else
   Row_Pos_29 := No_Token_Index;
   goto Row_Exit_Label_29_0;

end if;

--  End row_submatch


<<Row_Exit_Label_29_0>>

--  End row_code


if Row_Pos_29 /= No_Token_Index then

   Transform_Res_27 := Project
     (Project_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_27.Unit := Parser.Unit;
   Transform_Res_27.Token_Start := pos;
   Transform_Res_27.Token_End := (if Row_Pos_29 = pos
                        then pos
                        else Row_Pos_29 - 1);

      Transform_Res_27.F_Context_Clauses :=
            List_With_Decl (Row_Subres_0_29);

         if Row_Subres_0_29 /= null then
            Row_Subres_0_29.Parent := GPR_Node (Transform_Res_27);
         end if;
      Transform_Res_27.F_Project_Decl :=
            Project_Declaration (Row_Subres_1_26);

         if Row_Subres_1_26 /= null then
            Row_Subres_1_26.Parent := GPR_Node (Transform_Res_27);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Project_Transform_Parse_0_Memo,
        Row_Pos_29 /= No_Token_Index,
        Transform_Res_27,
        Pos,
        Row_Pos_29);


   Parser.Current_Pos := Row_Pos_29;

   return Transform_Res_27;
end Project_Transform_Parse_0;

   


Compilation_Unit_Transform_Parse_0_Memo : Compilation_Unit_Memos.Memo_Type;

function Compilation_Unit_Transform_Parse_0 (Parser : in out Parser_Type;
                               Pos    : Token_Index)
                               return Compilation_Unit
is
      Row_Pos_28 : Token_Index
         := No_Token_Index;
      Fncall_Pos_69 : Token_Index
         := No_Token_Index;
      Fncall_Res_69 : Project
         := null;
      Row_Subres_0_28 : Project
         := null;
      Transform_Res_28 : Compilation_Unit
         := null;


   M : Compilation_Unit_Memos.Memo_Entry := Get (Compilation_Unit_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_28 := M.Instance;
      return Transform_Res_28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_28;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_28 := pos;


--  Start row_submatch


Fncall_Res_69 := Project_Transform_Parse_0(Parser, Row_Pos_28);
Fncall_Pos_69 := Parser.Current_Pos;


if Fncall_Pos_69 /= No_Token_Index then

   Row_Pos_28 := Fncall_Pos_69;

      Row_Subres_0_28 := Fncall_Res_69;

else
   Row_Pos_28 := No_Token_Index;
   goto Row_Exit_Label_28_0;

end if;

--  End row_submatch


<<Row_Exit_Label_28_0>>

--  End row_code


if Row_Pos_28 /= No_Token_Index then

   Transform_Res_28 := Compilation_Unit
     (Compilation_Unit_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_28.Unit := Parser.Unit;
   Transform_Res_28.Token_Start := pos;
   Transform_Res_28.Token_End := (if Row_Pos_28 = pos
                        then pos
                        else Row_Pos_28 - 1);

      Transform_Res_28.F_Project :=
            Project (Row_Subres_0_28);

         if Row_Subres_0_28 /= null then
            Row_Subres_0_28.Parent := GPR_Node (Transform_Res_28);
         end if;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Compilation_Unit_Transform_Parse_0_Memo,
        Row_Pos_28 /= No_Token_Index,
        Transform_Res_28,
        Pos,
        Row_Pos_28);


   Parser.Current_Pos := Row_Pos_28;

   return Transform_Res_28;
end Compilation_Unit_Transform_Parse_0;


   ---------------------
   -- Clean_All_Memos --
   ---------------------

   procedure Clean_All_Memos is
   begin
         Clear (Package_Renaming_Transform_Parse_0_Memo);
         Clear (Qualifier_Names_Transform_Parse_0_Memo);
         Clear (Variable_Reference_Transform_Parse_0_Memo);
         Clear (Project_Declaration_Transform_Parse_0_Memo);
         Clear (String_Literal_Transform_Parse_0_Memo);
         Clear (Context_Clauses_List_Parse_0_Memo);
         Clear (Others_Designator_Transform_Parse_0_Memo);
         Clear (Empty_Declaration_Transform_Parse_0_Memo);
         Clear (Static_Name_List_Parse_0_Memo);
         Clear (Project_Qualifier_Transform_Parse_0_Memo);
         Clear (Package_Decl_Transform_Parse_0_Memo);
         Clear (Project_Extension_Transform_Parse_0_Memo);
         Clear (Declarative_Item_Or_Parse_0_Memo);
         Clear (Num_Literal_Transform_Parse_0_Memo);
         Clear (String_Literal_At_Transform_Parse_0_Memo);
         Clear (Compilation_Unit_Transform_Parse_0_Memo);
         Clear (Attribute_Reference_Transform_Parse_0_Memo);
         Clear (Simple_Declarative_Items_List_Parse_0_Memo);
         Clear (Discrete_Choice_List_List_Parse_0_Memo);
         Clear (Attribute_Decl_Transform_Parse_0_Memo);
         Clear (Expression_List_Transform_Parse_0_Memo);
         Clear (Variable_Decl_Transform_Parse_0_Memo);
         Clear (Package_Extension_Transform_Parse_0_Memo);
         Clear (With_Decl_Transform_Parse_0_Memo);
         Clear (Associative_Array_Index_Or_Parse_0_Memo);
         Clear (Abstract_Present_Transform_Parse_0_Memo);
         Clear (Case_Item_Transform_Parse_0_Memo);
         Clear (Choice_Or_Parse_0_Memo);
         Clear (Project_Transform_Parse_0_Memo);
         Clear (Package_Spec_Transform_Parse_0_Memo);
         Clear (Builtin_Function_Call_Transform_Parse_0_Memo);
         Clear (Term_Or_Parse_0_Memo);
         Clear (Project_Reference_Transform_Parse_0_Memo);
         Clear (Simple_Declarative_Item_Or_Parse_0_Memo);
         Clear (Identifier_Transform_Parse_0_Memo);
         Clear (Expression_Transform_Parse_0_Memo);
         Clear (Typed_String_Decl_Transform_Parse_0_Memo);
         Clear (Declarative_Items_List_Parse_0_Memo);
         Clear (Case_Construction_Transform_Parse_0_Memo);
   end Clean_All_Memos;

end GPR_Parser.AST.Types.Parsers;
