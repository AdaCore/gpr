
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2017, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE


with Ada.Strings.Wide_Wide_Unbounded; use Ada.Strings.Wide_Wide_Unbounded;

with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Packrat;
with Langkit_Support.Text;    use Langkit_Support.Text;

package body GPR_Parser.Analysis.Parsers is

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists). Likewise for bump ptr. allocators, except
   --  we need them only for non-abstract AST nodes.
   --
   --  In the Tagged_Alloc instanciations, there are unchecked conversions to
   --  wrap System.Address values from a low-level allocator. All read/writes
   --  for the pointed values are made through values of the same access types
   --  (i.e. AST node access). Thus, strict aliasing issues should not arise
   --  for these.
   --
   --  See <https://gcc.gnu.org/onlinedocs/gnat_ugn/
   --       Optimization-and-Strict-Aliasing.html>.

   pragma Warnings (Off, "is not referenced");
   pragma Warnings (Off, "possible aliasing problem for type");

      package GPR_Node_Memos is new Langkit_Support.Packrat
        (GPR_Node, Token_Index);
      use GPR_Node_Memos;

      package Abstract_Present_Memos is new Langkit_Support.Packrat
        (Abstract_Present, Token_Index);
      use Abstract_Present_Memos;

         package Abstract_Present_Alloc is
            new Tagged_Alloc (Abstract_Present_Type);
      package Attribute_Decl_Memos is new Langkit_Support.Packrat
        (Attribute_Decl, Token_Index);
      use Attribute_Decl_Memos;

         package Attribute_Decl_Alloc is
            new Tagged_Alloc (Attribute_Decl_Type);
      package Attribute_Reference_Memos is new Langkit_Support.Packrat
        (Attribute_Reference, Token_Index);
      use Attribute_Reference_Memos;

         package Attribute_Reference_Alloc is
            new Tagged_Alloc (Attribute_Reference_Type);
      package Base_List_Memos is new Langkit_Support.Packrat
        (Base_List, Token_Index);
      use Base_List_Memos;

      package Case_Item_List_Memos is new Langkit_Support.Packrat
        (Case_Item_List, Token_Index);
      use Case_Item_List_Memos;

         package Case_Item_List_Alloc is
            new Tagged_Alloc (Case_Item_List_Type);
      package GPR_Node_List_Memos is new Langkit_Support.Packrat
        (GPR_Node_List, Token_Index);
      use GPR_Node_List_Memos;

         package GPR_Node_List_Alloc is
            new Tagged_Alloc (GPR_Node_List_Type);
      package String_Literal_List_Memos is new Langkit_Support.Packrat
        (String_Literal_List, Token_Index);
      use String_Literal_List_Memos;

         package String_Literal_List_Alloc is
            new Tagged_Alloc (String_Literal_List_Type);
      package Term_List_List_Memos is new Langkit_Support.Packrat
        (Term_List_List, Token_Index);
      use Term_List_List_Memos;

         package Term_List_List_Alloc is
            new Tagged_Alloc (Term_List_List_Type);
      package With_Decl_List_Memos is new Langkit_Support.Packrat
        (With_Decl_List, Token_Index);
      use With_Decl_List_Memos;

         package With_Decl_List_Alloc is
            new Tagged_Alloc (With_Decl_List_Type);
      package Builtin_Function_Call_Memos is new Langkit_Support.Packrat
        (Builtin_Function_Call, Token_Index);
      use Builtin_Function_Call_Memos;

         package Builtin_Function_Call_Alloc is
            new Tagged_Alloc (Builtin_Function_Call_Type);
      package Case_Construction_Memos is new Langkit_Support.Packrat
        (Case_Construction, Token_Index);
      use Case_Construction_Memos;

         package Case_Construction_Alloc is
            new Tagged_Alloc (Case_Construction_Type);
      package Case_Item_Memos is new Langkit_Support.Packrat
        (Case_Item, Token_Index);
      use Case_Item_Memos;

         package Case_Item_Alloc is
            new Tagged_Alloc (Case_Item_Type);
      package Compilation_Unit_Memos is new Langkit_Support.Packrat
        (Compilation_Unit, Token_Index);
      use Compilation_Unit_Memos;

         package Compilation_Unit_Alloc is
            new Tagged_Alloc (Compilation_Unit_Type);
      package Empty_Decl_Memos is new Langkit_Support.Packrat
        (Empty_Decl, Token_Index);
      use Empty_Decl_Memos;

         package Empty_Decl_Alloc is
            new Tagged_Alloc (Empty_Decl_Type);
      package Expr_Memos is new Langkit_Support.Packrat
        (Expr, Token_Index);
      use Expr_Memos;

      package Prefix_Memos is new Langkit_Support.Packrat
        (Prefix, Token_Index);
      use Prefix_Memos;

         package Prefix_Alloc is
            new Tagged_Alloc (Prefix_Type);
      package Single_Tok_Node_Memos is new Langkit_Support.Packrat
        (Single_Tok_Node, Token_Index);
      use Single_Tok_Node_Memos;

      package Identifier_Memos is new Langkit_Support.Packrat
        (Identifier, Token_Index);
      use Identifier_Memos;

         package Identifier_Alloc is
            new Tagged_Alloc (Identifier_Type);
      package Num_Literal_Memos is new Langkit_Support.Packrat
        (Num_Literal, Token_Index);
      use Num_Literal_Memos;

         package Num_Literal_Alloc is
            new Tagged_Alloc (Num_Literal_Type);
      package String_Literal_Memos is new Langkit_Support.Packrat
        (String_Literal, Token_Index);
      use String_Literal_Memos;

         package String_Literal_Alloc is
            new Tagged_Alloc (String_Literal_Type);
      package Expr_List_Memos is new Langkit_Support.Packrat
        (Expr_List, Token_Index);
      use Expr_List_Memos;

         package Expr_List_Alloc is
            new Tagged_Alloc (Expr_List_Type);
      package Others_Designator_Memos is new Langkit_Support.Packrat
        (Others_Designator, Token_Index);
      use Others_Designator_Memos;

         package Others_Designator_Alloc is
            new Tagged_Alloc (Others_Designator_Type);
      package Package_Decl_Memos is new Langkit_Support.Packrat
        (Package_Decl, Token_Index);
      use Package_Decl_Memos;

         package Package_Decl_Alloc is
            new Tagged_Alloc (Package_Decl_Type);
      package Package_Extension_Memos is new Langkit_Support.Packrat
        (Package_Extension, Token_Index);
      use Package_Extension_Memos;

         package Package_Extension_Alloc is
            new Tagged_Alloc (Package_Extension_Type);
      package Package_Renaming_Memos is new Langkit_Support.Packrat
        (Package_Renaming, Token_Index);
      use Package_Renaming_Memos;

         package Package_Renaming_Alloc is
            new Tagged_Alloc (Package_Renaming_Type);
      package Package_Spec_Memos is new Langkit_Support.Packrat
        (Package_Spec, Token_Index);
      use Package_Spec_Memos;

         package Package_Spec_Alloc is
            new Tagged_Alloc (Package_Spec_Type);
      package Project_Memos is new Langkit_Support.Packrat
        (Project, Token_Index);
      use Project_Memos;

         package Project_Alloc is
            new Tagged_Alloc (Project_Type);
      package Project_Declaration_Memos is new Langkit_Support.Packrat
        (Project_Declaration, Token_Index);
      use Project_Declaration_Memos;

         package Project_Declaration_Alloc is
            new Tagged_Alloc (Project_Declaration_Type);
      package Project_Extension_Memos is new Langkit_Support.Packrat
        (Project_Extension, Token_Index);
      use Project_Extension_Memos;

         package Project_Extension_Alloc is
            new Tagged_Alloc (Project_Extension_Type);
      package Project_Qualifier_Memos is new Langkit_Support.Packrat
        (Project_Qualifier, Token_Index);
      use Project_Qualifier_Memos;

         package Project_Qualifier_Alloc is
            new Tagged_Alloc (Project_Qualifier_Type);
      package Project_Reference_Memos is new Langkit_Support.Packrat
        (Project_Reference, Token_Index);
      use Project_Reference_Memos;

         package Project_Reference_Alloc is
            new Tagged_Alloc (Project_Reference_Type);
      package Qualifier_Names_Memos is new Langkit_Support.Packrat
        (Qualifier_Names, Token_Index);
      use Qualifier_Names_Memos;

         package Qualifier_Names_Alloc is
            new Tagged_Alloc (Qualifier_Names_Type);
      package String_Literal_At_Memos is new Langkit_Support.Packrat
        (String_Literal_At, Token_Index);
      use String_Literal_At_Memos;

         package String_Literal_At_Alloc is
            new Tagged_Alloc (String_Literal_At_Type);
      package Term_List_Memos is new Langkit_Support.Packrat
        (Term_List, Token_Index);
      use Term_List_Memos;

         package Term_List_Alloc is
            new Tagged_Alloc (Term_List_Type);
      package Typed_String_Decl_Memos is new Langkit_Support.Packrat
        (Typed_String_Decl, Token_Index);
      use Typed_String_Decl_Memos;

         package Typed_String_Decl_Alloc is
            new Tagged_Alloc (Typed_String_Decl_Type);
      package Variable_Decl_Memos is new Langkit_Support.Packrat
        (Variable_Decl, Token_Index);
      use Variable_Decl_Memos;

         package Variable_Decl_Alloc is
            new Tagged_Alloc (Variable_Decl_Type);
      package Variable_Reference_Memos is new Langkit_Support.Packrat
        (Variable_Reference, Token_Index);
      use Variable_Reference_Memos;

         package Variable_Reference_Alloc is
            new Tagged_Alloc (Variable_Reference_Type);
      package With_Decl_Memos is new Langkit_Support.Packrat
        (With_Decl, Token_Index);
      use With_Decl_Memos;

         package With_Decl_Alloc is
            new Tagged_Alloc (With_Decl_Type);
   pragma Warnings (On, "is not referenced");
   pragma Warnings (On, "possible aliasing problem for type");

   type Free_Parse_List_Record;
   type Free_Parse_List is access all Free_Parse_List_Record;
   --  Cache of temporary lists of AST nodes used in List parsers

   type Free_Parse_List_Record is record
      Nodes : GPR_Node_Vectors.Vector;
      Next  : Free_Parse_List;
   end record;

   type Parser_Private_Part_Type is record
      Parse_Lists : Free_Parse_List;

      
      Discrete_Choice_List_List_Parse_0_Memo : GPR_Node_List_Memos.Memo_Type;
      
      Context_Clauses_List_Parse_0_Memo : With_Decl_List_Memos.Memo_Type;
      
      Declarative_Items_List_Parse_0_Memo : GPR_Node_List_Memos.Memo_Type;
      
      Simple_Declarative_Items_List_Parse_0_Memo : GPR_Node_List_Memos.Memo_Type;
      
      Term_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;
      
      Choice_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;
      
      Static_Name_Or_Parse_0_Memo : Expr_Memos.Memo_Type;
      
      Declarative_Item_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;
      
      Simple_Declarative_Item_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;
      
      Associative_Array_Index_Or_Parse_0_Memo : GPR_Node_Memos.Memo_Type;
      
      Project_Reference_Transform_Parse_0_Memo : Project_Reference_Memos.Memo_Type;
      
      Compilation_Unit_Transform_Parse_0_Memo : Compilation_Unit_Memos.Memo_Type;
      
      Package_Decl_Transform_Parse_0_Memo : Package_Decl_Memos.Memo_Type;
      
      Package_Renaming_Transform_Parse_0_Memo : Package_Renaming_Memos.Memo_Type;
      
      Package_Extension_Transform_Parse_0_Memo : Package_Extension_Memos.Memo_Type;
      
      Package_Spec_Transform_Parse_0_Memo : Package_Spec_Memos.Memo_Type;
      
      Empty_Declaration_Transform_Parse_0_Memo : Empty_Decl_Memos.Memo_Type;
      
      Case_Construction_Transform_Parse_0_Memo : Case_Construction_Memos.Memo_Type;
      
      Case_Item_Transform_Parse_0_Memo : Case_Item_Memos.Memo_Type;
      
      Others_Designator_Transform_Parse_0_Memo : Others_Designator_Memos.Memo_Type;
      
      Typed_String_Decl_Transform_Parse_0_Memo : Typed_String_Decl_Memos.Memo_Type;
      
      Identifier_Transform_Parse_0_Memo : Identifier_Memos.Memo_Type;
      
      String_Literal_Transform_Parse_0_Memo : String_Literal_Memos.Memo_Type;
      
      Num_Literal_Transform_Parse_0_Memo : Num_Literal_Memos.Memo_Type;
      
      Attribute_Reference_Transform_Parse_0_Memo : Attribute_Reference_Memos.Memo_Type;
      
      Variable_Reference_Transform_Parse_0_Memo : Variable_Reference_Memos.Memo_Type;
      
      Builtin_Function_Call_Transform_Parse_0_Memo : Builtin_Function_Call_Memos.Memo_Type;
      
      Expression_Transform_Parse_0_Memo : Term_List_Memos.Memo_Type;
      
      Expression_List_Transform_Parse_0_Memo : Expr_List_Memos.Memo_Type;
      
      String_Literal_At_Transform_Parse_0_Memo : String_Literal_At_Memos.Memo_Type;
      
      With_Decl_Transform_Parse_0_Memo : With_Decl_Memos.Memo_Type;
      
      Abstract_Present_Transform_Parse_0_Memo : Abstract_Present_Memos.Memo_Type;
      
      Qualifier_Names_Transform_Parse_0_Memo : Qualifier_Names_Memos.Memo_Type;
      
      Project_Qualifier_Transform_Parse_0_Memo : Project_Qualifier_Memos.Memo_Type;
      
      Project_Extension_Transform_Parse_0_Memo : Project_Extension_Memos.Memo_Type;
      
      Project_Declaration_Transform_Parse_0_Memo : Project_Declaration_Memos.Memo_Type;
      
      Project_Transform_Parse_0_Memo : Project_Memos.Memo_Type;
      
      Variable_Decl_Transform_Parse_0_Memo : Variable_Decl_Memos.Memo_Type;
      
      Attribute_Decl_Transform_Parse_0_Memo : Attribute_Decl_Memos.Memo_Type;
   end record;

   
function Identifier_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Identifier;

   
function Others_Designator_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Others_Designator;

   
function String_Literal_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return String_Literal;

   
function Attribute_Reference_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Attribute_Reference;

   
function Project_Reference_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Project_Reference;

   
function Static_Name_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Expr;

   
function Package_Renaming_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Package_Renaming;

   
function Num_Literal_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Num_Literal;

   
function String_Literal_At_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return String_Literal_At;

   
function Variable_Reference_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Variable_Reference;

   
function Term_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node;

   
function Expression_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Term_List;

   
function Expression_List_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Expr_List;

   
function Builtin_Function_Call_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Builtin_Function_Call;

   
function Package_Extension_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Package_Extension;

   
function Variable_Decl_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Variable_Decl;

   
function Associative_Array_Index_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node;

   
function Attribute_Decl_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Attribute_Decl;

   
function Choice_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node;

   
function Discrete_Choice_List_List_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node_List;

   
function Case_Item_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Case_Item;

   
function Case_Construction_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Case_Construction;

   
function Empty_Declaration_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Empty_Decl;

   
function Simple_Declarative_Item_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node;

   
function Simple_Declarative_Items_List_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node_List;

   
function Package_Spec_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Package_Spec;

   
function Package_Decl_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Package_Decl;

   
function Typed_String_Decl_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Typed_String_Decl;

   
function Declarative_Item_Or_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node;

   
function With_Decl_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return With_Decl;

   
function Context_Clauses_List_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return With_Decl_List;

   
function Abstract_Present_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Abstract_Present;

   
function Qualifier_Names_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Qualifier_Names;

   
function Project_Qualifier_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Project_Qualifier;

   
function Project_Extension_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Project_Extension;

   
function Declarative_Items_List_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return GPR_Node_List;

   
function Project_Declaration_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Project_Declaration;

   
function Project_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Project;

   
function Compilation_Unit_Transform_Parse_0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Compilation_Unit;


   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse. If
   --  the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List;
   --  Get a free parse list, or allocate one if there is no free parse list in
   --  Parser. When done with the result, the caller must invoke
   --  Release_Parse_List.

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List);
   --  Release a parse list, putting it in Parsers' free list. Set List to
   --  null.

   ----------------------
   -- Create_From_File --
   ----------------------

   procedure Init_Parser_From_File
     (Filename, Charset : String;
      Read_BOM          : Boolean;
      Unit              : Analysis_Unit;
      With_Trivia       : Boolean := False;
      Parser            : in out Parser_Type)
   is
      TDH : Token_Data_Handler_Access renames Token_Data (Unit);
   begin
      Lex_From_Filename (Filename, Charset, Read_BOM, TDH.all, With_Trivia);
      Reset (Parser);
      Parser.Unit := Unit;
      Parser.TDH := TDH;
   end Init_Parser_From_File;

   ------------------------
   -- Create_From_Buffer --
   ------------------------

   procedure Init_Parser_From_Buffer
     (Buffer, Charset : String;
      Read_BOM        : Boolean;
      Unit            : Analysis_Unit;
      With_Trivia     : Boolean := False;
      Parser          : in out Parser_Type)
   is
      TDH : Token_Data_Handler_Access renames Token_Data (Unit);
   begin
      Lex_From_Buffer (Buffer, Charset, Read_BOM, TDH.all, With_Trivia);
      Reset (Parser);
      Parser.Unit := Unit;
      Parser.TDH := TDH;
   end Init_Parser_From_Buffer;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True)
   is

      procedure Add_Last_Fail_Diagnostic is
         Last_Token : Lexer.Token_Data_Type renames
            Get_Token (Parser.TDH.all, Parser.Last_Fail.Pos);
         D : constant Diagnostic :=
           (if Parser.Last_Fail.Kind = Token_Fail then
             (Sloc_Range => Last_Token.Sloc_Range,
              Message    => To_Unbounded_Wide_Wide_String (To_Text
                ("Expected "
                 & Token_Error_Image (Parser.Last_Fail.Expected_Token_Id)
                 & ", got "
                 & Token_Error_Image (Parser.Last_Fail.Found_Token_Id))))
            else
              (Sloc_Range => Last_Token.Sloc_Range,
               Message => To_Unbounded_Wide_Wide_String
                 (To_Text (Parser.Last_Fail.Custom_Message.all))));
      begin
         Parser.Diagnostics.Append (D);
      end Add_Last_Fail_Diagnostic;

   begin

      if Parser.Current_Pos = No_Token_Index then

         Add_Last_Fail_Diagnostic;
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser or after,
         --  it means that the longest parse is the correct result, and that we
         --  have some garbage afterwards.
         if Parser.Current_Pos >= Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Lexer.Token_Data_Type renames
                  Get_Token (Parser.TDH.all, Parser.Current_Pos);
               D                   : constant Diagnostic :=
                 (Sloc_Range => First_Garbage_Token.Sloc_Range,
                  Message    => To_Unbounded_Wide_Wide_String (To_Text
                    ("End of input expected, got """
                     & Token_Kind_Name (First_Garbage_Token.Kind)
                     & """")));
            begin
               Parser.Diagnostics.Append (D);
            end;

         --  Else, the last fail pos is further down the line, and we want to
         --  have the diagnostic of what exactly failed.
         else
            Add_Last_Fail_Diagnostic;
         end if;
      end if;

   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True;
      Rule           : Grammar_Rule)
      return GPR_Node
   is
      Result : GPR_Node;
   begin
      case Rule is
         when Abstract_Present_Rule =>
            Result := GPR_Node
              (Abstract_Present_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Associative_Array_Index_Rule =>
            Result := GPR_Node
              (Associative_Array_Index_Or_Parse_0
                 (Parser, First_Token_Index));
         when Attribute_Decl_Rule =>
            Result := GPR_Node
              (Attribute_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Attribute_Reference_Rule =>
            Result := GPR_Node
              (Attribute_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Builtin_Function_Call_Rule =>
            Result := GPR_Node
              (Builtin_Function_Call_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Case_Construction_Rule =>
            Result := GPR_Node
              (Case_Construction_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Case_Item_Rule =>
            Result := GPR_Node
              (Case_Item_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Choice_Rule =>
            Result := GPR_Node
              (Choice_Or_Parse_0
                 (Parser, First_Token_Index));
         when Compilation_Unit_Rule =>
            Result := GPR_Node
              (Compilation_Unit_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Context_Clauses_Rule =>
            Result := GPR_Node
              (Context_Clauses_List_Parse_0
                 (Parser, First_Token_Index));
         when Declarative_Item_Rule =>
            Result := GPR_Node
              (Declarative_Item_Or_Parse_0
                 (Parser, First_Token_Index));
         when Declarative_Items_Rule =>
            Result := GPR_Node
              (Declarative_Items_List_Parse_0
                 (Parser, First_Token_Index));
         when Discrete_Choice_List_Rule =>
            Result := GPR_Node
              (Discrete_Choice_List_List_Parse_0
                 (Parser, First_Token_Index));
         when Empty_Declaration_Rule =>
            Result := GPR_Node
              (Empty_Declaration_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Expression_Rule =>
            Result := GPR_Node
              (Expression_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Expression_List_Rule =>
            Result := GPR_Node
              (Expression_List_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Identifier_Rule =>
            Result := GPR_Node
              (Identifier_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Num_Literal_Rule =>
            Result := GPR_Node
              (Num_Literal_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Others_Designator_Rule =>
            Result := GPR_Node
              (Others_Designator_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Decl_Rule =>
            Result := GPR_Node
              (Package_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Extension_Rule =>
            Result := GPR_Node
              (Package_Extension_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Renaming_Rule =>
            Result := GPR_Node
              (Package_Renaming_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Package_Spec_Rule =>
            Result := GPR_Node
              (Package_Spec_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Rule =>
            Result := GPR_Node
              (Project_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Declaration_Rule =>
            Result := GPR_Node
              (Project_Declaration_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Extension_Rule =>
            Result := GPR_Node
              (Project_Extension_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Qualifier_Rule =>
            Result := GPR_Node
              (Project_Qualifier_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Project_Reference_Rule =>
            Result := GPR_Node
              (Project_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Qualifier_Names_Rule =>
            Result := GPR_Node
              (Qualifier_Names_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Simple_Declarative_Item_Rule =>
            Result := GPR_Node
              (Simple_Declarative_Item_Or_Parse_0
                 (Parser, First_Token_Index));
         when Simple_Declarative_Items_Rule =>
            Result := GPR_Node
              (Simple_Declarative_Items_List_Parse_0
                 (Parser, First_Token_Index));
         when Static_Name_Rule =>
            Result := GPR_Node
              (Static_Name_Or_Parse_0
                 (Parser, First_Token_Index));
         when String_Literal_Rule =>
            Result := GPR_Node
              (String_Literal_Transform_Parse_0
                 (Parser, First_Token_Index));
         when String_Literal_At_Rule =>
            Result := GPR_Node
              (String_Literal_At_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Term_Rule =>
            Result := GPR_Node
              (Term_Or_Parse_0
                 (Parser, First_Token_Index));
         when Typed_String_Decl_Rule =>
            Result := GPR_Node
              (Typed_String_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Variable_Decl_Rule =>
            Result := GPR_Node
              (Variable_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
         when Variable_Reference_Rule =>
            Result := GPR_Node
              (Variable_Reference_Transform_Parse_0
                 (Parser, First_Token_Index));
         when With_Decl_Rule =>
            Result := GPR_Node
              (With_Decl_Transform_Parse_0
                 (Parser, First_Token_Index));
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Set_Parents (Result, null);
      return Result;
   end Parse;

   


function Identifier_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Identifier
is
      Tok_Pos_4 :
            Token_Index
               := No_Token_Index;
      Tok_Res_4 :
            Token_Index
               := No_Token_Index;
      Transform_Res_2 :
            Identifier
               := null;


   M : Identifier_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Identifier_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_2 := M.Instance;
      return Transform_Res_2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tok_Res_4 := Pos;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_4));
begin
   if
      T.Kind /= GPR_Identifier
   then
       Tok_Pos_4 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Pos then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Pos,
             Expected_Token_Id => GPR_Identifier,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_4 := Pos + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_4 /= No_Token_Index then

   Transform_Res_2 := Identifier
     (Identifier_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_2.Unit := Parser.Unit;
   Transform_Res_2.Token_Start_Index := Pos;
   Transform_Res_2.Token_End_Index :=
     (if Tok_Pos_4 = Pos
      then No_Token_Index
      else Tok_Pos_4 - 1);

      Transform_Res_2.F_Tok :=
            Tok_Res_4;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Identifier_Transform_Parse_0_Memo,
        Tok_Pos_4 /= No_Token_Index,
        Transform_Res_2,
        Pos,
        Tok_Pos_4);


   Parser.Current_Pos := Tok_Pos_4;

   return Transform_Res_2;
end Identifier_Transform_Parse_0;

   


function Others_Designator_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Others_Designator
is
      Tok_Pos_5 :
            Token_Index
               := No_Token_Index;
      Tok_Res_5 :
            Token_Index
               := No_Token_Index;
      Transform_Res_3 :
            Others_Designator
               := null;


   M : Others_Designator_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_3 := M.Instance;
      return Transform_Res_3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_3;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tok_Res_5 := Pos;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_5));
begin
   if
      T.Kind /= GPR_Others
   then
       Tok_Pos_5 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Pos then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Pos,
             Expected_Token_Id => GPR_Others,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_5 := Pos + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_5 /= No_Token_Index then

   Transform_Res_3 := Others_Designator
     (Others_Designator_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_3.Unit := Parser.Unit;
   Transform_Res_3.Token_Start_Index := Pos;
   Transform_Res_3.Token_End_Index :=
     (if Tok_Pos_5 = Pos
      then No_Token_Index
      else Tok_Pos_5 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo,
        Tok_Pos_5 /= No_Token_Index,
        Transform_Res_3,
        Pos,
        Tok_Pos_5);


   Parser.Current_Pos := Tok_Pos_5;

   return Transform_Res_3;
end Others_Designator_Transform_Parse_0;

   


function String_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return String_Literal
is
      Tok_Pos_6 :
            Token_Index
               := No_Token_Index;
      Tok_Res_6 :
            Token_Index
               := No_Token_Index;
      Transform_Res_4 :
            String_Literal
               := null;


   M : String_Literal_Memos.Memo_Entry :=
     Get (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_4 := M.Instance;
      return Transform_Res_4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tok_Res_6 := Pos;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_6));
begin
   if
      T.Kind /= GPR_String
   then
       Tok_Pos_6 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Pos then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Pos,
             Expected_Token_Id => GPR_String,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_6 := Pos + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_6 /= No_Token_Index then

   Transform_Res_4 := String_Literal
     (String_Literal_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_4.Unit := Parser.Unit;
   Transform_Res_4.Token_Start_Index := Pos;
   Transform_Res_4.Token_End_Index :=
     (if Tok_Pos_6 = Pos
      then No_Token_Index
      else Tok_Pos_6 - 1);

      Transform_Res_4.F_Tok :=
            Tok_Res_6;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo,
        Tok_Pos_6 /= No_Token_Index,
        Transform_Res_4,
        Pos,
        Tok_Pos_6);


   Parser.Current_Pos := Tok_Pos_6;

   return Transform_Res_4;
end String_Literal_Transform_Parse_0;

   


function Attribute_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Attribute_Reference
is
      Row_Pos_1 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_1 :
            Token_Index
               := No_Token_Index;
      Defer_Res_1 :
            Identifier
               := null;
      Row_Pos_2 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_2 :
            Token_Index
               := No_Token_Index;
      Tok_Res_2 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_2 :
            Token_Index
               := No_Token_Index;
      Defer_Res_2 :
            Others_Designator
               := null;
      Defer_Pos_3 :
            Token_Index
               := No_Token_Index;
      Defer_Res_3 :
            String_Literal
               := null;
      Or_Pos_0 :
            Token_Index
               := No_Token_Index;
      Or_Res_0 :
            GPR_Node
               := null;
      Tok_Pos_3 :
            Token_Index
               := No_Token_Index;
      Tok_Res_3 :
            Token_Index
               := No_Token_Index;
      Transform_Res_1 :
            Attribute_Reference
               := null;


   M : Attribute_Reference_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Attribute_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_1 := M.Instance;
      return Transform_Res_1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_1;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_1 := Pos;





Defer_Res_1 := Identifier_Transform_Parse_0(Parser, Row_Pos_1);
Defer_Pos_1 := Parser.Current_Pos;


if Defer_Pos_1 /= No_Token_Index then

   Row_Pos_1 := Defer_Pos_1;

else
   Row_Pos_1 := No_Token_Index;
   goto Exit_Row_1_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_2 := Row_Pos_1;





--  Start tok_code

Tok_Res_2 := Row_Pos_2;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_2));
begin
   if
      T.Kind /= GPR_Par_Open
   then
       Tok_Pos_2 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_2 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_2,
             Expected_Token_Id => GPR_Par_Open,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_2 := Row_Pos_2 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_2 /= No_Token_Index then

   Row_Pos_2 := Tok_Pos_2;

else
   Row_Pos_2 := No_Token_Index;
   goto Exit_Row_2_0;

end if;




--  Start or_code

Or_Pos_0 := No_Token_Index;
Or_Res_0 := null;
    
Defer_Res_2 := Others_Designator_Transform_Parse_0(Parser, Row_Pos_2);
Defer_Pos_2 := Parser.Current_Pos;

    if Defer_Pos_2 /= No_Token_Index then
        Or_Pos_0 := Defer_Pos_2;
        Or_Res_0 := GPR_Node
          (Defer_Res_2);
        goto Exit_Or_0;
    end if;
    
Defer_Res_3 := String_Literal_Transform_Parse_0(Parser, Row_Pos_2);
Defer_Pos_3 := Parser.Current_Pos;

    if Defer_Pos_3 /= No_Token_Index then
        Or_Pos_0 := Defer_Pos_3;
        Or_Res_0 := GPR_Node
          (Defer_Res_3);
        goto Exit_Or_0;
    end if;
<<Exit_Or_0>>

--  End or_code


if Or_Pos_0 /= No_Token_Index then

   Row_Pos_2 := Or_Pos_0;

else
   Row_Pos_2 := No_Token_Index;
   goto Exit_Row_2_0;

end if;




--  Start tok_code

Tok_Res_3 := Row_Pos_2;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_3));
begin
   if
      T.Kind /= GPR_Par_Close
   then
       Tok_Pos_3 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_2 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_2,
             Expected_Token_Id => GPR_Par_Close,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_3 := Row_Pos_2 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_3 /= No_Token_Index then

   Row_Pos_2 := Tok_Pos_3;

else
   Row_Pos_2 := No_Token_Index;
   goto Exit_Row_2_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_2_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_2 = No_Token_Index then
        Or_Res_0 :=
           null;


    Row_Pos_2 := Row_Pos_1;


end if;

--  End opt_code


if Row_Pos_2 /= No_Token_Index then

   Row_Pos_1 := Row_Pos_2;

else
   Row_Pos_1 := No_Token_Index;
   goto Exit_Row_1_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_1_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_1 /= No_Token_Index then

   Transform_Res_1 := Attribute_Reference
     (Attribute_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_1.Unit := Parser.Unit;
   Transform_Res_1.Token_Start_Index := Pos;
   Transform_Res_1.Token_End_Index :=
     (if Row_Pos_1 = Pos
      then No_Token_Index
      else Row_Pos_1 - 1);

      Transform_Res_1.F_Attribute_Name :=
            Identifier (Defer_Res_1);
      Transform_Res_1.F_Attribute_Index :=
            GPR_Node (Or_Res_0);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Attribute_Reference_Transform_Parse_0_Memo,
        Row_Pos_1 /= No_Token_Index,
        Transform_Res_1,
        Pos,
        Row_Pos_1);


   Parser.Current_Pos := Row_Pos_1;

   return Transform_Res_1;
end Attribute_Reference_Transform_Parse_0;

   


function Project_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Project_Reference
is
      Row_Pos_0 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_0 :
            Token_Index
               := No_Token_Index;
      Tok_Res_0 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_1 :
            Token_Index
               := No_Token_Index;
      Tok_Res_1 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_0 :
            Token_Index
               := No_Token_Index;
      Defer_Res_0 :
            Attribute_Reference
               := null;
      Transform_Res_0 :
            Project_Reference
               := null;


   M : Project_Reference_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Project_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_0 := M.Instance;
      return Transform_Res_0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_0 := Pos;





--  Start tok_code

Tok_Res_0 := Row_Pos_0;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_0));
begin
   if
      T.Kind /= GPR_Project
   then
       Tok_Pos_0 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_0 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_0,
             Expected_Token_Id => GPR_Project,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_0 := Row_Pos_0 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_0 /= No_Token_Index then

   Row_Pos_0 := Tok_Pos_0;

else
   Row_Pos_0 := No_Token_Index;
   goto Exit_Row_0_0;

end if;




--  Start tok_code

Tok_Res_1 := Row_Pos_0;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_1));
begin
   if
      T.Kind /= GPR_Tick
   then
       Tok_Pos_1 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_0 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_0,
             Expected_Token_Id => GPR_Tick,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_1 := Row_Pos_0 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_1 /= No_Token_Index then

   Row_Pos_0 := Tok_Pos_1;

else
   Row_Pos_0 := No_Token_Index;
   goto Exit_Row_0_0;

end if;




Defer_Res_0 := Attribute_Reference_Transform_Parse_0(Parser, Row_Pos_0);
Defer_Pos_0 := Parser.Current_Pos;


if Defer_Pos_0 /= No_Token_Index then

   Row_Pos_0 := Defer_Pos_0;

else
   Row_Pos_0 := No_Token_Index;
   goto Exit_Row_0_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_0_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_0 /= No_Token_Index then

   Transform_Res_0 := Project_Reference
     (Project_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_0.Unit := Parser.Unit;
   Transform_Res_0.Token_Start_Index := Pos;
   Transform_Res_0.Token_End_Index :=
     (if Row_Pos_0 = Pos
      then No_Token_Index
      else Row_Pos_0 - 1);

      Transform_Res_0.F_Attr_Ref :=
            Attribute_Reference (Defer_Res_0);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Project_Reference_Transform_Parse_0_Memo,
        Row_Pos_0 /= No_Token_Index,
        Transform_Res_0,
        Pos,
        Row_Pos_0);


   Parser.Current_Pos := Row_Pos_0;

   return Transform_Res_0;
end Project_Reference_Transform_Parse_0;

   


function Static_Name_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Expr
is
      Defer_Pos_4 :
            Token_Index
               := No_Token_Index;
      Defer_Res_4 :
            Identifier
               := null;
      Row_Pos_3 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_5 :
            Token_Index
               := No_Token_Index;
      Defer_Res_5 :
            Expr
               := null;
      Tok_Pos_7 :
            Token_Index
               := No_Token_Index;
      Tok_Res_7 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_6 :
            Token_Index
               := No_Token_Index;
      Defer_Res_6 :
            Identifier
               := null;
      Transform_Res_5 :
            Prefix
               := null;
      Or_Pos_1 :
            Token_Index
               := No_Token_Index;
      Or_Res_1 :
            Expr
               := null;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Expr := null;

   M : Expr_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Static_Name_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_1 := M.Instance;
      return Or_Res_1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_1;
   end if;

       Set (Parser.Private_Part.Static_Name_Or_Parse_0_Memo,
            False,
            Or_Res_1,
            Pos,
            Mem_Pos);

       <<Try_Again>>

   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_1 := No_Token_Index;
Or_Res_1 := null;
    
Defer_Res_4 := Identifier_Transform_Parse_0(Parser, Pos);
Defer_Pos_4 := Parser.Current_Pos;

    if Defer_Pos_4 /= No_Token_Index then
        Or_Pos_1 := Defer_Pos_4;
        Or_Res_1 := Expr
          (Defer_Res_4);
        goto Exit_Or_1;
    end if;
    
--  Start transform_code


--  Start row_code

Row_Pos_3 := Pos;





Defer_Res_5 := Static_Name_Or_Parse_0(Parser, Row_Pos_3);
Defer_Pos_5 := Parser.Current_Pos;


if Defer_Pos_5 /= No_Token_Index then

   Row_Pos_3 := Defer_Pos_5;

else
   Row_Pos_3 := No_Token_Index;
   goto Exit_Row_3_0;

end if;




--  Start tok_code

Tok_Res_7 := Row_Pos_3;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_7));
begin
   if
      T.Kind /= GPR_Dot
   then
       Tok_Pos_7 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_3 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_3,
             Expected_Token_Id => GPR_Dot,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_7 := Row_Pos_3 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_7 /= No_Token_Index then

   Row_Pos_3 := Tok_Pos_7;

else
   Row_Pos_3 := No_Token_Index;
   goto Exit_Row_3_0;

end if;




Defer_Res_6 := Identifier_Transform_Parse_0(Parser, Row_Pos_3);
Defer_Pos_6 := Parser.Current_Pos;


if Defer_Pos_6 /= No_Token_Index then

   Row_Pos_3 := Defer_Pos_6;

else
   Row_Pos_3 := No_Token_Index;
   goto Exit_Row_3_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_3_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_3 /= No_Token_Index then

   Transform_Res_5 := Prefix
     (Prefix_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_5.Unit := Parser.Unit;
   Transform_Res_5.Token_Start_Index := Pos;
   Transform_Res_5.Token_End_Index :=
     (if Row_Pos_3 = Pos
      then No_Token_Index
      else Row_Pos_3 - 1);

      Transform_Res_5.F_Prefix :=
            Expr (Defer_Res_5);
      Transform_Res_5.F_Suffix :=
            Identifier (Defer_Res_6);

end if;

--  End transform_code

    if Row_Pos_3 /= No_Token_Index then
        Or_Pos_1 := Row_Pos_3;
        Or_Res_1 := Expr
          (Transform_Res_5);
        goto Exit_Or_1;
    end if;
<<Exit_Or_1>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos_1 > Mem_Pos then
         Mem_Pos := Or_Pos_1;
         Mem_Res := Or_Res_1;
         Set (Parser.Private_Part.Static_Name_Or_Parse_0_Memo,
              Or_Pos_1 /= No_Token_Index,
              Or_Res_1,
              Pos,
              Or_Pos_1);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_1 := Mem_Res;
         Or_Pos_1 := Mem_Pos;
         goto No_Memo;
      end if;

   Set (Parser.Private_Part.Static_Name_Or_Parse_0_Memo,
        Or_Pos_1 /= No_Token_Index,
        Or_Res_1,
        Pos,
        Or_Pos_1);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos_1;

   return Or_Res_1;
end Static_Name_Or_Parse_0;

   


function Package_Renaming_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Package_Renaming
is
      Row_Pos_4 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_8 :
            Token_Index
               := No_Token_Index;
      Tok_Res_8 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_7 :
            Token_Index
               := No_Token_Index;
      Defer_Res_7 :
            Identifier
               := null;
      Tok_Pos_9 :
            Token_Index
               := No_Token_Index;
      Tok_Res_9 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_8 :
            Token_Index
               := No_Token_Index;
      Defer_Res_8 :
            Identifier
               := null;
      Transform_Res_6 :
            Package_Renaming
               := null;


   M : Package_Renaming_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Package_Renaming_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_6 := M.Instance;
      return Transform_Res_6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_4 := Pos;





--  Start tok_code

Tok_Res_8 := Row_Pos_4;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_8));
begin
   if
      T.Kind /= GPR_Renames
   then
       Tok_Pos_8 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_4 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_4,
             Expected_Token_Id => GPR_Renames,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_8 := Row_Pos_4 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_8 /= No_Token_Index then

   Row_Pos_4 := Tok_Pos_8;

else
   Row_Pos_4 := No_Token_Index;
   goto Exit_Row_4_0;

end if;




Defer_Res_7 := Identifier_Transform_Parse_0(Parser, Row_Pos_4);
Defer_Pos_7 := Parser.Current_Pos;


if Defer_Pos_7 /= No_Token_Index then

   Row_Pos_4 := Defer_Pos_7;

else
   Row_Pos_4 := No_Token_Index;
   goto Exit_Row_4_0;

end if;




--  Start tok_code

Tok_Res_9 := Row_Pos_4;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_9));
begin
   if
      T.Kind /= GPR_Dot
   then
       Tok_Pos_9 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_4 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_4,
             Expected_Token_Id => GPR_Dot,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_9 := Row_Pos_4 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_9 /= No_Token_Index then

   Row_Pos_4 := Tok_Pos_9;

else
   Row_Pos_4 := No_Token_Index;
   goto Exit_Row_4_0;

end if;




Defer_Res_8 := Identifier_Transform_Parse_0(Parser, Row_Pos_4);
Defer_Pos_8 := Parser.Current_Pos;


if Defer_Pos_8 /= No_Token_Index then

   Row_Pos_4 := Defer_Pos_8;

else
   Row_Pos_4 := No_Token_Index;
   goto Exit_Row_4_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_4_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_4 /= No_Token_Index then

   Transform_Res_6 := Package_Renaming
     (Package_Renaming_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_6.Unit := Parser.Unit;
   Transform_Res_6.Token_Start_Index := Pos;
   Transform_Res_6.Token_End_Index :=
     (if Row_Pos_4 = Pos
      then No_Token_Index
      else Row_Pos_4 - 1);

      Transform_Res_6.F_Prj_Name :=
            Identifier (Defer_Res_7);
      Transform_Res_6.F_Pkg_Name :=
            Identifier (Defer_Res_8);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Package_Renaming_Transform_Parse_0_Memo,
        Row_Pos_4 /= No_Token_Index,
        Transform_Res_6,
        Pos,
        Row_Pos_4);


   Parser.Current_Pos := Row_Pos_4;

   return Transform_Res_6;
end Package_Renaming_Transform_Parse_0;

   


function Num_Literal_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Num_Literal
is
      Tok_Pos_15 :
            Token_Index
               := No_Token_Index;
      Tok_Res_15 :
            Token_Index
               := No_Token_Index;
      Transform_Res_11 :
            Num_Literal
               := null;


   M : Num_Literal_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Num_Literal_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_11 := M.Instance;
      return Transform_Res_11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_11;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start tok_code

Tok_Res_15 := Pos;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_15));
begin
   if
      T.Kind /= GPR_Number
   then
       Tok_Pos_15 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Pos then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Pos,
             Expected_Token_Id => GPR_Number,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_15 := Pos + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_15 /= No_Token_Index then

   Transform_Res_11 := Num_Literal
     (Num_Literal_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_11.Unit := Parser.Unit;
   Transform_Res_11.Token_Start_Index := Pos;
   Transform_Res_11.Token_End_Index :=
     (if Tok_Pos_15 = Pos
      then No_Token_Index
      else Tok_Pos_15 - 1);

      Transform_Res_11.F_Tok :=
            Tok_Res_15;

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Num_Literal_Transform_Parse_0_Memo,
        Tok_Pos_15 /= No_Token_Index,
        Transform_Res_11,
        Pos,
        Tok_Pos_15);


   Parser.Current_Pos := Tok_Pos_15;

   return Transform_Res_11;
end Num_Literal_Transform_Parse_0;

   


function String_Literal_At_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return String_Literal_At
is
      Row_Pos_7 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_18 :
            Token_Index
               := No_Token_Index;
      Defer_Res_18 :
            String_Literal
               := null;
      Row_Pos_8 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_14 :
            Token_Index
               := No_Token_Index;
      Tok_Res_14 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_19 :
            Token_Index
               := No_Token_Index;
      Defer_Res_19 :
            Num_Literal
               := null;
      Transform_Res_10 :
            String_Literal_At
               := null;


   M : String_Literal_At_Memos.Memo_Entry :=
     Get (Parser.Private_Part.String_Literal_At_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_10 := M.Instance;
      return Transform_Res_10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_10;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_7 := Pos;





Defer_Res_18 := String_Literal_Transform_Parse_0(Parser, Row_Pos_7);
Defer_Pos_18 := Parser.Current_Pos;


if Defer_Pos_18 /= No_Token_Index then

   Row_Pos_7 := Defer_Pos_18;

else
   Row_Pos_7 := No_Token_Index;
   goto Exit_Row_7_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_8 := Row_Pos_7;





--  Start tok_code

Tok_Res_14 := Row_Pos_8;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_14));
begin
   if
      T.Kind /= GPR_At
   then
       Tok_Pos_14 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_8 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_8,
             Expected_Token_Id => GPR_At,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_14 := Row_Pos_8 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_14 /= No_Token_Index then

   Row_Pos_8 := Tok_Pos_14;

else
   Row_Pos_8 := No_Token_Index;
   goto Exit_Row_8_0;

end if;




Defer_Res_19 := Num_Literal_Transform_Parse_0(Parser, Row_Pos_8);
Defer_Pos_19 := Parser.Current_Pos;


if Defer_Pos_19 /= No_Token_Index then

   Row_Pos_8 := Defer_Pos_19;

else
   Row_Pos_8 := No_Token_Index;
   goto Exit_Row_8_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_8_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_8 = No_Token_Index then
        Defer_Res_19 :=
           null;


    Row_Pos_8 := Row_Pos_7;


end if;

--  End opt_code


if Row_Pos_8 /= No_Token_Index then

   Row_Pos_7 := Row_Pos_8;

else
   Row_Pos_7 := No_Token_Index;
   goto Exit_Row_7_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_7_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_7 /= No_Token_Index then

   Transform_Res_10 := String_Literal_At
     (String_Literal_At_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_10.Unit := Parser.Unit;
   Transform_Res_10.Token_Start_Index := Pos;
   Transform_Res_10.Token_End_Index :=
     (if Row_Pos_7 = Pos
      then No_Token_Index
      else Row_Pos_7 - 1);

      Transform_Res_10.F_Str_Lit :=
            String_Literal (Defer_Res_18);
      Transform_Res_10.F_At_Lit :=
            Num_Literal (Defer_Res_19);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.String_Literal_At_Transform_Parse_0_Memo,
        Row_Pos_7 /= No_Token_Index,
        Transform_Res_10,
        Pos,
        Row_Pos_7);


   Parser.Current_Pos := Row_Pos_7;

   return Transform_Res_10;
end String_Literal_At_Transform_Parse_0;

   


function Variable_Reference_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Variable_Reference
is
      Row_Pos_9 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_20 :
            Token_Index
               := No_Token_Index;
      Defer_Res_20 :
            Identifier
               := null;
      Row_Pos_10 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_16 :
            Token_Index
               := No_Token_Index;
      Tok_Res_16 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_21 :
            Token_Index
               := No_Token_Index;
      Defer_Res_21 :
            Identifier
               := null;
      Row_Pos_11 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_17 :
            Token_Index
               := No_Token_Index;
      Tok_Res_17 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_22 :
            Token_Index
               := No_Token_Index;
      Defer_Res_22 :
            Attribute_Reference
               := null;
      Transform_Res_12 :
            Variable_Reference
               := null;


   M : Variable_Reference_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Variable_Reference_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_12 := M.Instance;
      return Transform_Res_12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_12;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_9 := Pos;





Defer_Res_20 := Identifier_Transform_Parse_0(Parser, Row_Pos_9);
Defer_Pos_20 := Parser.Current_Pos;


if Defer_Pos_20 /= No_Token_Index then

   Row_Pos_9 := Defer_Pos_20;

else
   Row_Pos_9 := No_Token_Index;
   goto Exit_Row_9_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_10 := Row_Pos_9;





--  Start tok_code

Tok_Res_16 := Row_Pos_10;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_16));
begin
   if
      T.Kind /= GPR_Dot
   then
       Tok_Pos_16 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_10 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_10,
             Expected_Token_Id => GPR_Dot,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_16 := Row_Pos_10 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_16 /= No_Token_Index then

   Row_Pos_10 := Tok_Pos_16;

else
   Row_Pos_10 := No_Token_Index;
   goto Exit_Row_10_0;

end if;




Defer_Res_21 := Identifier_Transform_Parse_0(Parser, Row_Pos_10);
Defer_Pos_21 := Parser.Current_Pos;


if Defer_Pos_21 /= No_Token_Index then

   Row_Pos_10 := Defer_Pos_21;

else
   Row_Pos_10 := No_Token_Index;
   goto Exit_Row_10_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_10_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_10 = No_Token_Index then
        Defer_Res_21 :=
           null;


    Row_Pos_10 := Row_Pos_9;


end if;

--  End opt_code


if Row_Pos_10 /= No_Token_Index then

   Row_Pos_9 := Row_Pos_10;

else
   Row_Pos_9 := No_Token_Index;
   goto Exit_Row_9_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_11 := Row_Pos_9;





--  Start tok_code

Tok_Res_17 := Row_Pos_11;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_17));
begin
   if
      T.Kind /= GPR_Tick
   then
       Tok_Pos_17 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_11 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_11,
             Expected_Token_Id => GPR_Tick,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_17 := Row_Pos_11 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_17 /= No_Token_Index then

   Row_Pos_11 := Tok_Pos_17;

else
   Row_Pos_11 := No_Token_Index;
   goto Exit_Row_11_0;

end if;




Defer_Res_22 := Attribute_Reference_Transform_Parse_0(Parser, Row_Pos_11);
Defer_Pos_22 := Parser.Current_Pos;


if Defer_Pos_22 /= No_Token_Index then

   Row_Pos_11 := Defer_Pos_22;

else
   Row_Pos_11 := No_Token_Index;
   goto Exit_Row_11_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_11_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_11 = No_Token_Index then
        Defer_Res_22 :=
           null;


    Row_Pos_11 := Row_Pos_9;


end if;

--  End opt_code


if Row_Pos_11 /= No_Token_Index then

   Row_Pos_9 := Row_Pos_11;

else
   Row_Pos_9 := No_Token_Index;
   goto Exit_Row_9_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_9_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_9 /= No_Token_Index then

   Transform_Res_12 := Variable_Reference
     (Variable_Reference_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_12.Unit := Parser.Unit;
   Transform_Res_12.Token_Start_Index := Pos;
   Transform_Res_12.Token_End_Index :=
     (if Row_Pos_9 = Pos
      then No_Token_Index
      else Row_Pos_9 - 1);

      Transform_Res_12.F_Variable_Name1 :=
            Identifier (Defer_Res_20);
      Transform_Res_12.F_Variable_Name2 :=
            Identifier (Defer_Res_21);
      Transform_Res_12.F_Attribute_Ref :=
            Attribute_Reference (Defer_Res_22);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Variable_Reference_Transform_Parse_0_Memo,
        Row_Pos_9 /= No_Token_Index,
        Transform_Res_12,
        Pos,
        Row_Pos_9);


   Parser.Current_Pos := Row_Pos_9;

   return Transform_Res_12;
end Variable_Reference_Transform_Parse_0;

   


function Term_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node
is
      Defer_Pos_13 :
            Token_Index
               := No_Token_Index;
      Defer_Res_13 :
            Expr_List
               := null;
      Defer_Pos_14 :
            Token_Index
               := No_Token_Index;
      Defer_Res_14 :
            String_Literal_At
               := null;
      Defer_Pos_15 :
            Token_Index
               := No_Token_Index;
      Defer_Res_15 :
            Builtin_Function_Call
               := null;
      Defer_Pos_16 :
            Token_Index
               := No_Token_Index;
      Defer_Res_16 :
            Variable_Reference
               := null;
      Defer_Pos_17 :
            Token_Index
               := No_Token_Index;
      Defer_Res_17 :
            Project_Reference
               := null;
      Or_Pos_2 :
            Token_Index
               := No_Token_Index;
      Or_Res_2 :
            GPR_Node
               := null;


   M : GPR_Node_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Term_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_2 := M.Instance;
      return Or_Res_2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_2 := No_Token_Index;
Or_Res_2 := null;
    
Defer_Res_13 := Expression_List_Transform_Parse_0(Parser, Pos);
Defer_Pos_13 := Parser.Current_Pos;

    if Defer_Pos_13 /= No_Token_Index then
        Or_Pos_2 := Defer_Pos_13;
        Or_Res_2 := GPR_Node
          (Defer_Res_13);
        goto Exit_Or_2;
    end if;
    
Defer_Res_14 := String_Literal_At_Transform_Parse_0(Parser, Pos);
Defer_Pos_14 := Parser.Current_Pos;

    if Defer_Pos_14 /= No_Token_Index then
        Or_Pos_2 := Defer_Pos_14;
        Or_Res_2 := GPR_Node
          (Defer_Res_14);
        goto Exit_Or_2;
    end if;
    
Defer_Res_15 := Builtin_Function_Call_Transform_Parse_0(Parser, Pos);
Defer_Pos_15 := Parser.Current_Pos;

    if Defer_Pos_15 /= No_Token_Index then
        Or_Pos_2 := Defer_Pos_15;
        Or_Res_2 := GPR_Node
          (Defer_Res_15);
        goto Exit_Or_2;
    end if;
    
Defer_Res_16 := Variable_Reference_Transform_Parse_0(Parser, Pos);
Defer_Pos_16 := Parser.Current_Pos;

    if Defer_Pos_16 /= No_Token_Index then
        Or_Pos_2 := Defer_Pos_16;
        Or_Res_2 := GPR_Node
          (Defer_Res_16);
        goto Exit_Or_2;
    end if;
    
Defer_Res_17 := Project_Reference_Transform_Parse_0(Parser, Pos);
Defer_Pos_17 := Parser.Current_Pos;

    if Defer_Pos_17 /= No_Token_Index then
        Or_Pos_2 := Defer_Pos_17;
        Or_Res_2 := GPR_Node
          (Defer_Res_17);
        goto Exit_Or_2;
    end if;
<<Exit_Or_2>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Term_Or_Parse_0_Memo,
        Or_Pos_2 /= No_Token_Index,
        Or_Res_2,
        Pos,
        Or_Pos_2);


   Parser.Current_Pos := Or_Pos_2;

   return Or_Res_2;
end Term_Or_Parse_0;

   


function Expression_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Term_List
is
      Lst_Cpos_1 :
            Token_Index
               := No_Token_Index;
      Tmp_List_1 :
            Free_Parse_List;
      Defer_Pos_12 :
            Token_Index
               := No_Token_Index;
      Defer_Res_12 :
            GPR_Node
               := null;
      Tok_Pos_13 :
            Token_Index
               := No_Token_Index;
      Tok_Res_13 :
            Token_Index
               := No_Token_Index;
      List_Pos_1 :
            Token_Index
               := No_Token_Index;
      List_Res_1 :
            GPR_Node_List
               := null;
      Transform_Res_9 :
            Term_List
               := null;


   M : Term_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Expression_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_9 := M.Instance;
      return Transform_Res_9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_9;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start list_code

    List_Pos_1 := No_Token_Index;



Lst_Cpos_1 := Pos;
Tmp_List_1 := Get_Parse_List (Parser);

loop
   
Defer_Res_12 := Term_Or_Parse_0(Parser, Lst_Cpos_1);
Defer_Pos_12 := Parser.Current_Pos;


   exit when Defer_Pos_12 = No_Token_Index;

   List_Pos_1 := Defer_Pos_12;
   Lst_Cpos_1 := List_Pos_1;

   Tmp_List_1.Nodes.Append
     (GPR_Node (Defer_Res_12));

      
--  Start tok_code

Tok_Res_13 := Lst_Cpos_1;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_13));
begin
   if
      T.Kind /= GPR_Amp
   then
       Tok_Pos_13 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_1 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Lst_Cpos_1,
             Expected_Token_Id => GPR_Amp,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_13 := Lst_Cpos_1 + 1;
   end if;
end;

--  End tok_code

      if Tok_Pos_13 /= No_Token_Index then
          Lst_Cpos_1 := Tok_Pos_13;
      else
         exit;
      end if;

end loop;

List_Res_1 := GPR_Node_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_1.Unit := Parser.Unit;
List_Res_1.Count := Tmp_List_1.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_1.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_1.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_1.Count > 0 then
   List_Res_1.Token_Start_Index := Pos;
   List_Res_1.Token_End_Index :=
     (if Lst_Cpos_1 = Pos
      then Pos else Lst_Cpos_1 - 1);

else
   List_Res_1.Token_Start_Index :=
      Token_Index'Max (Pos, 1);
   List_Res_1.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_1);


--  End list_code


if List_Pos_1 /= No_Token_Index then

   Transform_Res_9 := Term_List
     (Term_List_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_9.Unit := Parser.Unit;
   Transform_Res_9.Token_Start_Index := Pos;
   Transform_Res_9.Token_End_Index :=
     (if List_Pos_1 = Pos
      then No_Token_Index
      else List_Pos_1 - 1);

      Transform_Res_9.F_Terms :=
            GPR_Node_List (List_Res_1);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Expression_Transform_Parse_0_Memo,
        List_Pos_1 /= No_Token_Index,
        Transform_Res_9,
        Pos,
        List_Pos_1);


   Parser.Current_Pos := List_Pos_1;

   return Transform_Res_9;
end Expression_Transform_Parse_0;

   


function Expression_List_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Expr_List
is
      Row_Pos_6 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_10 :
            Token_Index
               := No_Token_Index;
      Tok_Res_10 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos_0 :
            Token_Index
               := No_Token_Index;
      Tmp_List_0 :
            Free_Parse_List;
      Defer_Pos_11 :
            Token_Index
               := No_Token_Index;
      Defer_Res_11 :
            Term_List
               := null;
      Tok_Pos_11 :
            Token_Index
               := No_Token_Index;
      Tok_Res_11 :
            Token_Index
               := No_Token_Index;
      List_Pos_0 :
            Token_Index
               := No_Token_Index;
      List_Res_0 :
            Term_List_List
               := null;
      Tok_Pos_12 :
            Token_Index
               := No_Token_Index;
      Tok_Res_12 :
            Token_Index
               := No_Token_Index;
      Transform_Res_8 :
            Expr_List
               := null;


   M : Expr_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Expression_List_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_8 := M.Instance;
      return Transform_Res_8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_6 := Pos;





--  Start tok_code

Tok_Res_10 := Row_Pos_6;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_10));
begin
   if
      T.Kind /= GPR_Par_Open
   then
       Tok_Pos_10 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_6 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_6,
             Expected_Token_Id => GPR_Par_Open,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_10 := Row_Pos_6 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_10 /= No_Token_Index then

   Row_Pos_6 := Tok_Pos_10;

else
   Row_Pos_6 := No_Token_Index;
   goto Exit_Row_6_0;

end if;




--  Start list_code

    List_Pos_0 := Row_Pos_6;



Lst_Cpos_0 := Row_Pos_6;
Tmp_List_0 := Get_Parse_List (Parser);

loop
   
Defer_Res_11 := Expression_Transform_Parse_0(Parser, Lst_Cpos_0);
Defer_Pos_11 := Parser.Current_Pos;


   exit when Defer_Pos_11 = No_Token_Index;

   List_Pos_0 := Defer_Pos_11;
   Lst_Cpos_0 := List_Pos_0;

   Tmp_List_0.Nodes.Append
     (GPR_Node (Defer_Res_11));

      
--  Start tok_code

Tok_Res_11 := Lst_Cpos_0;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_11));
begin
   if
      T.Kind /= GPR_Comma
   then
       Tok_Pos_11 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_0 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Lst_Cpos_0,
             Expected_Token_Id => GPR_Comma,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_11 := Lst_Cpos_0 + 1;
   end if;
end;

--  End tok_code

      if Tok_Pos_11 /= No_Token_Index then
          Lst_Cpos_0 := Tok_Pos_11;
      else
         exit;
      end if;

end loop;

List_Res_0 := Term_List_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_0.Unit := Parser.Unit;
List_Res_0.Count := Tmp_List_0.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_0.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_0.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_0.Count > 0 then
   List_Res_0.Token_Start_Index := Row_Pos_6;
   List_Res_0.Token_End_Index :=
     (if Lst_Cpos_0 = Row_Pos_6
      then Row_Pos_6 else Lst_Cpos_0 - 1);

else
   List_Res_0.Token_Start_Index :=
      Token_Index'Max (Row_Pos_6, 1);
   List_Res_0.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_0);


--  End list_code


if List_Pos_0 /= No_Token_Index then

   Row_Pos_6 := List_Pos_0;

else
   Row_Pos_6 := No_Token_Index;
   goto Exit_Row_6_0;

end if;




--  Start tok_code

Tok_Res_12 := Row_Pos_6;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_12));
begin
   if
      T.Kind /= GPR_Par_Close
   then
       Tok_Pos_12 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_6 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_6,
             Expected_Token_Id => GPR_Par_Close,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_12 := Row_Pos_6 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_12 /= No_Token_Index then

   Row_Pos_6 := Tok_Pos_12;

else
   Row_Pos_6 := No_Token_Index;
   goto Exit_Row_6_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_6_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_6 /= No_Token_Index then

   Transform_Res_8 := Expr_List
     (Expr_List_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_8.Unit := Parser.Unit;
   Transform_Res_8.Token_Start_Index := Pos;
   Transform_Res_8.Token_End_Index :=
     (if Row_Pos_6 = Pos
      then No_Token_Index
      else Row_Pos_6 - 1);

      Transform_Res_8.F_Exprs :=
            Term_List_List (List_Res_0);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Expression_List_Transform_Parse_0_Memo,
        Row_Pos_6 /= No_Token_Index,
        Transform_Res_8,
        Pos,
        Row_Pos_6);


   Parser.Current_Pos := Row_Pos_6;

   return Transform_Res_8;
end Expression_List_Transform_Parse_0;

   


function Builtin_Function_Call_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Builtin_Function_Call
is
      Row_Pos_5 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_9 :
            Token_Index
               := No_Token_Index;
      Defer_Res_9 :
            Identifier
               := null;
      Defer_Pos_10 :
            Token_Index
               := No_Token_Index;
      Defer_Res_10 :
            Expr_List
               := null;
      Transform_Res_7 :
            Builtin_Function_Call
               := null;


   M : Builtin_Function_Call_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Builtin_Function_Call_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_7 := M.Instance;
      return Transform_Res_7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_7;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_5 := Pos;





Defer_Res_9 := Identifier_Transform_Parse_0(Parser, Row_Pos_5);
Defer_Pos_9 := Parser.Current_Pos;


if Defer_Pos_9 /= No_Token_Index then

   Row_Pos_5 := Defer_Pos_9;

else
   Row_Pos_5 := No_Token_Index;
   goto Exit_Row_5_0;

end if;




Defer_Res_10 := Expression_List_Transform_Parse_0(Parser, Row_Pos_5);
Defer_Pos_10 := Parser.Current_Pos;


if Defer_Pos_10 /= No_Token_Index then

   Row_Pos_5 := Defer_Pos_10;

else
   Row_Pos_5 := No_Token_Index;
   goto Exit_Row_5_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_5_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_5 /= No_Token_Index then

   Transform_Res_7 := Builtin_Function_Call
     (Builtin_Function_Call_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_7.Unit := Parser.Unit;
   Transform_Res_7.Token_Start_Index := Pos;
   Transform_Res_7.Token_End_Index :=
     (if Row_Pos_5 = Pos
      then No_Token_Index
      else Row_Pos_5 - 1);

      Transform_Res_7.F_Function_Name :=
            Identifier (Defer_Res_9);
      Transform_Res_7.F_Parameters :=
            Expr_List (Defer_Res_10);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Builtin_Function_Call_Transform_Parse_0_Memo,
        Row_Pos_5 /= No_Token_Index,
        Transform_Res_7,
        Pos,
        Row_Pos_5);


   Parser.Current_Pos := Row_Pos_5;

   return Transform_Res_7;
end Builtin_Function_Call_Transform_Parse_0;

   


function Package_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Package_Extension
is
      Row_Pos_14 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_21 :
            Token_Index
               := No_Token_Index;
      Tok_Res_21 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_29 :
            Token_Index
               := No_Token_Index;
      Defer_Res_29 :
            Identifier
               := null;
      Tok_Pos_22 :
            Token_Index
               := No_Token_Index;
      Tok_Res_22 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_30 :
            Token_Index
               := No_Token_Index;
      Defer_Res_30 :
            Identifier
               := null;
      Transform_Res_15 :
            Package_Extension
               := null;


   M : Package_Extension_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Package_Extension_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_15 := M.Instance;
      return Transform_Res_15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_15;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_14 := Pos;





--  Start tok_code

Tok_Res_21 := Row_Pos_14;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_21));
begin
   if
      T.Kind /= GPR_Extends
   then
       Tok_Pos_21 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_14 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_14,
             Expected_Token_Id => GPR_Extends,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_21 := Row_Pos_14 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_21 /= No_Token_Index then

   Row_Pos_14 := Tok_Pos_21;

else
   Row_Pos_14 := No_Token_Index;
   goto Exit_Row_14_0;

end if;




Defer_Res_29 := Identifier_Transform_Parse_0(Parser, Row_Pos_14);
Defer_Pos_29 := Parser.Current_Pos;


if Defer_Pos_29 /= No_Token_Index then

   Row_Pos_14 := Defer_Pos_29;

else
   Row_Pos_14 := No_Token_Index;
   goto Exit_Row_14_0;

end if;




--  Start tok_code

Tok_Res_22 := Row_Pos_14;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_22));
begin
   if
      T.Kind /= GPR_Dot
   then
       Tok_Pos_22 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_14 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_14,
             Expected_Token_Id => GPR_Dot,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_22 := Row_Pos_14 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_22 /= No_Token_Index then

   Row_Pos_14 := Tok_Pos_22;

else
   Row_Pos_14 := No_Token_Index;
   goto Exit_Row_14_0;

end if;




Defer_Res_30 := Identifier_Transform_Parse_0(Parser, Row_Pos_14);
Defer_Pos_30 := Parser.Current_Pos;


if Defer_Pos_30 /= No_Token_Index then

   Row_Pos_14 := Defer_Pos_30;

else
   Row_Pos_14 := No_Token_Index;
   goto Exit_Row_14_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_14_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_14 /= No_Token_Index then

   Transform_Res_15 := Package_Extension
     (Package_Extension_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_15.Unit := Parser.Unit;
   Transform_Res_15.Token_Start_Index := Pos;
   Transform_Res_15.Token_End_Index :=
     (if Row_Pos_14 = Pos
      then No_Token_Index
      else Row_Pos_14 - 1);

      Transform_Res_15.F_Prj_Name :=
            Identifier (Defer_Res_29);
      Transform_Res_15.F_Pkg_Name :=
            Identifier (Defer_Res_30);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Package_Extension_Transform_Parse_0_Memo,
        Row_Pos_14 /= No_Token_Index,
        Transform_Res_15,
        Pos,
        Row_Pos_14);


   Parser.Current_Pos := Row_Pos_14;

   return Transform_Res_15;
end Package_Extension_Transform_Parse_0;

   


function Variable_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Variable_Decl
is
      Row_Pos_16 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_36 :
            Token_Index
               := No_Token_Index;
      Defer_Res_36 :
            Identifier
               := null;
      Row_Pos_17 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_24 :
            Token_Index
               := No_Token_Index;
      Tok_Res_24 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_37 :
            Token_Index
               := No_Token_Index;
      Defer_Res_37 :
            Expr
               := null;
      Tok_Pos_25 :
            Token_Index
               := No_Token_Index;
      Tok_Res_25 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_38 :
            Token_Index
               := No_Token_Index;
      Defer_Res_38 :
            Term_List
               := null;
      Transform_Res_16 :
            Variable_Decl
               := null;


   M : Variable_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Variable_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_16 := M.Instance;
      return Transform_Res_16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_16;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_16 := Pos;





Defer_Res_36 := Identifier_Transform_Parse_0(Parser, Row_Pos_16);
Defer_Pos_36 := Parser.Current_Pos;


if Defer_Pos_36 /= No_Token_Index then

   Row_Pos_16 := Defer_Pos_36;

else
   Row_Pos_16 := No_Token_Index;
   goto Exit_Row_16_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_17 := Row_Pos_16;





--  Start tok_code

Tok_Res_24 := Row_Pos_17;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_24));
begin
   if
      T.Kind /= GPR_Colon
   then
       Tok_Pos_24 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_17 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_17,
             Expected_Token_Id => GPR_Colon,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_24 := Row_Pos_17 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_24 /= No_Token_Index then

   Row_Pos_17 := Tok_Pos_24;

else
   Row_Pos_17 := No_Token_Index;
   goto Exit_Row_17_0;

end if;




Defer_Res_37 := Static_Name_Or_Parse_0(Parser, Row_Pos_17);
Defer_Pos_37 := Parser.Current_Pos;


if Defer_Pos_37 /= No_Token_Index then

   Row_Pos_17 := Defer_Pos_37;

else
   Row_Pos_17 := No_Token_Index;
   goto Exit_Row_17_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_17_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_17 = No_Token_Index then
        Defer_Res_37 :=
           null;


    Row_Pos_17 := Row_Pos_16;


end if;

--  End opt_code


if Row_Pos_17 /= No_Token_Index then

   Row_Pos_16 := Row_Pos_17;

else
   Row_Pos_16 := No_Token_Index;
   goto Exit_Row_16_0;

end if;




--  Start tok_code

Tok_Res_25 := Row_Pos_16;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_25));
begin
   if
      T.Kind /= GPR_Assign
   then
       Tok_Pos_25 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_16 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_16,
             Expected_Token_Id => GPR_Assign,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_25 := Row_Pos_16 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_25 /= No_Token_Index then

   Row_Pos_16 := Tok_Pos_25;

else
   Row_Pos_16 := No_Token_Index;
   goto Exit_Row_16_0;

end if;




Defer_Res_38 := Expression_Transform_Parse_0(Parser, Row_Pos_16);
Defer_Pos_38 := Parser.Current_Pos;


if Defer_Pos_38 /= No_Token_Index then

   Row_Pos_16 := Defer_Pos_38;

else
   Row_Pos_16 := No_Token_Index;
   goto Exit_Row_16_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_16_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_16 /= No_Token_Index then

   Transform_Res_16 := Variable_Decl
     (Variable_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_16.Unit := Parser.Unit;
   Transform_Res_16.Token_Start_Index := Pos;
   Transform_Res_16.Token_End_Index :=
     (if Row_Pos_16 = Pos
      then No_Token_Index
      else Row_Pos_16 - 1);

      Transform_Res_16.F_Var_Name :=
            Identifier (Defer_Res_36);
      Transform_Res_16.F_Var_Type :=
            Expr (Defer_Res_37);
      Transform_Res_16.F_Expr :=
            Term_List (Defer_Res_38);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Variable_Decl_Transform_Parse_0_Memo,
        Row_Pos_16 /= No_Token_Index,
        Transform_Res_16,
        Pos,
        Row_Pos_16);


   Parser.Current_Pos := Row_Pos_16;

   return Transform_Res_16;
end Variable_Decl_Transform_Parse_0;

   


function Associative_Array_Index_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node
is
      Defer_Pos_42 :
            Token_Index
               := No_Token_Index;
      Defer_Res_42 :
            Others_Designator
               := null;
      Defer_Pos_43 :
            Token_Index
               := No_Token_Index;
      Defer_Res_43 :
            String_Literal_At
               := null;
      Or_Pos_5 :
            Token_Index
               := No_Token_Index;
      Or_Res_5 :
            GPR_Node
               := null;


   M : GPR_Node_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Associative_Array_Index_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_5 := M.Instance;
      return Or_Res_5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_5 := No_Token_Index;
Or_Res_5 := null;
    
Defer_Res_42 := Others_Designator_Transform_Parse_0(Parser, Pos);
Defer_Pos_42 := Parser.Current_Pos;

    if Defer_Pos_42 /= No_Token_Index then
        Or_Pos_5 := Defer_Pos_42;
        Or_Res_5 := GPR_Node
          (Defer_Res_42);
        goto Exit_Or_5;
    end if;
    
Defer_Res_43 := String_Literal_At_Transform_Parse_0(Parser, Pos);
Defer_Pos_43 := Parser.Current_Pos;

    if Defer_Pos_43 /= No_Token_Index then
        Or_Pos_5 := Defer_Pos_43;
        Or_Res_5 := GPR_Node
          (Defer_Res_43);
        goto Exit_Or_5;
    end if;
<<Exit_Or_5>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Associative_Array_Index_Or_Parse_0_Memo,
        Or_Pos_5 /= No_Token_Index,
        Or_Res_5,
        Pos,
        Or_Pos_5);


   Parser.Current_Pos := Or_Pos_5;

   return Or_Res_5;
end Associative_Array_Index_Or_Parse_0;

   


function Attribute_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Attribute_Decl
is
      Row_Pos_18 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_26 :
            Token_Index
               := No_Token_Index;
      Tok_Res_26 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_39 :
            Token_Index
               := No_Token_Index;
      Defer_Res_39 :
            Identifier
               := null;
      Row_Pos_19 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_27 :
            Token_Index
               := No_Token_Index;
      Tok_Res_27 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_40 :
            Token_Index
               := No_Token_Index;
      Defer_Res_40 :
            GPR_Node
               := null;
      Tok_Pos_28 :
            Token_Index
               := No_Token_Index;
      Tok_Res_28 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_29 :
            Token_Index
               := No_Token_Index;
      Tok_Res_29 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_41 :
            Token_Index
               := No_Token_Index;
      Defer_Res_41 :
            Term_List
               := null;
      Transform_Res_17 :
            Attribute_Decl
               := null;


   M : Attribute_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Attribute_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_17 := M.Instance;
      return Transform_Res_17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_17;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_18 := Pos;





--  Start tok_code

Tok_Res_26 := Row_Pos_18;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_26));
begin
   if
      T.Kind /= GPR_For
   then
       Tok_Pos_26 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_18 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_18,
             Expected_Token_Id => GPR_For,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_26 := Row_Pos_18 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_26 /= No_Token_Index then

   Row_Pos_18 := Tok_Pos_26;

else
   Row_Pos_18 := No_Token_Index;
   goto Exit_Row_18_0;

end if;




Defer_Res_39 := Identifier_Transform_Parse_0(Parser, Row_Pos_18);
Defer_Pos_39 := Parser.Current_Pos;


if Defer_Pos_39 /= No_Token_Index then

   Row_Pos_18 := Defer_Pos_39;

else
   Row_Pos_18 := No_Token_Index;
   goto Exit_Row_18_0;

end if;




--  Start opt_code


--  Start row_code

Row_Pos_19 := Row_Pos_18;





--  Start tok_code

Tok_Res_27 := Row_Pos_19;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_27));
begin
   if
      T.Kind /= GPR_Par_Open
   then
       Tok_Pos_27 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_19,
             Expected_Token_Id => GPR_Par_Open,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_27 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_27 /= No_Token_Index then

   Row_Pos_19 := Tok_Pos_27;

else
   Row_Pos_19 := No_Token_Index;
   goto Exit_Row_19_0;

end if;




Defer_Res_40 := Associative_Array_Index_Or_Parse_0(Parser, Row_Pos_19);
Defer_Pos_40 := Parser.Current_Pos;


if Defer_Pos_40 /= No_Token_Index then

   Row_Pos_19 := Defer_Pos_40;

else
   Row_Pos_19 := No_Token_Index;
   goto Exit_Row_19_0;

end if;




--  Start tok_code

Tok_Res_28 := Row_Pos_19;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_28));
begin
   if
      T.Kind /= GPR_Par_Close
   then
       Tok_Pos_28 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_19 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_19,
             Expected_Token_Id => GPR_Par_Close,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_28 := Row_Pos_19 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_28 /= No_Token_Index then

   Row_Pos_19 := Tok_Pos_28;

else
   Row_Pos_19 := No_Token_Index;
   goto Exit_Row_19_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_19_0>>
pragma Warnings (On, "referenced");

--  End row_code




if Row_Pos_19 = No_Token_Index then
        Defer_Res_40 :=
           null;


    Row_Pos_19 := Row_Pos_18;


end if;

--  End opt_code


if Row_Pos_19 /= No_Token_Index then

   Row_Pos_18 := Row_Pos_19;

else
   Row_Pos_18 := No_Token_Index;
   goto Exit_Row_18_0;

end if;




--  Start tok_code

Tok_Res_29 := Row_Pos_18;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_29));
begin
   if
      T.Kind /= GPR_Use
   then
       Tok_Pos_29 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_18 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_18,
             Expected_Token_Id => GPR_Use,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_29 := Row_Pos_18 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_29 /= No_Token_Index then

   Row_Pos_18 := Tok_Pos_29;

else
   Row_Pos_18 := No_Token_Index;
   goto Exit_Row_18_0;

end if;




Defer_Res_41 := Expression_Transform_Parse_0(Parser, Row_Pos_18);
Defer_Pos_41 := Parser.Current_Pos;


if Defer_Pos_41 /= No_Token_Index then

   Row_Pos_18 := Defer_Pos_41;

else
   Row_Pos_18 := No_Token_Index;
   goto Exit_Row_18_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_18_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_18 /= No_Token_Index then

   Transform_Res_17 := Attribute_Decl
     (Attribute_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_17.Unit := Parser.Unit;
   Transform_Res_17.Token_Start_Index := Pos;
   Transform_Res_17.Token_End_Index :=
     (if Row_Pos_18 = Pos
      then No_Token_Index
      else Row_Pos_18 - 1);

      Transform_Res_17.F_Attr_Name :=
            Identifier (Defer_Res_39);
      Transform_Res_17.F_Attr_Index :=
            GPR_Node (Defer_Res_40);
      Transform_Res_17.F_Expr :=
            Term_List (Defer_Res_41);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Attribute_Decl_Transform_Parse_0_Memo,
        Row_Pos_18 /= No_Token_Index,
        Transform_Res_17,
        Pos,
        Row_Pos_18);


   Parser.Current_Pos := Row_Pos_18;

   return Transform_Res_17;
end Attribute_Decl_Transform_Parse_0;

   


function Choice_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node
is
      Defer_Pos_49 :
            Token_Index
               := No_Token_Index;
      Defer_Res_49 :
            String_Literal
               := null;
      Defer_Pos_50 :
            Token_Index
               := No_Token_Index;
      Defer_Res_50 :
            Others_Designator
               := null;
      Or_Pos_6 :
            Token_Index
               := No_Token_Index;
      Or_Res_6 :
            GPR_Node
               := null;


   M : GPR_Node_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Choice_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_6 := M.Instance;
      return Or_Res_6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_6 := No_Token_Index;
Or_Res_6 := null;
    
Defer_Res_49 := String_Literal_Transform_Parse_0(Parser, Pos);
Defer_Pos_49 := Parser.Current_Pos;

    if Defer_Pos_49 /= No_Token_Index then
        Or_Pos_6 := Defer_Pos_49;
        Or_Res_6 := GPR_Node
          (Defer_Res_49);
        goto Exit_Or_6;
    end if;
    
Defer_Res_50 := Others_Designator_Transform_Parse_0(Parser, Pos);
Defer_Pos_50 := Parser.Current_Pos;

    if Defer_Pos_50 /= No_Token_Index then
        Or_Pos_6 := Defer_Pos_50;
        Or_Res_6 := GPR_Node
          (Defer_Res_50);
        goto Exit_Or_6;
    end if;
<<Exit_Or_6>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Choice_Or_Parse_0_Memo,
        Or_Pos_6 /= No_Token_Index,
        Or_Res_6,
        Pos,
        Or_Pos_6);


   Parser.Current_Pos := Or_Pos_6;

   return Or_Res_6;
end Choice_Or_Parse_0;

   


function Discrete_Choice_List_List_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node_List
is
      Lst_Cpos_4 :
            Token_Index
               := No_Token_Index;
      Tmp_List_4 :
            Free_Parse_List;
      Defer_Pos_48 :
            Token_Index
               := No_Token_Index;
      Defer_Res_48 :
            GPR_Node
               := null;
      Tok_Pos_36 :
            Token_Index
               := No_Token_Index;
      Tok_Res_36 :
            Token_Index
               := No_Token_Index;
      List_Pos_4 :
            Token_Index
               := No_Token_Index;
      List_Res_4 :
            GPR_Node_List
               := null;


   M : GPR_Node_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Discrete_Choice_List_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res_4 := M.Instance;
      return List_Res_4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res_4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos_4 := No_Token_Index;



Lst_Cpos_4 := Pos;
Tmp_List_4 := Get_Parse_List (Parser);

loop
   
Defer_Res_48 := Choice_Or_Parse_0(Parser, Lst_Cpos_4);
Defer_Pos_48 := Parser.Current_Pos;


   exit when Defer_Pos_48 = No_Token_Index;

   List_Pos_4 := Defer_Pos_48;
   Lst_Cpos_4 := List_Pos_4;

   Tmp_List_4.Nodes.Append
     (GPR_Node (Defer_Res_48));

      
--  Start tok_code

Tok_Res_36 := Lst_Cpos_4;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_36));
begin
   if
      T.Kind /= GPR_Pipe
   then
       Tok_Pos_36 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_4 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Lst_Cpos_4,
             Expected_Token_Id => GPR_Pipe,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_36 := Lst_Cpos_4 + 1;
   end if;
end;

--  End tok_code

      if Tok_Pos_36 /= No_Token_Index then
          Lst_Cpos_4 := Tok_Pos_36;
      else
         exit;
      end if;

end loop;

List_Res_4 := GPR_Node_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_4.Unit := Parser.Unit;
List_Res_4.Count := Tmp_List_4.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_4.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_4.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_4.Count > 0 then
   List_Res_4.Token_Start_Index := Pos;
   List_Res_4.Token_End_Index :=
     (if Lst_Cpos_4 = Pos
      then Pos else Lst_Cpos_4 - 1);

else
   List_Res_4.Token_Start_Index :=
      Token_Index'Max (Pos, 1);
   List_Res_4.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_4);


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Discrete_Choice_List_List_Parse_0_Memo,
        List_Pos_4 /= No_Token_Index,
        List_Res_4,
        Pos,
        List_Pos_4);


   Parser.Current_Pos := List_Pos_4;

   return List_Res_4;
end Discrete_Choice_List_List_Parse_0;

   


function Case_Item_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Case_Item
is
      Row_Pos_21 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_34 :
            Token_Index
               := No_Token_Index;
      Tok_Res_34 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_46 :
            Token_Index
               := No_Token_Index;
      Defer_Res_46 :
            GPR_Node_List
               := null;
      Tok_Pos_35 :
            Token_Index
               := No_Token_Index;
      Tok_Res_35 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_47 :
            Token_Index
               := No_Token_Index;
      Defer_Res_47 :
            GPR_Node_List
               := null;
      Transform_Res_19 :
            Case_Item
               := null;


   M : Case_Item_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Case_Item_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_19 := M.Instance;
      return Transform_Res_19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_21 := Pos;





--  Start tok_code

Tok_Res_34 := Row_Pos_21;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_34));
begin
   if
      T.Kind /= GPR_When
   then
       Tok_Pos_34 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_21 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_21,
             Expected_Token_Id => GPR_When,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_34 := Row_Pos_21 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_34 /= No_Token_Index then

   Row_Pos_21 := Tok_Pos_34;

else
   Row_Pos_21 := No_Token_Index;
   goto Exit_Row_21_0;

end if;




Defer_Res_46 := Discrete_Choice_List_List_Parse_0(Parser, Row_Pos_21);
Defer_Pos_46 := Parser.Current_Pos;


if Defer_Pos_46 /= No_Token_Index then

   Row_Pos_21 := Defer_Pos_46;

else
   Row_Pos_21 := No_Token_Index;
   goto Exit_Row_21_0;

end if;




--  Start tok_code

Tok_Res_35 := Row_Pos_21;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_35));
begin
   if
      T.Kind /= GPR_Arrow
   then
       Tok_Pos_35 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_21 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_21,
             Expected_Token_Id => GPR_Arrow,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_35 := Row_Pos_21 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_35 /= No_Token_Index then

   Row_Pos_21 := Tok_Pos_35;

else
   Row_Pos_21 := No_Token_Index;
   goto Exit_Row_21_0;

end if;




Defer_Res_47 := Simple_Declarative_Items_List_Parse_0(Parser, Row_Pos_21);
Defer_Pos_47 := Parser.Current_Pos;


if Defer_Pos_47 /= No_Token_Index then

   Row_Pos_21 := Defer_Pos_47;

else
   Row_Pos_21 := No_Token_Index;
   goto Exit_Row_21_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_21_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_21 /= No_Token_Index then

   Transform_Res_19 := Case_Item
     (Case_Item_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_19.Unit := Parser.Unit;
   Transform_Res_19.Token_Start_Index := Pos;
   Transform_Res_19.Token_End_Index :=
     (if Row_Pos_21 = Pos
      then No_Token_Index
      else Row_Pos_21 - 1);

      Transform_Res_19.F_Choice :=
            GPR_Node_List (Defer_Res_46);
      Transform_Res_19.F_Decls :=
            GPR_Node_List (Defer_Res_47);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Case_Item_Transform_Parse_0_Memo,
        Row_Pos_21 /= No_Token_Index,
        Transform_Res_19,
        Pos,
        Row_Pos_21);


   Parser.Current_Pos := Row_Pos_21;

   return Transform_Res_19;
end Case_Item_Transform_Parse_0;

   


function Case_Construction_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Case_Construction
is
      Row_Pos_20 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_30 :
            Token_Index
               := No_Token_Index;
      Tok_Res_30 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_44 :
            Token_Index
               := No_Token_Index;
      Defer_Res_44 :
            Variable_Reference
               := null;
      Tok_Pos_31 :
            Token_Index
               := No_Token_Index;
      Tok_Res_31 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos_3 :
            Token_Index
               := No_Token_Index;
      Tmp_List_3 :
            Free_Parse_List;
      Defer_Pos_45 :
            Token_Index
               := No_Token_Index;
      Defer_Res_45 :
            Case_Item
               := null;
      List_Pos_3 :
            Token_Index
               := No_Token_Index;
      List_Res_3 :
            Case_Item_List
               := null;
      Tok_Pos_32 :
            Token_Index
               := No_Token_Index;
      Tok_Res_32 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_33 :
            Token_Index
               := No_Token_Index;
      Tok_Res_33 :
            Token_Index
               := No_Token_Index;
      Transform_Res_18 :
            Case_Construction
               := null;


   M : Case_Construction_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Case_Construction_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_18 := M.Instance;
      return Transform_Res_18;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_18;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_20 := Pos;





--  Start tok_code

Tok_Res_30 := Row_Pos_20;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_30));
begin
   if
      T.Kind /= GPR_Case
   then
       Tok_Pos_30 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_20,
             Expected_Token_Id => GPR_Case,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_30 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_30 /= No_Token_Index then

   Row_Pos_20 := Tok_Pos_30;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;




Defer_Res_44 := Variable_Reference_Transform_Parse_0(Parser, Row_Pos_20);
Defer_Pos_44 := Parser.Current_Pos;


if Defer_Pos_44 /= No_Token_Index then

   Row_Pos_20 := Defer_Pos_44;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;




--  Start tok_code

Tok_Res_31 := Row_Pos_20;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_31));
begin
   if
      T.Kind /= GPR_Is
   then
       Tok_Pos_31 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_20,
             Expected_Token_Id => GPR_Is,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_31 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_31 /= No_Token_Index then

   Row_Pos_20 := Tok_Pos_31;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;




--  Start list_code

    List_Pos_3 := Row_Pos_20;



Lst_Cpos_3 := Row_Pos_20;
Tmp_List_3 := Get_Parse_List (Parser);

loop
   
Defer_Res_45 := Case_Item_Transform_Parse_0(Parser, Lst_Cpos_3);
Defer_Pos_45 := Parser.Current_Pos;


   exit when Defer_Pos_45 = No_Token_Index;

   List_Pos_3 := Defer_Pos_45;
   Lst_Cpos_3 := List_Pos_3;

   Tmp_List_3.Nodes.Append
     (GPR_Node (Defer_Res_45));


end loop;

List_Res_3 := Case_Item_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_3.Unit := Parser.Unit;
List_Res_3.Count := Tmp_List_3.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_3.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_3.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_3.Count > 0 then
   List_Res_3.Token_Start_Index := Row_Pos_20;
   List_Res_3.Token_End_Index :=
     (if Lst_Cpos_3 = Row_Pos_20
      then Row_Pos_20 else Lst_Cpos_3 - 1);

else
   List_Res_3.Token_Start_Index :=
      Token_Index'Max (Row_Pos_20, 1);
   List_Res_3.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_3);


--  End list_code


if List_Pos_3 /= No_Token_Index then

   Row_Pos_20 := List_Pos_3;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;




--  Start tok_code

Tok_Res_32 := Row_Pos_20;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_32));
begin
   if
      T.Kind /= GPR_End
   then
       Tok_Pos_32 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_20,
             Expected_Token_Id => GPR_End,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_32 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_32 /= No_Token_Index then

   Row_Pos_20 := Tok_Pos_32;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;




--  Start tok_code

Tok_Res_33 := Row_Pos_20;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_33));
begin
   if
      T.Kind /= GPR_Case
   then
       Tok_Pos_33 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_20 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_20,
             Expected_Token_Id => GPR_Case,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_33 := Row_Pos_20 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_33 /= No_Token_Index then

   Row_Pos_20 := Tok_Pos_33;

else
   Row_Pos_20 := No_Token_Index;
   goto Exit_Row_20_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_20_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_20 /= No_Token_Index then

   Transform_Res_18 := Case_Construction
     (Case_Construction_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_18.Unit := Parser.Unit;
   Transform_Res_18.Token_Start_Index := Pos;
   Transform_Res_18.Token_End_Index :=
     (if Row_Pos_20 = Pos
      then No_Token_Index
      else Row_Pos_20 - 1);

      Transform_Res_18.F_Var_Ref :=
            Variable_Reference (Defer_Res_44);
      Transform_Res_18.F_Items :=
            Case_Item_List (List_Res_3);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Case_Construction_Transform_Parse_0_Memo,
        Row_Pos_20 /= No_Token_Index,
        Transform_Res_18,
        Pos,
        Row_Pos_20);


   Parser.Current_Pos := Row_Pos_20;

   return Transform_Res_18;
end Case_Construction_Transform_Parse_0;

   


function Empty_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Empty_Decl
is
      Row_Pos_22 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_37 :
            Token_Index
               := No_Token_Index;
      Tok_Res_37 :
            Token_Index
               := No_Token_Index;
      Transform_Res_20 :
            Empty_Decl
               := null;


   M : Empty_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Empty_Declaration_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_20 := M.Instance;
      return Transform_Res_20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_20;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_22 := Pos;





--  Start tok_code

Tok_Res_37 := Row_Pos_22;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_37));
begin
   if
      T.Kind /= GPR_Null
   then
       Tok_Pos_37 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_22 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_22,
             Expected_Token_Id => GPR_Null,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_37 := Row_Pos_22 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_37 /= No_Token_Index then

   Row_Pos_22 := Tok_Pos_37;

else
   Row_Pos_22 := No_Token_Index;
   goto Exit_Row_22_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_22_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_22 /= No_Token_Index then

   Transform_Res_20 := Empty_Decl
     (Empty_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_20.Unit := Parser.Unit;
   Transform_Res_20.Token_Start_Index := Pos;
   Transform_Res_20.Token_End_Index :=
     (if Row_Pos_22 = Pos
      then No_Token_Index
      else Row_Pos_22 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Empty_Declaration_Transform_Parse_0_Memo,
        Row_Pos_22 /= No_Token_Index,
        Transform_Res_20,
        Pos,
        Row_Pos_22);


   Parser.Current_Pos := Row_Pos_22;

   return Transform_Res_20;
end Empty_Declaration_Transform_Parse_0;

   


function Simple_Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node
is
      Defer_Pos_32 :
            Token_Index
               := No_Token_Index;
      Defer_Res_32 :
            Variable_Decl
               := null;
      Defer_Pos_33 :
            Token_Index
               := No_Token_Index;
      Defer_Res_33 :
            Attribute_Decl
               := null;
      Defer_Pos_34 :
            Token_Index
               := No_Token_Index;
      Defer_Res_34 :
            Case_Construction
               := null;
      Defer_Pos_35 :
            Token_Index
               := No_Token_Index;
      Defer_Res_35 :
            Empty_Decl
               := null;
      Or_Pos_4 :
            Token_Index
               := No_Token_Index;
      Or_Res_4 :
            GPR_Node
               := null;


   M : GPR_Node_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Simple_Declarative_Item_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_4 := M.Instance;
      return Or_Res_4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_4 := No_Token_Index;
Or_Res_4 := null;
    
Defer_Res_32 := Variable_Decl_Transform_Parse_0(Parser, Pos);
Defer_Pos_32 := Parser.Current_Pos;

    if Defer_Pos_32 /= No_Token_Index then
        Or_Pos_4 := Defer_Pos_32;
        Or_Res_4 := GPR_Node
          (Defer_Res_32);
        goto Exit_Or_4;
    end if;
    
Defer_Res_33 := Attribute_Decl_Transform_Parse_0(Parser, Pos);
Defer_Pos_33 := Parser.Current_Pos;

    if Defer_Pos_33 /= No_Token_Index then
        Or_Pos_4 := Defer_Pos_33;
        Or_Res_4 := GPR_Node
          (Defer_Res_33);
        goto Exit_Or_4;
    end if;
    
Defer_Res_34 := Case_Construction_Transform_Parse_0(Parser, Pos);
Defer_Pos_34 := Parser.Current_Pos;

    if Defer_Pos_34 /= No_Token_Index then
        Or_Pos_4 := Defer_Pos_34;
        Or_Res_4 := GPR_Node
          (Defer_Res_34);
        goto Exit_Or_4;
    end if;
    
Defer_Res_35 := Empty_Declaration_Transform_Parse_0(Parser, Pos);
Defer_Pos_35 := Parser.Current_Pos;

    if Defer_Pos_35 /= No_Token_Index then
        Or_Pos_4 := Defer_Pos_35;
        Or_Res_4 := GPR_Node
          (Defer_Res_35);
        goto Exit_Or_4;
    end if;
<<Exit_Or_4>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Simple_Declarative_Item_Or_Parse_0_Memo,
        Or_Pos_4 /= No_Token_Index,
        Or_Res_4,
        Pos,
        Or_Pos_4);


   Parser.Current_Pos := Or_Pos_4;

   return Or_Res_4;
end Simple_Declarative_Item_Or_Parse_0;

   


function Simple_Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node_List
is
      Lst_Cpos_2 :
            Token_Index
               := No_Token_Index;
      Tmp_List_2 :
            Free_Parse_List;
      Row_Pos_15 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_31 :
            Token_Index
               := No_Token_Index;
      Defer_Res_31 :
            GPR_Node
               := null;
      Tok_Pos_23 :
            Token_Index
               := No_Token_Index;
      Tok_Res_23 :
            Token_Index
               := No_Token_Index;
      List_Pos_2 :
            Token_Index
               := No_Token_Index;
      List_Res_2 :
            GPR_Node_List
               := null;


   M : GPR_Node_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Simple_Declarative_Items_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res_2 := M.Instance;
      return List_Res_2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res_2;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos_2 := Pos;



Lst_Cpos_2 := Pos;
Tmp_List_2 := Get_Parse_List (Parser);

loop
   
--  Start row_code

Row_Pos_15 := Lst_Cpos_2;





Defer_Res_31 := Simple_Declarative_Item_Or_Parse_0(Parser, Row_Pos_15);
Defer_Pos_31 := Parser.Current_Pos;


if Defer_Pos_31 /= No_Token_Index then

   Row_Pos_15 := Defer_Pos_31;

else
   Row_Pos_15 := No_Token_Index;
   goto Exit_Row_15_0;

end if;




--  Start tok_code

Tok_Res_23 := Row_Pos_15;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_23));
begin
   if
      T.Kind /= GPR_Semicolon
   then
       Tok_Pos_23 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_15 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_15,
             Expected_Token_Id => GPR_Semicolon,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_23 := Row_Pos_15 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_23 /= No_Token_Index then

   Row_Pos_15 := Tok_Pos_23;

else
   Row_Pos_15 := No_Token_Index;
   goto Exit_Row_15_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_15_0>>
pragma Warnings (On, "referenced");

--  End row_code


   exit when Row_Pos_15 = No_Token_Index;

   List_Pos_2 := Row_Pos_15;
   Lst_Cpos_2 := List_Pos_2;

   Tmp_List_2.Nodes.Append
     (GPR_Node (Defer_Res_31));


end loop;

List_Res_2 := GPR_Node_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_2.Unit := Parser.Unit;
List_Res_2.Count := Tmp_List_2.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_2.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_2.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_2.Count > 0 then
   List_Res_2.Token_Start_Index := Pos;
   List_Res_2.Token_End_Index :=
     (if Lst_Cpos_2 = Pos
      then Pos else Lst_Cpos_2 - 1);

else
   List_Res_2.Token_Start_Index :=
      Token_Index'Max (Pos, 1);
   List_Res_2.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_2);


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Simple_Declarative_Items_List_Parse_0_Memo,
        List_Pos_2 /= No_Token_Index,
        List_Res_2,
        Pos,
        List_Pos_2);


   Parser.Current_Pos := List_Pos_2;

   return List_Res_2;
end Simple_Declarative_Items_List_Parse_0;

   


function Package_Spec_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Package_Spec
is
      Row_Pos_13 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_26 :
            Token_Index
               := No_Token_Index;
      Defer_Res_26 :
            Package_Extension
               := null;
      Tok_Pos_19 :
            Token_Index
               := No_Token_Index;
      Tok_Res_19 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_27 :
            Token_Index
               := No_Token_Index;
      Defer_Res_27 :
            GPR_Node_List
               := null;
      Tok_Pos_20 :
            Token_Index
               := No_Token_Index;
      Tok_Res_20 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_28 :
            Token_Index
               := No_Token_Index;
      Defer_Res_28 :
            Identifier
               := null;
      Transform_Res_14 :
            Package_Spec
               := null;


   M : Package_Spec_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Package_Spec_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_14 := M.Instance;
      return Transform_Res_14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_14;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_13 := Pos;





--  Start opt_code


Defer_Res_26 := Package_Extension_Transform_Parse_0(Parser, Row_Pos_13);
Defer_Pos_26 := Parser.Current_Pos;




if Defer_Pos_26 = No_Token_Index then
        Defer_Res_26 :=
           null;


    Defer_Pos_26 := Row_Pos_13;


end if;

--  End opt_code


if Defer_Pos_26 /= No_Token_Index then

   Row_Pos_13 := Defer_Pos_26;

else
   Row_Pos_13 := No_Token_Index;
   goto Exit_Row_13_0;

end if;




--  Start tok_code

Tok_Res_19 := Row_Pos_13;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_19));
begin
   if
      T.Kind /= GPR_Is
   then
       Tok_Pos_19 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_13 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_13,
             Expected_Token_Id => GPR_Is,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_19 := Row_Pos_13 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_19 /= No_Token_Index then

   Row_Pos_13 := Tok_Pos_19;

else
   Row_Pos_13 := No_Token_Index;
   goto Exit_Row_13_0;

end if;




Defer_Res_27 := Simple_Declarative_Items_List_Parse_0(Parser, Row_Pos_13);
Defer_Pos_27 := Parser.Current_Pos;


if Defer_Pos_27 /= No_Token_Index then

   Row_Pos_13 := Defer_Pos_27;

else
   Row_Pos_13 := No_Token_Index;
   goto Exit_Row_13_0;

end if;




--  Start tok_code

Tok_Res_20 := Row_Pos_13;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_20));
begin
   if
      T.Kind /= GPR_End
   then
       Tok_Pos_20 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_13 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_13,
             Expected_Token_Id => GPR_End,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_20 := Row_Pos_13 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_20 /= No_Token_Index then

   Row_Pos_13 := Tok_Pos_20;

else
   Row_Pos_13 := No_Token_Index;
   goto Exit_Row_13_0;

end if;




Defer_Res_28 := Identifier_Transform_Parse_0(Parser, Row_Pos_13);
Defer_Pos_28 := Parser.Current_Pos;


if Defer_Pos_28 /= No_Token_Index then

   Row_Pos_13 := Defer_Pos_28;

else
   Row_Pos_13 := No_Token_Index;
   goto Exit_Row_13_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_13_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_13 /= No_Token_Index then

   Transform_Res_14 := Package_Spec
     (Package_Spec_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_14.Unit := Parser.Unit;
   Transform_Res_14.Token_Start_Index := Pos;
   Transform_Res_14.Token_End_Index :=
     (if Row_Pos_13 = Pos
      then No_Token_Index
      else Row_Pos_13 - 1);

      Transform_Res_14.F_Extension :=
            Package_Extension (Defer_Res_26);
      Transform_Res_14.F_Decls :=
            GPR_Node_List (Defer_Res_27);
      Transform_Res_14.F_End_Name :=
            Identifier (Defer_Res_28);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Package_Spec_Transform_Parse_0_Memo,
        Row_Pos_13 /= No_Token_Index,
        Transform_Res_14,
        Pos,
        Row_Pos_13);


   Parser.Current_Pos := Row_Pos_13;

   return Transform_Res_14;
end Package_Spec_Transform_Parse_0;

   


function Package_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Package_Decl
is
      Row_Pos_12 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_18 :
            Token_Index
               := No_Token_Index;
      Tok_Res_18 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_23 :
            Token_Index
               := No_Token_Index;
      Defer_Res_23 :
            Identifier
               := null;
      Defer_Pos_24 :
            Token_Index
               := No_Token_Index;
      Defer_Res_24 :
            Package_Renaming
               := null;
      Defer_Pos_25 :
            Token_Index
               := No_Token_Index;
      Defer_Res_25 :
            Package_Spec
               := null;
      Or_Pos_3 :
            Token_Index
               := No_Token_Index;
      Or_Res_3 :
            GPR_Node
               := null;
      Transform_Res_13 :
            Package_Decl
               := null;


   M : Package_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Package_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_13 := M.Instance;
      return Transform_Res_13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_13;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_12 := Pos;





--  Start tok_code

Tok_Res_18 := Row_Pos_12;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_18));
begin
   if
      T.Kind /= GPR_Package
   then
       Tok_Pos_18 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_12 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_12,
             Expected_Token_Id => GPR_Package,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_18 := Row_Pos_12 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_18 /= No_Token_Index then

   Row_Pos_12 := Tok_Pos_18;

else
   Row_Pos_12 := No_Token_Index;
   goto Exit_Row_12_0;

end if;




Defer_Res_23 := Identifier_Transform_Parse_0(Parser, Row_Pos_12);
Defer_Pos_23 := Parser.Current_Pos;


if Defer_Pos_23 /= No_Token_Index then

   Row_Pos_12 := Defer_Pos_23;

else
   Row_Pos_12 := No_Token_Index;
   goto Exit_Row_12_0;

end if;




--  Start or_code

Or_Pos_3 := No_Token_Index;
Or_Res_3 := null;
    
Defer_Res_24 := Package_Renaming_Transform_Parse_0(Parser, Row_Pos_12);
Defer_Pos_24 := Parser.Current_Pos;

    if Defer_Pos_24 /= No_Token_Index then
        Or_Pos_3 := Defer_Pos_24;
        Or_Res_3 := GPR_Node
          (Defer_Res_24);
        goto Exit_Or_3;
    end if;
    
Defer_Res_25 := Package_Spec_Transform_Parse_0(Parser, Row_Pos_12);
Defer_Pos_25 := Parser.Current_Pos;

    if Defer_Pos_25 /= No_Token_Index then
        Or_Pos_3 := Defer_Pos_25;
        Or_Res_3 := GPR_Node
          (Defer_Res_25);
        goto Exit_Or_3;
    end if;
<<Exit_Or_3>>

--  End or_code


if Or_Pos_3 /= No_Token_Index then

   Row_Pos_12 := Or_Pos_3;

else
   Row_Pos_12 := No_Token_Index;
   goto Exit_Row_12_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_12_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_12 /= No_Token_Index then

   Transform_Res_13 := Package_Decl
     (Package_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_13.Unit := Parser.Unit;
   Transform_Res_13.Token_Start_Index := Pos;
   Transform_Res_13.Token_End_Index :=
     (if Row_Pos_12 = Pos
      then No_Token_Index
      else Row_Pos_12 - 1);

      Transform_Res_13.F_Pkg_Name :=
            Identifier (Defer_Res_23);
      Transform_Res_13.F_Pkg_Spec :=
            GPR_Node (Or_Res_3);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Package_Decl_Transform_Parse_0_Memo,
        Row_Pos_12 /= No_Token_Index,
        Transform_Res_13,
        Pos,
        Row_Pos_12);


   Parser.Current_Pos := Row_Pos_12;

   return Transform_Res_13;
end Package_Decl_Transform_Parse_0;

   


function Typed_String_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Typed_String_Decl
is
      Row_Pos_23 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_38 :
            Token_Index
               := No_Token_Index;
      Tok_Res_38 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_54 :
            Token_Index
               := No_Token_Index;
      Defer_Res_54 :
            Identifier
               := null;
      Tok_Pos_39 :
            Token_Index
               := No_Token_Index;
      Tok_Res_39 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_40 :
            Token_Index
               := No_Token_Index;
      Tok_Res_40 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos_5 :
            Token_Index
               := No_Token_Index;
      Tmp_List_5 :
            Free_Parse_List;
      Defer_Pos_55 :
            Token_Index
               := No_Token_Index;
      Defer_Res_55 :
            String_Literal
               := null;
      Tok_Pos_41 :
            Token_Index
               := No_Token_Index;
      Tok_Res_41 :
            Token_Index
               := No_Token_Index;
      List_Pos_5 :
            Token_Index
               := No_Token_Index;
      List_Res_5 :
            String_Literal_List
               := null;
      Tok_Pos_42 :
            Token_Index
               := No_Token_Index;
      Tok_Res_42 :
            Token_Index
               := No_Token_Index;
      Transform_Res_21 :
            Typed_String_Decl
               := null;


   M : Typed_String_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Typed_String_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_21 := M.Instance;
      return Transform_Res_21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_21;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_23 := Pos;





--  Start tok_code

Tok_Res_38 := Row_Pos_23;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_38));
begin
   if
      T.Kind /= GPR_Type
   then
       Tok_Pos_38 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_23 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_23,
             Expected_Token_Id => GPR_Type,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_38 := Row_Pos_23 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_38 /= No_Token_Index then

   Row_Pos_23 := Tok_Pos_38;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;




Defer_Res_54 := Identifier_Transform_Parse_0(Parser, Row_Pos_23);
Defer_Pos_54 := Parser.Current_Pos;


if Defer_Pos_54 /= No_Token_Index then

   Row_Pos_23 := Defer_Pos_54;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;




--  Start tok_code

Tok_Res_39 := Row_Pos_23;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_39));
begin
   if
      T.Kind /= GPR_Is
   then
       Tok_Pos_39 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_23 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_23,
             Expected_Token_Id => GPR_Is,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_39 := Row_Pos_23 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_39 /= No_Token_Index then

   Row_Pos_23 := Tok_Pos_39;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;




--  Start tok_code

Tok_Res_40 := Row_Pos_23;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_40));
begin
   if
      T.Kind /= GPR_Par_Open
   then
       Tok_Pos_40 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_23 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_23,
             Expected_Token_Id => GPR_Par_Open,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_40 := Row_Pos_23 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_40 /= No_Token_Index then

   Row_Pos_23 := Tok_Pos_40;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;




--  Start list_code

    List_Pos_5 := No_Token_Index;



Lst_Cpos_5 := Row_Pos_23;
Tmp_List_5 := Get_Parse_List (Parser);

loop
   
Defer_Res_55 := String_Literal_Transform_Parse_0(Parser, Lst_Cpos_5);
Defer_Pos_55 := Parser.Current_Pos;


   exit when Defer_Pos_55 = No_Token_Index;

   List_Pos_5 := Defer_Pos_55;
   Lst_Cpos_5 := List_Pos_5;

   Tmp_List_5.Nodes.Append
     (GPR_Node (Defer_Res_55));

      
--  Start tok_code

Tok_Res_41 := Lst_Cpos_5;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_41));
begin
   if
      T.Kind /= GPR_Comma
   then
       Tok_Pos_41 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_5 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Lst_Cpos_5,
             Expected_Token_Id => GPR_Comma,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_41 := Lst_Cpos_5 + 1;
   end if;
end;

--  End tok_code

      if Tok_Pos_41 /= No_Token_Index then
          Lst_Cpos_5 := Tok_Pos_41;
      else
         exit;
      end if;

end loop;

List_Res_5 := String_Literal_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_5.Unit := Parser.Unit;
List_Res_5.Count := Tmp_List_5.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_5.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_5.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_5.Count > 0 then
   List_Res_5.Token_Start_Index := Row_Pos_23;
   List_Res_5.Token_End_Index :=
     (if Lst_Cpos_5 = Row_Pos_23
      then Row_Pos_23 else Lst_Cpos_5 - 1);

else
   List_Res_5.Token_Start_Index :=
      Token_Index'Max (Row_Pos_23, 1);
   List_Res_5.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_5);


--  End list_code


if List_Pos_5 /= No_Token_Index then

   Row_Pos_23 := List_Pos_5;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;




--  Start tok_code

Tok_Res_42 := Row_Pos_23;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_42));
begin
   if
      T.Kind /= GPR_Par_Close
   then
       Tok_Pos_42 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_23 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_23,
             Expected_Token_Id => GPR_Par_Close,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_42 := Row_Pos_23 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_42 /= No_Token_Index then

   Row_Pos_23 := Tok_Pos_42;

else
   Row_Pos_23 := No_Token_Index;
   goto Exit_Row_23_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_23_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_23 /= No_Token_Index then

   Transform_Res_21 := Typed_String_Decl
     (Typed_String_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_21.Unit := Parser.Unit;
   Transform_Res_21.Token_Start_Index := Pos;
   Transform_Res_21.Token_End_Index :=
     (if Row_Pos_23 = Pos
      then No_Token_Index
      else Row_Pos_23 - 1);

      Transform_Res_21.F_Type_Id :=
            Identifier (Defer_Res_54);
      Transform_Res_21.F_String_Literals :=
            String_Literal_List (List_Res_5);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Typed_String_Decl_Transform_Parse_0_Memo,
        Row_Pos_23 /= No_Token_Index,
        Transform_Res_21,
        Pos,
        Row_Pos_23);


   Parser.Current_Pos := Row_Pos_23;

   return Transform_Res_21;
end Typed_String_Decl_Transform_Parse_0;

   


function Declarative_Item_Or_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node
is
      Defer_Pos_51 :
            Token_Index
               := No_Token_Index;
      Defer_Res_51 :
            GPR_Node
               := null;
      Defer_Pos_52 :
            Token_Index
               := No_Token_Index;
      Defer_Res_52 :
            Typed_String_Decl
               := null;
      Defer_Pos_53 :
            Token_Index
               := No_Token_Index;
      Defer_Res_53 :
            Package_Decl
               := null;
      Or_Pos_7 :
            Token_Index
               := No_Token_Index;
      Or_Res_7 :
            GPR_Node
               := null;


   M : GPR_Node_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Declarative_Item_Or_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res_7 := M.Instance;
      return Or_Res_7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res_7;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start or_code

Or_Pos_7 := No_Token_Index;
Or_Res_7 := null;
    
Defer_Res_51 := Simple_Declarative_Item_Or_Parse_0(Parser, Pos);
Defer_Pos_51 := Parser.Current_Pos;

    if Defer_Pos_51 /= No_Token_Index then
        Or_Pos_7 := Defer_Pos_51;
        Or_Res_7 := GPR_Node
          (Defer_Res_51);
        goto Exit_Or_7;
    end if;
    
Defer_Res_52 := Typed_String_Decl_Transform_Parse_0(Parser, Pos);
Defer_Pos_52 := Parser.Current_Pos;

    if Defer_Pos_52 /= No_Token_Index then
        Or_Pos_7 := Defer_Pos_52;
        Or_Res_7 := GPR_Node
          (Defer_Res_52);
        goto Exit_Or_7;
    end if;
    
Defer_Res_53 := Package_Decl_Transform_Parse_0(Parser, Pos);
Defer_Pos_53 := Parser.Current_Pos;

    if Defer_Pos_53 /= No_Token_Index then
        Or_Pos_7 := Defer_Pos_53;
        Or_Res_7 := GPR_Node
          (Defer_Res_53);
        goto Exit_Or_7;
    end if;
<<Exit_Or_7>>

--  End or_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Declarative_Item_Or_Parse_0_Memo,
        Or_Pos_7 /= No_Token_Index,
        Or_Res_7,
        Pos,
        Or_Pos_7);


   Parser.Current_Pos := Or_Pos_7;

   return Or_Res_7;
end Declarative_Item_Or_Parse_0;

   


function With_Decl_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return With_Decl
is
      Row_Pos_25 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_44 :
            Token_Index
               := No_Token_Index;
      Tok_Res_44 :
            Token_Index
               := No_Token_Index;
      Opt_Res_0 :
            Boolean
               := false;
      Tok_Pos_45 :
            Token_Index
               := No_Token_Index;
      Tok_Res_45 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos_7 :
            Token_Index
               := No_Token_Index;
      Tmp_List_7 :
            Free_Parse_List;
      Defer_Pos_57 :
            Token_Index
               := No_Token_Index;
      Defer_Res_57 :
            String_Literal
               := null;
      Tok_Pos_46 :
            Token_Index
               := No_Token_Index;
      Tok_Res_46 :
            Token_Index
               := No_Token_Index;
      List_Pos_7 :
            Token_Index
               := No_Token_Index;
      List_Res_7 :
            String_Literal_List
               := null;
      Transform_Res_22 :
            With_Decl
               := null;


   M : With_Decl_Memos.Memo_Entry :=
     Get (Parser.Private_Part.With_Decl_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_22 := M.Instance;
      return Transform_Res_22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_22;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_25 := Pos;





--  Start opt_code


--  Start tok_code

Tok_Res_44 := Row_Pos_25;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_44));
begin
   if
      T.Kind /= GPR_Limited
   then
       Tok_Pos_44 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_25 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_25,
             Expected_Token_Id => GPR_Limited,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_44 := Row_Pos_25 + 1;
   end if;
end;

--  End tok_code




if Tok_Pos_44 = No_Token_Index then
         Opt_Res_0 := False;


    Tok_Pos_44 := Row_Pos_25;

else
      Opt_Res_0 := True;

end if;

--  End opt_code


if Tok_Pos_44 /= No_Token_Index then

   Row_Pos_25 := Tok_Pos_44;

else
   Row_Pos_25 := No_Token_Index;
   goto Exit_Row_25_0;

end if;




--  Start tok_code

Tok_Res_45 := Row_Pos_25;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_45));
begin
   if
      T.Kind /= GPR_With
   then
       Tok_Pos_45 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_25 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_25,
             Expected_Token_Id => GPR_With,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_45 := Row_Pos_25 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_45 /= No_Token_Index then

   Row_Pos_25 := Tok_Pos_45;

else
   Row_Pos_25 := No_Token_Index;
   goto Exit_Row_25_0;

end if;




--  Start list_code

    List_Pos_7 := No_Token_Index;



Lst_Cpos_7 := Row_Pos_25;
Tmp_List_7 := Get_Parse_List (Parser);

loop
   
Defer_Res_57 := String_Literal_Transform_Parse_0(Parser, Lst_Cpos_7);
Defer_Pos_57 := Parser.Current_Pos;


   exit when Defer_Pos_57 = No_Token_Index;

   List_Pos_7 := Defer_Pos_57;
   Lst_Cpos_7 := List_Pos_7;

   Tmp_List_7.Nodes.Append
     (GPR_Node (Defer_Res_57));

      
--  Start tok_code

Tok_Res_46 := Lst_Cpos_7;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_46));
begin
   if
      T.Kind /= GPR_Comma
   then
       Tok_Pos_46 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos_7 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Lst_Cpos_7,
             Expected_Token_Id => GPR_Comma,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_46 := Lst_Cpos_7 + 1;
   end if;
end;

--  End tok_code

      if Tok_Pos_46 /= No_Token_Index then
          Lst_Cpos_7 := Tok_Pos_46;
      else
         exit;
      end if;

end loop;

List_Res_7 := String_Literal_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_7.Unit := Parser.Unit;
List_Res_7.Count := Tmp_List_7.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_7.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_7.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_7.Count > 0 then
   List_Res_7.Token_Start_Index := Row_Pos_25;
   List_Res_7.Token_End_Index :=
     (if Lst_Cpos_7 = Row_Pos_25
      then Row_Pos_25 else Lst_Cpos_7 - 1);

else
   List_Res_7.Token_Start_Index :=
      Token_Index'Max (Row_Pos_25, 1);
   List_Res_7.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_7);


--  End list_code


if List_Pos_7 /= No_Token_Index then

   Row_Pos_25 := List_Pos_7;

else
   Row_Pos_25 := No_Token_Index;
   goto Exit_Row_25_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_25_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_25 /= No_Token_Index then

   Transform_Res_22 := With_Decl
     (With_Decl_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_22.Unit := Parser.Unit;
   Transform_Res_22.Token_Start_Index := Pos;
   Transform_Res_22.Token_End_Index :=
     (if Row_Pos_25 = Pos
      then No_Token_Index
      else Row_Pos_25 - 1);

      Transform_Res_22.F_Is_Limited :=
            Opt_Res_0;
      Transform_Res_22.F_Path_Names :=
            String_Literal_List (List_Res_7);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.With_Decl_Transform_Parse_0_Memo,
        Row_Pos_25 /= No_Token_Index,
        Transform_Res_22,
        Pos,
        Row_Pos_25);


   Parser.Current_Pos := Row_Pos_25;

   return Transform_Res_22;
end With_Decl_Transform_Parse_0;

   


function Context_Clauses_List_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return With_Decl_List
is
      Lst_Cpos_6 :
            Token_Index
               := No_Token_Index;
      Tmp_List_6 :
            Free_Parse_List;
      Row_Pos_24 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_56 :
            Token_Index
               := No_Token_Index;
      Defer_Res_56 :
            With_Decl
               := null;
      Tok_Pos_43 :
            Token_Index
               := No_Token_Index;
      Tok_Res_43 :
            Token_Index
               := No_Token_Index;
      List_Pos_6 :
            Token_Index
               := No_Token_Index;
      List_Res_6 :
            With_Decl_List
               := null;


   M : With_Decl_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Context_Clauses_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res_6 := M.Instance;
      return List_Res_6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res_6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos_6 := Pos;



Lst_Cpos_6 := Pos;
Tmp_List_6 := Get_Parse_List (Parser);

loop
   
--  Start row_code

Row_Pos_24 := Lst_Cpos_6;





Defer_Res_56 := With_Decl_Transform_Parse_0(Parser, Row_Pos_24);
Defer_Pos_56 := Parser.Current_Pos;


if Defer_Pos_56 /= No_Token_Index then

   Row_Pos_24 := Defer_Pos_56;

else
   Row_Pos_24 := No_Token_Index;
   goto Exit_Row_24_0;

end if;




--  Start tok_code

Tok_Res_43 := Row_Pos_24;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_43));
begin
   if
      T.Kind /= GPR_Semicolon
   then
       Tok_Pos_43 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_24 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_24,
             Expected_Token_Id => GPR_Semicolon,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_43 := Row_Pos_24 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_43 /= No_Token_Index then

   Row_Pos_24 := Tok_Pos_43;

else
   Row_Pos_24 := No_Token_Index;
   goto Exit_Row_24_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_24_0>>
pragma Warnings (On, "referenced");

--  End row_code


   exit when Row_Pos_24 = No_Token_Index;

   List_Pos_6 := Row_Pos_24;
   Lst_Cpos_6 := List_Pos_6;

   Tmp_List_6.Nodes.Append
     (GPR_Node (Defer_Res_56));


end loop;

List_Res_6 := With_Decl_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_6.Unit := Parser.Unit;
List_Res_6.Count := Tmp_List_6.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_6.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_6.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_6.Count > 0 then
   List_Res_6.Token_Start_Index := Pos;
   List_Res_6.Token_End_Index :=
     (if Lst_Cpos_6 = Pos
      then Pos else Lst_Cpos_6 - 1);

else
   List_Res_6.Token_Start_Index :=
      Token_Index'Max (Pos, 1);
   List_Res_6.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_6);


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Context_Clauses_List_Parse_0_Memo,
        List_Pos_6 /= No_Token_Index,
        List_Res_6,
        Pos,
        List_Pos_6);


   Parser.Current_Pos := List_Pos_6;

   return List_Res_6;
end Context_Clauses_List_Parse_0;

   


function Abstract_Present_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Abstract_Present
is
      Row_Pos_26 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_47 :
            Token_Index
               := No_Token_Index;
      Tok_Res_47 :
            Token_Index
               := No_Token_Index;
      Transform_Res_24 :
            Abstract_Present
               := null;


   M : Abstract_Present_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Abstract_Present_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_24 := M.Instance;
      return Transform_Res_24;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_24;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_26 := Pos;





--  Start tok_code

Tok_Res_47 := Row_Pos_26;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_47));
begin
   if
      T.Kind /= GPR_Abstract
   then
       Tok_Pos_47 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_26 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_26,
             Expected_Token_Id => GPR_Abstract,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_47 := Row_Pos_26 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_47 /= No_Token_Index then

   Row_Pos_26 := Tok_Pos_47;

else
   Row_Pos_26 := No_Token_Index;
   goto Exit_Row_26_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_26_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_26 /= No_Token_Index then

   Transform_Res_24 := Abstract_Present
     (Abstract_Present_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_24.Unit := Parser.Unit;
   Transform_Res_24.Token_Start_Index := Pos;
   Transform_Res_24.Token_End_Index :=
     (if Row_Pos_26 = Pos
      then No_Token_Index
      else Row_Pos_26 - 1);


end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Abstract_Present_Transform_Parse_0_Memo,
        Row_Pos_26 /= No_Token_Index,
        Transform_Res_24,
        Pos,
        Row_Pos_26);


   Parser.Current_Pos := Row_Pos_26;

   return Transform_Res_24;
end Abstract_Present_Transform_Parse_0;

   


function Qualifier_Names_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Qualifier_Names
is
      Row_Pos_27 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_60 :
            Token_Index
               := No_Token_Index;
      Defer_Res_60 :
            Identifier
               := null;
      Defer_Pos_61 :
            Token_Index
               := No_Token_Index;
      Defer_Res_61 :
            Identifier
               := null;
      Transform_Res_25 :
            Qualifier_Names
               := null;


   M : Qualifier_Names_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Qualifier_Names_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_25 := M.Instance;
      return Transform_Res_25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_27 := Pos;





Defer_Res_60 := Identifier_Transform_Parse_0(Parser, Row_Pos_27);
Defer_Pos_60 := Parser.Current_Pos;


if Defer_Pos_60 /= No_Token_Index then

   Row_Pos_27 := Defer_Pos_60;

else
   Row_Pos_27 := No_Token_Index;
   goto Exit_Row_27_0;

end if;




--  Start opt_code


Defer_Res_61 := Identifier_Transform_Parse_0(Parser, Row_Pos_27);
Defer_Pos_61 := Parser.Current_Pos;




if Defer_Pos_61 = No_Token_Index then
        Defer_Res_61 :=
           null;


    Defer_Pos_61 := Row_Pos_27;


end if;

--  End opt_code


if Defer_Pos_61 /= No_Token_Index then

   Row_Pos_27 := Defer_Pos_61;

else
   Row_Pos_27 := No_Token_Index;
   goto Exit_Row_27_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_27_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_27 /= No_Token_Index then

   Transform_Res_25 := Qualifier_Names
     (Qualifier_Names_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_25.Unit := Parser.Unit;
   Transform_Res_25.Token_Start_Index := Pos;
   Transform_Res_25.Token_End_Index :=
     (if Row_Pos_27 = Pos
      then No_Token_Index
      else Row_Pos_27 - 1);

      Transform_Res_25.F_Qualifier_Id1 :=
            Identifier (Defer_Res_60);
      Transform_Res_25.F_Qualifier_Id2 :=
            Identifier (Defer_Res_61);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Qualifier_Names_Transform_Parse_0_Memo,
        Row_Pos_27 /= No_Token_Index,
        Transform_Res_25,
        Pos,
        Row_Pos_27);


   Parser.Current_Pos := Row_Pos_27;

   return Transform_Res_25;
end Qualifier_Names_Transform_Parse_0;

   


function Project_Qualifier_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Project_Qualifier
is
      Defer_Pos_58 :
            Token_Index
               := No_Token_Index;
      Defer_Res_58 :
            Abstract_Present
               := null;
      Defer_Pos_59 :
            Token_Index
               := No_Token_Index;
      Defer_Res_59 :
            Qualifier_Names
               := null;
      Or_Pos_8 :
            Token_Index
               := No_Token_Index;
      Or_Res_8 :
            GPR_Node
               := null;
      Transform_Res_23 :
            Project_Qualifier
               := null;


   M : Project_Qualifier_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Project_Qualifier_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_23 := M.Instance;
      return Transform_Res_23;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_23;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start or_code

Or_Pos_8 := No_Token_Index;
Or_Res_8 := null;
    
Defer_Res_58 := Abstract_Present_Transform_Parse_0(Parser, Pos);
Defer_Pos_58 := Parser.Current_Pos;

    if Defer_Pos_58 /= No_Token_Index then
        Or_Pos_8 := Defer_Pos_58;
        Or_Res_8 := GPR_Node
          (Defer_Res_58);
        goto Exit_Or_8;
    end if;
    
Defer_Res_59 := Qualifier_Names_Transform_Parse_0(Parser, Pos);
Defer_Pos_59 := Parser.Current_Pos;

    if Defer_Pos_59 /= No_Token_Index then
        Or_Pos_8 := Defer_Pos_59;
        Or_Res_8 := GPR_Node
          (Defer_Res_59);
        goto Exit_Or_8;
    end if;
<<Exit_Or_8>>

--  End or_code


if Or_Pos_8 /= No_Token_Index then

   Transform_Res_23 := Project_Qualifier
     (Project_Qualifier_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_23.Unit := Parser.Unit;
   Transform_Res_23.Token_Start_Index := Pos;
   Transform_Res_23.Token_End_Index :=
     (if Or_Pos_8 = Pos
      then No_Token_Index
      else Or_Pos_8 - 1);

      Transform_Res_23.F_Qualifier :=
            GPR_Node (Or_Res_8);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Project_Qualifier_Transform_Parse_0_Memo,
        Or_Pos_8 /= No_Token_Index,
        Transform_Res_23,
        Pos,
        Or_Pos_8);


   Parser.Current_Pos := Or_Pos_8;

   return Transform_Res_23;
end Project_Qualifier_Transform_Parse_0;

   


function Project_Extension_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Project_Extension
is
      Row_Pos_28 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_48 :
            Token_Index
               := No_Token_Index;
      Tok_Res_48 :
            Token_Index
               := No_Token_Index;
      Tok_Pos_49 :
            Token_Index
               := No_Token_Index;
      Tok_Res_49 :
            Token_Index
               := No_Token_Index;
      Opt_Res_1 :
            Boolean
               := false;
      Defer_Pos_62 :
            Token_Index
               := No_Token_Index;
      Defer_Res_62 :
            String_Literal
               := null;
      Transform_Res_26 :
            Project_Extension
               := null;


   M : Project_Extension_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Project_Extension_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_26 := M.Instance;
      return Transform_Res_26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_26;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_28 := Pos;





--  Start tok_code

Tok_Res_48 := Row_Pos_28;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_48));
begin
   if
      T.Kind /= GPR_Extends
   then
       Tok_Pos_48 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_28 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_28,
             Expected_Token_Id => GPR_Extends,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_48 := Row_Pos_28 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_48 /= No_Token_Index then

   Row_Pos_28 := Tok_Pos_48;

else
   Row_Pos_28 := No_Token_Index;
   goto Exit_Row_28_0;

end if;




--  Start opt_code


--  Start tok_code

Tok_Res_49 := Row_Pos_28;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_49));
begin
   if
      T.Kind /= GPR_All
   then
       Tok_Pos_49 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_28 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_28,
             Expected_Token_Id => GPR_All,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_49 := Row_Pos_28 + 1;
   end if;
end;

--  End tok_code




if Tok_Pos_49 = No_Token_Index then
         Opt_Res_1 := False;


    Tok_Pos_49 := Row_Pos_28;

else
      Opt_Res_1 := True;

end if;

--  End opt_code


if Tok_Pos_49 /= No_Token_Index then

   Row_Pos_28 := Tok_Pos_49;

else
   Row_Pos_28 := No_Token_Index;
   goto Exit_Row_28_0;

end if;




Defer_Res_62 := String_Literal_Transform_Parse_0(Parser, Row_Pos_28);
Defer_Pos_62 := Parser.Current_Pos;


if Defer_Pos_62 /= No_Token_Index then

   Row_Pos_28 := Defer_Pos_62;

else
   Row_Pos_28 := No_Token_Index;
   goto Exit_Row_28_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_28_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_28 /= No_Token_Index then

   Transform_Res_26 := Project_Extension
     (Project_Extension_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_26.Unit := Parser.Unit;
   Transform_Res_26.Token_Start_Index := Pos;
   Transform_Res_26.Token_End_Index :=
     (if Row_Pos_28 = Pos
      then No_Token_Index
      else Row_Pos_28 - 1);

      Transform_Res_26.F_Is_All :=
            Opt_Res_1;
      Transform_Res_26.F_Path_Name :=
            String_Literal (Defer_Res_62);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Project_Extension_Transform_Parse_0_Memo,
        Row_Pos_28 /= No_Token_Index,
        Transform_Res_26,
        Pos,
        Row_Pos_28);


   Parser.Current_Pos := Row_Pos_28;

   return Transform_Res_26;
end Project_Extension_Transform_Parse_0;

   


function Declarative_Items_List_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return GPR_Node_List
is
      Lst_Cpos_8 :
            Token_Index
               := No_Token_Index;
      Tmp_List_8 :
            Free_Parse_List;
      Row_Pos_32 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_71 :
            Token_Index
               := No_Token_Index;
      Defer_Res_71 :
            GPR_Node
               := null;
      Tok_Pos_54 :
            Token_Index
               := No_Token_Index;
      Tok_Res_54 :
            Token_Index
               := No_Token_Index;
      List_Pos_8 :
            Token_Index
               := No_Token_Index;
      List_Res_8 :
            GPR_Node_List
               := null;


   M : GPR_Node_List_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Declarative_Items_List_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res_8 := M.Instance;
      return List_Res_8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res_8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start list_code

    List_Pos_8 := Pos;



Lst_Cpos_8 := Pos;
Tmp_List_8 := Get_Parse_List (Parser);

loop
   
--  Start row_code

Row_Pos_32 := Lst_Cpos_8;





Defer_Res_71 := Declarative_Item_Or_Parse_0(Parser, Row_Pos_32);
Defer_Pos_71 := Parser.Current_Pos;


if Defer_Pos_71 /= No_Token_Index then

   Row_Pos_32 := Defer_Pos_71;

else
   Row_Pos_32 := No_Token_Index;
   goto Exit_Row_32_0;

end if;




--  Start tok_code

Tok_Res_54 := Row_Pos_32;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_54));
begin
   if
      T.Kind /= GPR_Semicolon
   then
       Tok_Pos_54 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_32 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_32,
             Expected_Token_Id => GPR_Semicolon,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_54 := Row_Pos_32 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_54 /= No_Token_Index then

   Row_Pos_32 := Tok_Pos_54;

else
   Row_Pos_32 := No_Token_Index;
   goto Exit_Row_32_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_32_0>>
pragma Warnings (On, "referenced");

--  End row_code


   exit when Row_Pos_32 = No_Token_Index;

   List_Pos_8 := Row_Pos_32;
   Lst_Cpos_8 := List_Pos_8;

   Tmp_List_8.Nodes.Append
     (GPR_Node (Defer_Res_71));


end loop;

List_Res_8 := GPR_Node_List_Alloc.Alloc (Parser.Mem_Pool);
List_Res_8.Unit := Parser.Unit;
List_Res_8.Count := Tmp_List_8.Nodes.Length;

declare
   Vec : GPR_Node_Vectors.Vector renames
      Tmp_List_8.Nodes;
   Arr : Alloc_AST_List_Array.Element_Array_Access renames
      List_Res_8.Nodes;
begin
   Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
   for I in Vec.First_Index .. Vec.Last_Index loop
      Arr (I) := Vec.Get (I);
   end loop;
end;

if List_Res_8.Count > 0 then
   List_Res_8.Token_Start_Index := Pos;
   List_Res_8.Token_End_Index :=
     (if Lst_Cpos_8 = Pos
      then Pos else Lst_Cpos_8 - 1);

else
   List_Res_8.Token_Start_Index :=
      Token_Index'Max (Pos, 1);
   List_Res_8.Token_End_Index := No_Token_Index;
end if;

Release_Parse_List (Parser, Tmp_List_8);


--  End list_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Declarative_Items_List_Parse_0_Memo,
        List_Pos_8 /= No_Token_Index,
        List_Res_8,
        Pos,
        List_Pos_8);


   Parser.Current_Pos := List_Pos_8;

   return List_Res_8;
end Declarative_Items_List_Parse_0;

   


function Project_Declaration_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Project_Declaration
is
      Row_Pos_31 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_66 :
            Token_Index
               := No_Token_Index;
      Defer_Res_66 :
            Project_Qualifier
               := null;
      Tok_Pos_50 :
            Token_Index
               := No_Token_Index;
      Tok_Res_50 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_67 :
            Token_Index
               := No_Token_Index;
      Defer_Res_67 :
            Expr
               := null;
      Defer_Pos_68 :
            Token_Index
               := No_Token_Index;
      Defer_Res_68 :
            Project_Extension
               := null;
      Tok_Pos_51 :
            Token_Index
               := No_Token_Index;
      Tok_Res_51 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_69 :
            Token_Index
               := No_Token_Index;
      Defer_Res_69 :
            GPR_Node_List
               := null;
      Tok_Pos_52 :
            Token_Index
               := No_Token_Index;
      Tok_Res_52 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_70 :
            Token_Index
               := No_Token_Index;
      Defer_Res_70 :
            Expr
               := null;
      Tok_Pos_53 :
            Token_Index
               := No_Token_Index;
      Tok_Res_53 :
            Token_Index
               := No_Token_Index;
      Transform_Res_29 :
            Project_Declaration
               := null;


   M : Project_Declaration_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Project_Declaration_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_29 := M.Instance;
      return Transform_Res_29;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_29;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_31 := Pos;





--  Start opt_code


Defer_Res_66 := Project_Qualifier_Transform_Parse_0(Parser, Row_Pos_31);
Defer_Pos_66 := Parser.Current_Pos;




if Defer_Pos_66 = No_Token_Index then
        Defer_Res_66 :=
           null;


    Defer_Pos_66 := Row_Pos_31;


end if;

--  End opt_code


if Defer_Pos_66 /= No_Token_Index then

   Row_Pos_31 := Defer_Pos_66;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




--  Start tok_code

Tok_Res_50 := Row_Pos_31;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_50));
begin
   if
      T.Kind /= GPR_Project
   then
       Tok_Pos_50 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_31 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_31,
             Expected_Token_Id => GPR_Project,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_50 := Row_Pos_31 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_50 /= No_Token_Index then

   Row_Pos_31 := Tok_Pos_50;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




Defer_Res_67 := Static_Name_Or_Parse_0(Parser, Row_Pos_31);
Defer_Pos_67 := Parser.Current_Pos;


if Defer_Pos_67 /= No_Token_Index then

   Row_Pos_31 := Defer_Pos_67;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




--  Start opt_code


Defer_Res_68 := Project_Extension_Transform_Parse_0(Parser, Row_Pos_31);
Defer_Pos_68 := Parser.Current_Pos;




if Defer_Pos_68 = No_Token_Index then
        Defer_Res_68 :=
           null;


    Defer_Pos_68 := Row_Pos_31;


end if;

--  End opt_code


if Defer_Pos_68 /= No_Token_Index then

   Row_Pos_31 := Defer_Pos_68;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




--  Start tok_code

Tok_Res_51 := Row_Pos_31;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_51));
begin
   if
      T.Kind /= GPR_Is
   then
       Tok_Pos_51 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_31 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_31,
             Expected_Token_Id => GPR_Is,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_51 := Row_Pos_31 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_51 /= No_Token_Index then

   Row_Pos_31 := Tok_Pos_51;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




Defer_Res_69 := Declarative_Items_List_Parse_0(Parser, Row_Pos_31);
Defer_Pos_69 := Parser.Current_Pos;


if Defer_Pos_69 /= No_Token_Index then

   Row_Pos_31 := Defer_Pos_69;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




--  Start tok_code

Tok_Res_52 := Row_Pos_31;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_52));
begin
   if
      T.Kind /= GPR_End
   then
       Tok_Pos_52 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_31 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_31,
             Expected_Token_Id => GPR_End,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_52 := Row_Pos_31 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_52 /= No_Token_Index then

   Row_Pos_31 := Tok_Pos_52;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




Defer_Res_70 := Static_Name_Or_Parse_0(Parser, Row_Pos_31);
Defer_Pos_70 := Parser.Current_Pos;


if Defer_Pos_70 /= No_Token_Index then

   Row_Pos_31 := Defer_Pos_70;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;




--  Start tok_code

Tok_Res_53 := Row_Pos_31;

declare
   T : constant Lexer.Token_Data_Type :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Tok_Res_53));
begin
   if
      T.Kind /= GPR_Semicolon
   then
       Tok_Pos_53 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos_31 then
          Parser.Last_Fail :=
            (Kind => Token_Fail,
             Pos => Row_Pos_31,
             Expected_Token_Id => GPR_Semicolon,
             Found_Token_Id => T.Kind);
       end if;
   else
          Tok_Pos_53 := Row_Pos_31 + 1;
   end if;
end;

--  End tok_code


if Tok_Pos_53 /= No_Token_Index then

   Row_Pos_31 := Tok_Pos_53;

else
   Row_Pos_31 := No_Token_Index;
   goto Exit_Row_31_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_31_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_31 /= No_Token_Index then

   Transform_Res_29 := Project_Declaration
     (Project_Declaration_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_29.Unit := Parser.Unit;
   Transform_Res_29.Token_Start_Index := Pos;
   Transform_Res_29.Token_End_Index :=
     (if Row_Pos_31 = Pos
      then No_Token_Index
      else Row_Pos_31 - 1);

      Transform_Res_29.F_Qualifier :=
            Project_Qualifier (Defer_Res_66);
      Transform_Res_29.F_Project_Name :=
            Expr (Defer_Res_67);
      Transform_Res_29.F_Extension :=
            Project_Extension (Defer_Res_68);
      Transform_Res_29.F_Decls :=
            GPR_Node_List (Defer_Res_69);
      Transform_Res_29.F_End_Name :=
            Expr (Defer_Res_70);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Project_Declaration_Transform_Parse_0_Memo,
        Row_Pos_31 /= No_Token_Index,
        Transform_Res_29,
        Pos,
        Row_Pos_31);


   Parser.Current_Pos := Row_Pos_31;

   return Transform_Res_29;
end Project_Declaration_Transform_Parse_0;

   


function Project_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Project
is
      Row_Pos_30 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_64 :
            Token_Index
               := No_Token_Index;
      Defer_Res_64 :
            With_Decl_List
               := null;
      Defer_Pos_65 :
            Token_Index
               := No_Token_Index;
      Defer_Res_65 :
            Project_Declaration
               := null;
      Transform_Res_28 :
            Project
               := null;


   M : Project_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Project_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_28 := M.Instance;
      return Transform_Res_28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_28;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_30 := Pos;





Defer_Res_64 := Context_Clauses_List_Parse_0(Parser, Row_Pos_30);
Defer_Pos_64 := Parser.Current_Pos;


if Defer_Pos_64 /= No_Token_Index then

   Row_Pos_30 := Defer_Pos_64;

else
   Row_Pos_30 := No_Token_Index;
   goto Exit_Row_30_0;

end if;




Defer_Res_65 := Project_Declaration_Transform_Parse_0(Parser, Row_Pos_30);
Defer_Pos_65 := Parser.Current_Pos;


if Defer_Pos_65 /= No_Token_Index then

   Row_Pos_30 := Defer_Pos_65;

else
   Row_Pos_30 := No_Token_Index;
   goto Exit_Row_30_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_30_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_30 /= No_Token_Index then

   Transform_Res_28 := Project
     (Project_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_28.Unit := Parser.Unit;
   Transform_Res_28.Token_Start_Index := Pos;
   Transform_Res_28.Token_End_Index :=
     (if Row_Pos_30 = Pos
      then No_Token_Index
      else Row_Pos_30 - 1);

      Transform_Res_28.F_Context_Clauses :=
            With_Decl_List (Defer_Res_64);
      Transform_Res_28.F_Project_Decl :=
            Project_Declaration (Defer_Res_65);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Project_Transform_Parse_0_Memo,
        Row_Pos_30 /= No_Token_Index,
        Transform_Res_28,
        Pos,
        Row_Pos_30);


   Parser.Current_Pos := Row_Pos_30;

   return Transform_Res_28;
end Project_Transform_Parse_0;

   


function Compilation_Unit_Transform_Parse_0 (Parser : in out Parser_Type;
                                Pos    : Token_Index)
                                return Compilation_Unit
is
      Row_Pos_29 :
            Token_Index
               := No_Token_Index;
      Defer_Pos_63 :
            Token_Index
               := No_Token_Index;
      Defer_Res_63 :
            Project
               := null;
      Transform_Res_27 :
            Compilation_Unit
               := null;


   M : Compilation_Unit_Memos.Memo_Entry :=
     Get (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo, Pos);

begin

   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res_27 := M.Instance;
      return Transform_Res_27;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res_27;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  Start transform_code


--  Start row_code

Row_Pos_29 := Pos;





Defer_Res_63 := Project_Transform_Parse_0(Parser, Row_Pos_29);
Defer_Pos_63 := Parser.Current_Pos;


if Defer_Pos_63 /= No_Token_Index then

   Row_Pos_29 := Defer_Pos_63;

else
   Row_Pos_29 := No_Token_Index;
   goto Exit_Row_29_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row_29_0>>
pragma Warnings (On, "referenced");

--  End row_code


if Row_Pos_29 /= No_Token_Index then

   Transform_Res_27 := Compilation_Unit
     (Compilation_Unit_Alloc.Alloc (Parser.Mem_Pool));

   Transform_Res_27.Unit := Parser.Unit;
   Transform_Res_27.Token_Start_Index := Pos;
   Transform_Res_27.Token_End_Index :=
     (if Row_Pos_29 = Pos
      then No_Token_Index
      else Row_Pos_29 - 1);

      Transform_Res_27.F_Project :=
            Project (Defer_Res_63);

end if;

--  End transform_code


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo,
        Row_Pos_29 /= No_Token_Index,
        Transform_Res_27,
        Pos,
        Row_Pos_29);


   Parser.Current_Pos := Row_Pos_29;

   return Transform_Res_27;
end Compilation_Unit_Transform_Parse_0;


   -----------
   -- Reset --
   -----------

   procedure Reset (Parser : in out Parser_Type) is
      New_Parser : Parser_Type;
      --  We create this new parser instance to leverage creation of default
      --  values, so as to not repeat them.
   begin
      --  We just keep the private part, to not have to reallocate it
      New_Parser.Private_Part := Parser.Private_Part;

      --  And then reset everything else
      Parser := New_Parser;

      --  Reset the memo tables in the private part
         Clear (Parser.Private_Part.Discrete_Choice_List_List_Parse_0_Memo);
         Clear (Parser.Private_Part.Context_Clauses_List_Parse_0_Memo);
         Clear (Parser.Private_Part.Declarative_Items_List_Parse_0_Memo);
         Clear (Parser.Private_Part.Simple_Declarative_Items_List_Parse_0_Memo);
         Clear (Parser.Private_Part.Term_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Choice_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Static_Name_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Declarative_Item_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Simple_Declarative_Item_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Associative_Array_Index_Or_Parse_0_Memo);
         Clear (Parser.Private_Part.Project_Reference_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Package_Decl_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Package_Renaming_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Package_Extension_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Package_Spec_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Empty_Declaration_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Case_Construction_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Case_Item_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Typed_String_Decl_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Identifier_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Num_Literal_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Attribute_Reference_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Variable_Reference_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Builtin_Function_Call_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Expression_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Expression_List_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.String_Literal_At_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.With_Decl_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Abstract_Present_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Qualifier_Names_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Project_Qualifier_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Project_Extension_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Project_Declaration_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Project_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Variable_Decl_Transform_Parse_0_Memo);
         Clear (Parser.Private_Part.Attribute_Decl_Transform_Parse_0_Memo);
   end Reset;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Parser : in out Parser_Type) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Parser_Private_Part_Type, Parser_Private_Part);
      procedure Free is new Ada.Unchecked_Deallocation
        (Free_Parse_List_Record, Free_Parse_List);

      Cur : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      while Cur /= null loop
         declare
            Next : constant Free_Parse_List := Cur.Next;
         begin
            Cur.Nodes.Destroy;
            Free (Cur);
            Cur := Next;
         end;
      end loop;
      Free (Parser.Private_Part);
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize (Parser : in out Parser_Type) is
   begin
      Parser.Private_Part := new Parser_Private_Part_Type'(others => <>);
   end Initialize;

   --------------------
   -- Get_Parse_List --
   --------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List is
      Lists  : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
      Result : Free_Parse_List;
   begin
      if Lists = null then
         Result := new Free_Parse_List_Record;

      else
         Result := Lists;
         Lists := Lists.Next;
      end if;

      return Result;
   end Get_Parse_List;

   ------------------------
   -- Release_Parse_List --
   ------------------------

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List)
   is
      Lists  : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      List.Nodes.Clear;
      List.Next := Lists;
      Lists := List;
      List := null;
   end Release_Parse_List;

end GPR_Parser.Analysis.Parsers;
