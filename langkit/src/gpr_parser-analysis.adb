
------------------------------------------------------------------------------
--                                                                          --
--                            GPR PROJECT PARSER                            --
--                                                                          --
--            Copyright (C) 2015-2017, Free Software Foundation, Inc.       --
--                                                                          --
-- This library is free software;  you can redistribute it and/or modify it --
-- under terms of the  GNU General Public License  as published by the Free --
-- Software  Foundation;  either version 3,  or (at your  option) any later --
-- version. This library is distributed in the hope that it will be useful, --
-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --
--                                                                          --
-- As a special exception under Section 7 of GPL version 3, you are granted --
-- additional permissions described in the GCC Runtime Library Exception,   --
-- version 3.1, as published by the Free Software Foundation.               --
--                                                                          --
-- You should have received a copy of the GNU General Public License and    --
-- a copy of the GCC Runtime Library Exception along with this program;     --
-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
-- <http://www.gnu.org/licenses/>.                                          --
--                                                                          --
------------------------------------------------------------------------------

--  DO NOT EDIT THIS IS AN AUTOGENERATED FILE










with Ada.Containers;                  use Ada.Containers;
with Ada.Containers.Hashed_Maps;
with Ada.Containers.Ordered_Maps;
with Ada.Exceptions;
with Ada.Strings.Wide_Wide_Unbounded; use Ada.Strings.Wide_Wide_Unbounded;
with Ada.Text_IO;                     use Ada.Text_IO;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;

with System.Address_Image;
with System.Storage_Elements;    use System.Storage_Elements;

with Langkit_Support.Array_Utils;
with Langkit_Support.Images;  use Langkit_Support.Images;
with Langkit_Support.Relative_Get;
with Langkit_Support.Slocs;   use Langkit_Support.Slocs;
with Langkit_Support.Text;    use Langkit_Support.Text;

pragma Warnings (Off, "referenced");
with Langkit_Support.Adalog.Abstract_Relation;
use Langkit_Support.Adalog.Abstract_Relation;
with Langkit_Support.Adalog.Debug;
use Langkit_Support.Adalog.Debug;
with Langkit_Support.Adalog.Operations;
use Langkit_Support.Adalog.Operations;
with Langkit_Support.Adalog.Predicates;
use Langkit_Support.Adalog.Predicates;
with Langkit_Support.Adalog.Pure_Relations;
use Langkit_Support.Adalog.Pure_Relations;
pragma Warnings (On, "referenced");

with GPR_Parser.Analysis.Parsers; use GPR_Parser.Analysis.Parsers;
with GPR_Parser.Lexer;


package body GPR_Parser.Analysis is

   type Analysis_Context_Private_Part_Type is record
      Parser : Parser_Type;
      --  Main parser type. TODO: If we want to parse in several tasks, we'll
      --  replace that by an array of parsers.
   end record;

   

   


   ---------
   -- Get --
   ---------

   function Get
     (T       : GPR_Node_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return GPR_Node
   is
      function Absolute_Get
        (T : GPR_Node_Array_Access; Index : Integer)
         return GPR_Node
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => GPR_Node,
         Sequence_Type => GPR_Node_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : GPR_Node;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds array access";
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : GPR_Node_Array_Access) return GPR_Node_Array_Access is
      use GPR_Node_Vectors;
      Ret : GPR_Node_Array_Access := Create (Length (L) + Length (R));
   begin
      Ret.Items := (L.Items & R.Items);
      return Ret;
   end Concat;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : GPR_Node_Array_Access) is
   begin
      T.Ref_Count := T.Ref_Count + 1;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : GPR_Node_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out GPR_Node_Array_Access) is
   begin
      if T = null then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   ------------
   -- Create --
   ------------

   function Create (Items_Count : Natural) return GPR_Node_Array_Access is
     (new GPR_Node_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));



   procedure Destroy (Self : in out Lex_Env_Data_Type);
   --  Destroy data associated to lexical environments

   type Containing_Env_Element is record
      Env  : Lexical_Env;
      Key  : Symbol_Type;
      Node : GPR_Node;
   end record;
   --  Tuple of values passed to Lexical_Env.Add. Used in the lexical
   --  environment rerooting machinery: see Lex_Env_Data_Type.

   package Containing_Envs is new Langkit_Support.Vectors
     (Containing_Env_Element);

   type Lex_Env_Data_Type is record
      Is_Contained_By : Containing_Envs.Vector;
      --  Lexical env population for the unit that owns this Lex_Env_Data may
      --  have added AST nodes it owns to the lexical environments that belong
      --  to other units. For each of these AST nodes, this vector contains an
      --  entry that records the target environment, the AST node and the
      --  corresponding symbol.

      Contains : GPR_Node_Vectors.Vector;
      --  The unit that owns this Lex_Env_Data owns a set of lexical
      --  environments. This vector contains the list of AST nodes that were
      --  added to these environments and that come from other units.
   end record;

   procedure Remove_Exiled_Entries (Self : Lex_Env_Data);
   --  Remove lex env entries that references some of the unit's nodes, in
   --  lexical environments not owned by the unit.

   procedure Reroot_Foreign_Nodes
     (Self : Lex_Env_Data; Root_Scope : Lexical_Env);
   --  Re-create entries for nodes that are keyed in one of the unit's lexical
   --  envs.

   procedure Update_After_Reparse (Unit : Analysis_Unit);
   --  Update stale lexical environment data after the reparsing of Unit

   package GPR_Node_Arrays
   is new Langkit_Support.Array_Utils
     (GPR_Node,
      GPR_Node_Vectors.Index_Type,
      GPR_Node_Vectors.Elements_Array);

   use Eq_Node, Eq_Node.Raw_Impl;

   procedure Destroy (Unit : Analysis_Unit);

   procedure Free is new Ada.Unchecked_Deallocation
     (Analysis_Context_Type, Analysis_Context);

   procedure Free is new Ada.Unchecked_Deallocation
     (Analysis_Unit_Type, Analysis_Unit);

   procedure Update_Charset (Unit : Analysis_Unit; Charset : String);
   --  If Charset is an empty string, do nothing. Otherwise, update
   --  Unit.Charset field to Charset.

   procedure Do_Parsing
     (Unit        : Analysis_Unit;
      Read_BOM    : Boolean;
      Init_Parser : access procedure (Unit     : Analysis_Unit;
                                      Read_BOM : Boolean;
                                      Parser   : in out Parser_Type));
   --  Helper for Get_Unit and the public Reparse procedures: parse an analysis
   --  unit using Init_Parser and replace Unit's AST_Root and the diagnostics
   --  with the parsers's output.

   function Create_Unit
     (Context           : Analysis_Context;
      Filename, Charset : String;
      With_Trivia       : Boolean;
      Rule              : Grammar_Rule) return Analysis_Unit
      with Pre => not Has_Unit (Context, Filename);
   --  Create a new analysis unit and register it in Context

   function Get_Unit
     (Context           : Analysis_Context;
      Filename, Charset : String;
      Reparse           : Boolean;
      Init_Parser       :
        access procedure (Unit     : Analysis_Unit;
                          Read_BOM : Boolean;
                          Parser   : in out Parser_Type);
      With_Trivia       : Boolean;
      Rule              : Grammar_Rule)
      return Analysis_Unit;
   --  Helper for Get_From_File and Get_From_Buffer: do all the common work
   --  using Init_Parser to either parse from a file or from a buffer. Return
   --  the resulting analysis unit.


   function Convert
     (TDH      : Token_Data_Handler;
      Token    : Token_Type;
      Raw_Data : Lexer.Token_Data_Type) return Token_Data_Type;
   --  Turn data from TDH and Raw_Data into a user-ready token data record

   ------------------------
   -- Address_To_Id_Maps --
   ------------------------

   --  Those maps are used to give unique ids to lexical envs while pretty
   --  printing them.

   function Hash (S : Lexical_Env) return Hash_Type is
     (Hash_Type (To_Integer (S.all'Address)));

   package Address_To_Id_Maps is new Ada.Containers.Hashed_Maps
     (Lexical_Env, Integer, Hash, "=");

   type Dump_Lexical_Env_State is record
      Env_Ids : Address_to_Id_Maps.Map;
      --  Mapping: Lexical_Env -> Integer, used to remember which unique Ids we
      --  assigned to the lexical environments we found.

      Next_Id : Positive := 1;
      --  Id to assign to the next unknown lexical environment

      Root_Env : Lexical_Env;
      --  Lexical environment we consider a root (this is the Root_Scope from
      --  the current analysis context), or null if unknown.
   end record;
   --  Holder for the state of lexical environment dumpers

   function Get_Env_Id
     (E : Lexical_Env; State : in out Dump_Lexical_Env_State) return String;
   --  If E is known, return its unique Id from State. Otherwise, assign it a
   --  new unique Id and return it.

   --------------------
   -- Update_Charset --
   --------------------

   procedure Update_Charset (Unit : Analysis_Unit; Charset : String)
   is
   begin
      if Charset'Length /= 0 then
         Unit.Charset := To_Unbounded_String (Charset);
      end if;
   end Update_Charset;

   ------------
   -- Create --
   ------------

   function Create
     (Charset : String := Default_Charset
     ) return Analysis_Context
   is
      Actual_Charset : constant String :=
        (if Charset = "" then Default_Charset else Charset);
      Symbols        : constant Symbol_Table := Create;
      Ret            : Analysis_Context;
   begin
      Ret := new Analysis_Context_Type'
        (Ref_Count  => 1,
         Units_Map  => <>,
         Symbols    => Symbols,
         Charset    => To_Unbounded_String (Actual_Charset),
         Root_Scope => AST_Envs.Create
                         (Parent        => AST_Envs.No_Env_Getter,
                          Node          => null,
                          Is_Refcounted => False),



         Private_Part =>
         new Analysis_Context_Private_Part_Type'(others => <>)
        );

      Initialize (Ret.Private_Part.Parser);
      return Ret;
   end Create;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Context : Analysis_Context) is
   begin
      Context.Ref_Count := Context.Ref_Count + 1;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Context : in out Analysis_Context) is
   begin
      Context.Ref_Count := Context.Ref_Count - 1;
      if Context.Ref_Count = 0 then
         Destroy (Context);
      end if;
   end Dec_Ref;

   -----------------
   -- Create_Unit --
   -----------------

   function Create_Unit
     (Context           : Analysis_Context;
      Filename, Charset : String;
      With_Trivia       : Boolean;
      Rule              : Grammar_Rule) return Analysis_Unit
   is
      Fname : constant Unbounded_String := To_Unbounded_String (Filename);
      Unit  : Analysis_Unit := new Analysis_Unit_Type'
        (Context           => Context,
         Ref_Count         => 1,
         AST_Root          => null,
         File_Name         => Fname,
         Charset           => <>,
         TDH               => <>,
         Diagnostics       => <>,
         With_Trivia       => With_Trivia,
         Is_Env_Populated  => False,
         Has_Filled_Caches => False,
         Rule              => Rule,
         AST_Mem_Pool      => No_Pool,
         Destroyables      => Destroyable_Vectors.Empty_Vector,
         Referenced_Units  => <>,
         Lex_Env_Data_Acc  => new Lex_Env_Data_Type);
   begin
      Initialize (Unit.TDH, Context.Symbols);
      Context.Units_Map.Insert (Fname, Unit);
      return Unit;
   end Create_Unit;

   --------------
   -- Get_Unit --
   --------------

   function Get_Unit
     (Context           : Analysis_Context;
      Filename, Charset : String;
      Reparse           : Boolean;
      Init_Parser       :
        access procedure (Unit     : Analysis_Unit;
                          Read_BOM : Boolean;
                          Parser   : in out Parser_Type);
      With_Trivia       : Boolean;
      Rule              : Grammar_Rule)
      return Analysis_Unit
   is
      use Units_Maps;

      Fname   : constant Unbounded_String := To_Unbounded_String (Filename);
      Cur     : constant Cursor := Context.Units_Map.Find (Fname);
      Created : constant Boolean := Cur = No_Element;
      Unit    : Analysis_Unit;

      Read_BOM : constant Boolean := Charset'Length = 0;
      --  Unless the caller requested a specific charset for this unit, allow
      --  the lexer to automatically discover the source file encoding before
      --  defaulting to the context-specific one. We do this trying to match a
      --  byte order mark.

      Actual_Charset : Unbounded_String;

   begin
      --  Determine which encoding to use.  The parameter comes first, then the
      --  unit-specific default, then the context-specific one.

      if Charset'Length /= 0 then
         Actual_Charset := To_Unbounded_String (Charset);
      elsif not Created then
         Actual_Charset := Element (Cur).Charset;
      else
         Actual_Charset := Context.Charset;
      end if;

      --  Create the Analysis_Unit if needed

      if Created then
         Unit := Create_Unit (Context, Filename, Charset, With_Trivia, Rule);
      else
         Unit := Element (Cur);
      end if;
      Unit.Charset := Actual_Charset;

      --  (Re)parse it if needed

      if Created
         or else Reparse
         or else (With_Trivia and then not Unit.With_Trivia)
      then
         Do_Parsing (Unit, Read_BOM, Init_Parser);
      end if;

      --  If we're in a reparse, do necessary updates
      if Reparse or else (With_Trivia and then not Unit.With_Trivia) then
         Update_After_Reparse (Unit);
      end if;

      return Unit;
   end Get_Unit;

   --------------
   -- Has_Unit --
   --------------

   function Has_Unit
     (Context       : Analysis_Context;
      Unit_Filename : String) return Boolean is
   begin
      return Context.Units_Map.Contains (To_Unbounded_String (Unit_Filename));
   end Has_Unit;

   ----------------
   -- Do_Parsing --
   ----------------

   procedure Do_Parsing
     (Unit        : Analysis_Unit;
      Read_BOM    : Boolean;
      Init_Parser :
        access procedure (Unit     : Analysis_Unit;
                          Read_BOM : Boolean;
                          Parser   : in out Parser_Type))
   is

      procedure Add_Diagnostic (Message : String);
      --  Helper to add a sloc-less diagnostic to Unit

      --------------------
      -- Add_Diagnostic --
      --------------------

      procedure Add_Diagnostic (Message : String) is
      begin
         Unit.Diagnostics.Append
           ((Sloc_Range => No_Source_Location_Range,
             Message    => To_Unbounded_Wide_Wide_String (To_Text (Message))));
      end Add_Diagnostic;

   begin
      --  If we have an AST_Mem_Pool already, we are reparsing. We want to
      --  destroy it to free all the allocated memory.
      if Unit.AST_Root /= null then
         Unit.AST_Root.Destroy;
      end if;
      if Unit.AST_Mem_Pool /= No_Pool then
         Free (Unit.AST_Mem_Pool);
      end if;
      Unit.AST_Root := null;
      Unit.Has_Filled_Caches := False;
      Unit.Diagnostics.Clear;

      --  As (re-)loading an unit can change how any AST node property in the
      --  whole analysis context behaves, we have to invalidate caches. This
      --  is likely overkill, but kill all caches here as it's easy to do.
      Reset_Property_Caches (Unit.Context);

      --  Now create the parser. This is where lexing occurs, so this is where
      --  we get most "setup" issues: missing input file, bad charset, etc.
      --  If we have such an error, catch it, turn it into diagnostics and
      --  abort parsing.

      declare
         use Ada.Exceptions;
      begin
         Init_Parser (Unit, Read_BOM, Unit.Context.Private_Part.Parser);
      exception
         when Exc : Name_Error =>
            --  This happens when we cannot open the source file for lexing:
            --  return an unit anyway with diagnostics indicating what happens.

            Add_Diagnostic
              (Exception_Message (Exc));
            return;

         when Lexer.Unknown_Charset =>
            Add_Diagnostic
              ("Unknown charset """ & To_String (Unit.Charset) & """");
            return;

         when Lexer.Invalid_Input =>
            --  TODO??? Tell where (as a source location) we failed to decode
            --  the input.
            Add_Diagnostic
              ("Could not decode source as """ & To_String (Unit.Charset)
               & """");
            return;
      end;

      --  We have correctly setup a parser! Now let's parse and return what we
      --  get.

      Unit.AST_Mem_Pool := Create;
      Unit.Context.Private_Part.Parser.Mem_Pool := Unit.AST_Mem_Pool;

      Unit.AST_Root :=
        Parse (Unit.Context.Private_Part.Parser, Rule => Unit.Rule);
      Unit.Diagnostics := Unit.Context.Private_Part.Parser.Diagnostics;
   end Do_Parsing;

   -------------------
   -- Get_From_File --
   -------------------

   function Get_From_File
     (Context     : Analysis_Context;
      Filename    : String;
      Charset     : String := "";
      Reparse     : Boolean := False;
      With_Trivia : Boolean := False;
      Rule        : Grammar_Rule :=
         Compilation_Unit_Rule)
      return Analysis_Unit
   is
      procedure Init_Parser
        (Unit     : Analysis_Unit;
         Read_BOM : Boolean;
         Parser   : in out Parser_Type)
      is
      begin
         Init_Parser_From_File
           (Filename, To_String (Unit.Charset), Read_BOM, Unit,
            With_Trivia, Parser);
      end Init_Parser;
   begin
      return Get_Unit
        (Context, Filename, Charset, Reparse, Init_Parser'Access, With_Trivia,
         Rule);
   end Get_From_File;

   ---------------------
   -- Get_From_Buffer --
   ---------------------

   function Get_From_Buffer
     (Context     : Analysis_Context;
      Filename    : String;
      Charset     : String := "";
      Buffer      : String;
      With_Trivia : Boolean := False;
      Rule        : Grammar_Rule :=
         Compilation_Unit_Rule)
      return Analysis_Unit
   is
      procedure Init_Parser
        (Unit     : Analysis_Unit;
         Read_BOM : Boolean;
         Parser   : in out Parser_Type)
      is
      begin
         Init_Parser_From_Buffer
           (Buffer, To_String (Unit.Charset), Read_BOM, Unit,
            With_Trivia, Parser);
      end Init_Parser;
   begin
      return Get_Unit (Context, Filename, Charset, True, Init_Parser'Access,
                       With_Trivia, Rule);
   end Get_From_Buffer;


   --------------------
   -- Get_With_Error --
   --------------------

   function Get_With_Error
     (Context     : Analysis_Context;
      Filename    : String;
      Error       : String;
      Charset     : String := "";
      With_Trivia : Boolean := False;
      Rule        : Grammar_Rule :=
         Compilation_Unit_Rule)
      return Analysis_Unit
   is
      use Units_Maps;

      Fname : constant Unbounded_String := To_Unbounded_String (Filename);
      Cur   : constant Cursor := Context.Units_Map.Find (Fname);
   begin
      if Cur = No_Element then
         declare
            Unit : constant Analysis_Unit :=
               Create_Unit (Context, Filename, Charset, With_Trivia, Rule);
            Msg  : constant Text_Type := To_Text (Error);
         begin
            Unit.Diagnostics.Append
              ((Sloc_Range => No_Source_Location_Range,
                Message    => To_Unbounded_Wide_Wide_String (Msg)));
            return Unit;
         end;
      else
         return Element (Cur);
      end if;
   end Get_With_Error;

   ------------
   -- Remove --
   ------------

   procedure Remove (Context   : Analysis_Context;
                     File_Name : String)
   is
      use Units_Maps;

      Cur : Cursor := Context.Units_Map.Find (To_Unbounded_String (File_Name));
   begin
      if Cur = No_Element then
         raise Constraint_Error with "No such analysis unit";
      end if;

      --  We remove the corresponding analysis unit from this context but
      --  users could keep references on it, so make sure it can live
      --  independently.

      declare
         Unit : constant Analysis_Unit := Element (Cur);
      begin
         Unit.Context := null;
         Dec_Ref (Unit);
      end;

      Context.Units_Map.Delete (Cur);
   end Remove;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Context : in out Analysis_Context) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Analysis_Context_Private_Part_Type, Analysis_Context_Private_Part);
   begin
      for Unit of Context.Units_Map loop
         Unit.Context := null;
         Dec_Ref (Unit);
      end loop;
      AST_Envs.Destroy (Context.Root_Scope);

      Destroy (Context.Symbols);

      --  Free resources associated to the private part
      Destroy (Context.Private_Part.Parser);
      Free (Context.Private_Part);

      Free (Context);
   end Destroy;

   ---------------------------
   -- Reset_Property_Caches --
   ---------------------------

   procedure Reset_Property_Caches (Context : Analysis_Context) is
   begin
      for Unit of Context.Units_Map loop
         Reset_Property_Caches (Unit);
      end loop;
   end Reset_Property_Caches;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Unit : Analysis_Unit) is
   begin
      Unit.Ref_Count := Unit.Ref_Count + 1;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Unit : Analysis_Unit) is
   begin
      Unit.Ref_Count := Unit.Ref_Count - 1;
      if Unit.Ref_Count = 0 then
         Destroy (Unit);
      end if;
   end Dec_Ref;

   ---------------------------
   -- Remove_Exiled_Entries --
   ---------------------------

   procedure Remove_Exiled_Entries (Self : Lex_Env_Data) is
   begin
      for El of Self.Is_Contained_By loop
         AST_Envs.Remove (El.Env, El.Key, El.Node);
      end loop;
      Self.Is_Contained_By.Clear;
   end Remove_Exiled_Entries;

   --------------------------
   -- Reroot_Foreign_Nodes --
   --------------------------

   procedure Reroot_Foreign_Nodes
     (Self : Lex_Env_Data; Root_Scope : Lexical_Env)
   is
      Els : GPR_Node_Vectors.Elements_Array :=
         Self.Contains.To_Array;
      Env : Lexical_Env;
   begin
      Self.Is_Contained_By.Clear;
      for El of Els loop
         Env := El.Pre_Env_Actions (El.Self_Env, Root_Scope, True);
         El.Post_Env_Actions (Env, Root_Scope);
      end loop;
   end Reroot_Foreign_Nodes;

   --------------------------
   -- Update_After_Reparse --
   --------------------------

   procedure Update_After_Reparse (Unit : Analysis_Unit)
   is
   begin
      if Unit.Is_Env_Populated then

         --  Reset the flag so that Populate_Lexical_Env does its work
         Unit.Is_Env_Populated := False;

         --  First we'll remove old entries referencing the old translation
         --  unit in foreign lexical envs.
         Remove_Exiled_Entries (Unit.Lex_Env_Data_Acc);

         --  Then we'll recreate the lexical env structure for the newly parsed
         --  unit.
         Populate_Lexical_Env (Unit);

         --  Finally, any entry that was rooted in one of the unit's lex envs
         --  needs to be re-rooted.
         Reroot_Foreign_Nodes
           (Unit.Lex_Env_Data_Acc, Unit.Context.Root_Scope);

      end if;
   end Update_After_Reparse;

   -------------
   -- Reparse --
   -------------

   procedure Reparse
     (Unit    : Analysis_Unit;
      Charset : String := "")
   is
      procedure Init_Parser
        (Unit     : Analysis_Unit;
         Read_BOM : Boolean;
         Parser   : in out Parser_Type)
      is
      begin
         Init_Parser_From_File
           (To_String (Unit.File_Name),
            To_String (Unit.Charset),
            Read_BOM, Unit, Unit.With_Trivia, Parser);
      end Init_Parser;
   begin
      Update_Charset (Unit, Charset);
      Do_Parsing (Unit, Charset'Length = 0, Init_Parser'Access);
      Update_After_Reparse (Unit);
   end Reparse;

   -------------
   -- Reparse --
   -------------

   procedure Reparse
     (Unit    : Analysis_Unit;
      Charset : String := "";
      Buffer  : String)
   is
      procedure Init_Parser
        (Unit     : Analysis_Unit;
         Read_BOM : Boolean;
         Parser   : in out Parser_Type)
      is
      begin
         Init_Parser_From_Buffer
           (Buffer, To_String (Unit.Charset), Read_BOM,
            Unit, Unit.With_Trivia, Parser);
      end Init_Parser;
   begin
      Update_Charset (Unit, Charset);
      Do_Parsing (Unit, Charset'Length = 0, Init_Parser'Access);
      Unit.Charset := To_Unbounded_String (Charset);
      Update_After_Reparse (Unit);
   end Reparse;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Unit : Analysis_Unit) is
      Unit_Var : Analysis_Unit := Unit;
   begin
      Destroy (Unit.Lex_Env_Data_Acc);
      Analysis_Unit_Sets.Destroy (Unit.Referenced_Units);

      if Unit.AST_Root /= null then
         Destroy (Unit.AST_Root);
      end if;

      Free (Unit.TDH);
      Free (Unit.AST_Mem_Pool);
      for D of Unit.Destroyables loop
         D.Destroy (D.Object);
      end loop;
      Destroyable_Vectors.Destroy (Unit.Destroyables);
      Free (Unit_Var);

   end Destroy;

   -----------
   -- Print --
   -----------

   procedure Print (Unit : Analysis_Unit) is
   begin
      if Unit.AST_Root = null then
         Put_Line ("<empty analysis unit>");
      else
         Unit.AST_Root.Print;
      end if;
   end Print;

   ---------------
   -- PP_Trivia --
   ---------------

   procedure PP_Trivia (Unit : Analysis_Unit) is

      procedure Process (Trivia : Token_Index) is
         Data : constant Lexer.Token_Data_Type :=
            Unit.TDH.Trivias.Get (Natural (Trivia)).T;
      begin
         Put_Line (Image (Text (Unit.TDH, Data)));
      end Process;

      Last_Token : constant Token_Index :=
         Token_Index (Token_Vectors.Last_Index (Unit.TDH.Tokens) - 1);
      --  Index for the last token in Unit excluding the Termination token
      --  (hence the -1).
   begin
      for Tok of Get_Leading_Trivias (Unit.TDH) loop
         Process (Tok);
      end loop;

      PP_Trivia (Unit.AST_Root);

      for Tok of Get_Trivias (Unit.TDH, Last_Token) loop
         Process (Tok);
      end loop;
   end PP_Trivia;

   --------------------------
   -- Populate_Lexical_Env --
   --------------------------

   procedure Populate_Lexical_Env (Unit : Analysis_Unit) is
   begin
      --  TODO??? Handle env invalidation when reparsing an unit and when a
      --  previous call raised a Property_Error.
      if Unit.Is_Env_Populated then
         return;
      end if;
      Unit.Is_Env_Populated := True;

      Populate_Lexical_Env (Unit.AST_Root, Unit.Context.Root_Scope);
   end Populate_Lexical_Env;

   ---------------------
   -- Pre_Env_Actions --
   ---------------------

   function Pre_Env_Actions
     (Self                : access GPR_Node_Type;
      Bound_Env, Root_Env : AST_Envs.Lexical_Env;
      Add_To_Env_Only     : Boolean := False) return AST_Envs.Lexical_Env
   is (null);

   ---------------------
   -- Is_Visible_From --
   ---------------------

   function Is_Visible_From
     (Referenced_Env, Base_Env : AST_Envs.Lexical_Env) return Boolean is
      Referenced_Node : constant GPR_Node := Referenced_Env.Node;
      Base_Node       : constant GPR_Node := Base_Env.Node;
   begin
      if Referenced_Node = null then
         raise Property_Error with
            "referenced environment does not belong to any analysis unit";
      elsif Base_Node = null then
         raise Property_Error with
            "base environment does not belong to any analysis unit";
      end if;
      return Is_Referenced_From (Referenced_Node.Unit, Base_Node.Unit);
   end Is_Visible_From;

   ---------------------
   -- Has_Diagnostics --
   ---------------------

   function Has_Diagnostics (Unit : Analysis_Unit) return Boolean is
   begin
      return not Unit.Diagnostics.Is_Empty;
   end Has_Diagnostics;

   -----------------
   -- Diagnostics --
   -----------------

   function Diagnostics (Unit : Analysis_Unit) return Diagnostics_Array is
      Result : Diagnostics_Array (1 .. Natural (Unit.Diagnostics.Length));
      I      : Natural := 1;
   begin
      for D of Unit.Diagnostics loop
         Result (I) := D;
         I := I + 1;
      end loop;
      return Result;
   end Diagnostics;

   ----------------------
   -- Dump_Lexical_Env --
   ----------------------

   procedure Dump_Lexical_Env (Unit : Analysis_Unit) is
   begin
      Dump_Lexical_Env (Unit.AST_Root, Unit.Context.Root_Scope);
   end Dump_Lexical_Env;

   --------------------------
   -- Register_Destroyable --
   --------------------------

   procedure Register_Destroyable_Helper
     (Unit    : Analysis_Unit;
      Object  : System.Address;
      Destroy : Destroy_Procedure)
   is
   begin
      Destroyable_Vectors.Append (Unit.Destroyables, (Object, Destroy));
   end Register_Destroyable_Helper;


   ----------------
   -- Token_Data --
   ----------------

   function Token_Data (Unit : Analysis_Unit) return Token_Data_Handler_Access
   is (Unit.TDH'Access);

   ----------
   -- Root --
   ----------

   function Root (Unit : Analysis_Unit) return GPR_Node is
     (Unit.AST_Root);

   -----------------
   -- First_Token --
   -----------------

   function First_Token (Unit : Analysis_Unit) return Token_Type is
     (First_Token (Unit.TDH'Access));

   ----------------
   -- Last_Token --
   ----------------

   function Last_Token (Unit : Analysis_Unit) return Token_Type is
     (Last_Token (Unit.TDH'Access));

   -----------------
   -- Token_Count --
   -----------------

   function Token_Count (Unit : Analysis_Unit) return Natural is
     (Unit.TDH.Tokens.Length);

   ------------------
   -- Trivia_Count --
   ------------------

   function Trivia_Count (Unit : Analysis_Unit) return Natural is
     (Unit.TDH.Trivias.Length);

   -----------------
   -- Get_Context --
   -----------------

   function Get_Context (Unit : Analysis_Unit) return Analysis_Context is
     (Unit.Context);

   ------------------
   -- Get_Filename --
   ------------------

   function Get_Filename (Unit : Analysis_Unit) return String is
     (To_String (Unit.File_Name));

   -----------------------
   -- Set_Filled_Caches --
   -----------------------

   procedure Set_Filled_Caches (Unit : Analysis_Unit)
   is
   begin
      Unit.Has_Filled_Caches := True;
   end Set_Filled_Caches;

   --------------
   -- Get_Unit --
   --------------

   function Get_Unit
     (Node : access GPR_Node_Type'Class)
      return Analysis_Unit
   is
   begin
      return Node.Unit;
   end Get_Unit;

   -------------------
   -- Is_Empty_List --
   -------------------

   function Is_Empty_List
     (Node : access GPR_Node_Type) return Boolean
   is (False);

   --------------------
   -- Reference_Unit --
   --------------------

   procedure Reference_Unit (From, Referenced : Analysis_Unit) is
      Dummy : Boolean;
   begin
      Dummy := Analysis_Unit_Sets.Add (From.Referenced_Units, Referenced);
   end Reference_Unit;

   ------------------------
   -- Is_Referenced_From --
   ------------------------

   function Is_Referenced_From
     (Referenced, Unit : Analysis_Unit) return Boolean
   is
   begin
      if Unit = null or else Referenced = null then
         return False;
      elsif Unit = Referenced then
         return True;
      else
         return Analysis_Unit_Sets.Has (Unit.Referenced_Units, Referenced);
      end if;
   end Is_Referenced_From;

   ----------------------
   -- Get_Lex_Env_Data --
   ----------------------

   function Get_Lex_Env_Data
     (Unit : Analysis_Unit) return Lex_Env_Data
   is
   begin
      return Unit.Lex_Env_Data_Acc;
   end Get_Lex_Env_Data;

   ------------------------------
   -- Register_Destroyable_Gen --
   ------------------------------

   procedure Register_Destroyable_Gen
     (Unit : Analysis_Unit; Object : T_Access)
   is
      function Convert is new Ada.Unchecked_Conversion
        (System.Address, Destroy_Procedure);
      procedure Destroy_Procedure (Object : in out T_Access) renames Destroy;
   begin
      Register_Destroyable_Helper
        (Unit,
         Object.all'Address,
         Convert (Destroy_Procedure'Address));
   end Register_Destroyable_Gen;

   ---------------------------
   -- Reset_Property_Caches --
   ---------------------------

   procedure Reset_Property_Caches (Unit : Analysis_Unit) is

      -----------
      -- Visit --
      -----------

      function Visit
        (Node : access GPR_Node_Type'Class)
         return Visit_Status
      is
      begin
         Node.Reset_Property_Caches;
         return Into;
      end Visit;

   begin
      if Unit.Has_Filled_Caches and Unit.AST_Root /= null then
         Unit.AST_Root.Traverse (Visit'Access);
      end if;
      Unit.Has_Filled_Caches := False;
   end Reset_Property_Caches;

   

   

      package Lexical_Env_Vectors is new Langkit_Support.Vectors (Lexical_Env);

   ---------
   -- Get --
   ---------

   function Get
     (T       : Lexical_Env_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Lexical_Env
   is
      function Absolute_Get
        (T : Lexical_Env_Array_Access; Index : Integer)
         return Lexical_Env
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Lexical_Env,
         Sequence_Type => Lexical_Env_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Lexical_Env;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return Empty_Env;
      else
         raise Property_Error with "out-of-bounds array access";
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Lexical_Env_Array_Access) return Lexical_Env_Array_Access is
      use Lexical_Env_Vectors;
      Ret : Lexical_Env_Array_Access := Create (Length (L) + Length (R));
   begin
      Ret.Items := (L.Items & R.Items);
      return Ret;
   end Concat;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Lexical_Env_Array_Access) is
   begin
      T.Ref_Count := T.Ref_Count + 1;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Lexical_Env_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Lexical_Env_Array_Access) is
   begin
      if T = null then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   ------------
   -- Create --
   ------------

   function Create (Items_Count : Natural) return Lexical_Env_Array_Access is
     (new Lexical_Env_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   

   

      package Entity_Vectors is new Langkit_Support.Vectors (Entity);

   ---------
   -- Get --
   ---------

   function Get
     (T       : Entity_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Entity
   is
      function Absolute_Get
        (T : Entity_Array_Access; Index : Integer)
         return Entity
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Entity,
         Sequence_Type => Entity_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Entity;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return No_Entity;
      else
         raise Property_Error with "out-of-bounds array access";
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Entity_Array_Access) return Entity_Array_Access is
      use Entity_Vectors;
      Ret : Entity_Array_Access := Create (Length (L) + Length (R));
   begin
      Ret.Items := (L.Items & R.Items);
      return Ret;
   end Concat;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Entity_Array_Access) is
   begin
      T.Ref_Count := T.Ref_Count + 1;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Entity_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Entity_Array_Access) is
   begin
      if T = null then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   ------------
   -- Create --
   ------------

   function Create (Items_Count : Natural) return Entity_Array_Access is
     (new Entity_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));

   function Create (Items : AST_Envs.Entity_Array) return Entity_Array_Access
   is (new Entity_Array_Record'(N         => Items'Length,
                           Items     => Entity_Array (Items),
                           Ref_Count => 1));


   function Child_Number
     (Node : access GPR_Node_Type'Class)
      return Positive
      with Pre => Node.Parent /= null;
   --  Return the 1-based index for Node in its parents' children

   function Lookup_Internal
     (Node : GPR_Node;
      Sloc : Source_Location;
      Snap : Boolean := False) return GPR_Node;
   procedure Lookup_Relative
     (Node       : GPR_Node;
      Sloc       : Source_Location;
      Position   : out Relative_Position;
      Node_Found : out GPR_Node;
      Snap       : Boolean := False);
   --  Implementation helpers for the looking up process

   -----------------
   -- Set_Parents --
   -----------------

   procedure Set_Parents
     (Node, Parent : access GPR_Node_Type'Class)
   is
   begin
      if Node = null then
         return;
      end if;

      Node.Parent := GPR_Node (Parent);

      for I in 1 .. Node.Child_Count loop
         Set_Parents (Node.Child (I), Node);
      end loop;
   end Set_Parents;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Node : access GPR_Node_Type'Class) is
   begin
      if Node = null then
         return;
      end if;

      Node.Destroy_Node;
      for I in 1 .. Node.Child_Count loop
         Destroy (Node.Child (I));
      end loop;
   end Destroy;

   -----------
   -- Child --
   -----------

   function Child (Node  : access GPR_Node_Type'Class;
                   Index : Positive) return GPR_Node
   is
      Result          : GPR_Node;
      Index_In_Bounds : Boolean;
   begin
      Get_Child (Node, Index, Index_In_Bounds, Result);
      return (if Index_In_Bounds then Result else null);
   end Child;

   --------------
   -- Traverse --
   --------------

   function Traverse
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class)
              return Visit_Status)
     return Visit_Status
   is
      Status : Visit_Status := Into;

   begin
      if Node /= null then
         Status := Visit (Node);

         --  Skip processing the child nodes if the returned status is Over
         --  or Stop. In the former case the previous call to Visit has taken
         --  care of processing the needed childs, and in the latter case we
         --  must immediately stop processing the tree.

         if Status = Into then
            for I in 1 .. Child_Count (Node) loop
               declare
                  Cur_Child : constant GPR_Node :=
                     Child (Node, I);

               begin
                  if Cur_Child /= null then
                     Status := Traverse (Cur_Child, Visit);
                     exit when Status /= Into;
                  end if;
               end;
            end loop;
         end if;
      end if;

      if Status = Stop then
         return Stop;

      --  At this stage the Over status has no sense and we just continue
      --  processing the tree.

      else
         return Into;
      end if;
   end Traverse;

   --------------
   -- Traverse --
   --------------

   procedure Traverse
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class)
                               return Visit_Status)
   is
      Result_Status : Visit_Status;
      pragma Unreferenced (Result_Status);
   begin
      Result_Status := Traverse (Node, Visit);
   end Traverse;

   ------------------------
   -- Traverse_With_Data --
   ------------------------

   function Traverse_With_Data
     (Node  : access GPR_Node_Type'Class;
      Visit : access function (Node : access GPR_Node_Type'Class;
                               Data : in out Data_type)
                               return Visit_Status;
      Data  : in out Data_Type)
      return Visit_Status
   is
      function Helper (Node : access GPR_Node_Type'Class)
                       return Visit_Status;

      ------------
      -- Helper --
      ------------

      function Helper (Node : access GPR_Node_Type'Class)
                       return Visit_Status
      is
      begin
         return Visit (Node, Data);
      end Helper;

      Saved_Data : Data_Type;
      Result     : Visit_Status;

   begin
      if Reset_After_Traversal then
         Saved_Data := Data;
      end if;
      Result := Traverse (Node, Helper'Access);
      if Reset_After_Traversal then
         Data := Saved_Data;
      end if;
      return Result;
   end Traverse_With_Data;

   --------------
   -- Traverse --
   --------------

   function Traverse
     (Root : access GPR_Node_Type'Class)
      return Traverse_Iterator
   is
   begin
      return Create (Root);
   end Traverse;

   ----------------
   -- Get_Parent --
   ----------------

   function Get_Parent
     (N : GPR_Node) return GPR_Node
   is (N.Parent);

   ------------------------------------
   -- First_Child_Index_For_Traverse --
   ------------------------------------

   function First_Child_Index_For_Traverse
     (N : GPR_Node) return Natural
   is (N.First_Child_Index);

   -----------------------------------
   -- Last_Child_Index_For_Traverse --
   -----------------------------------

   function Last_Child_Index_For_Traverse
     (N : GPR_Node) return Natural
   is (N.Last_Child_Index);

   ---------------
   -- Get_Child --
   ---------------

   function Get_Child
     (N : GPR_Node; I : Natural) return GPR_Node
   is (N.Child (I));

   ----------
   -- Next --
   ----------

   function Next (It       : in out Find_Iterator;
                  Element  : out GPR_Node) return Boolean
   is
   begin
      while Next (It.Traverse_It, Element) loop
         if It.Predicate.Evaluate (Element) then
            return True;
         end if;
      end loop;
      return False;
   end Next;

   --------------
   -- Finalize --
   --------------

   overriding procedure Finalize (It : in out Find_Iterator) is
   begin
      Destroy (It.Predicate);
   end Finalize;

   ----------
   -- Next --
   ----------

   overriding function Next
     (It      : in out Local_Find_Iterator;
      Element : out GPR_Node)
      return Boolean
   is
   begin
      while Next (It.Traverse_It, Element) loop
         if It.Predicate (Element) then
            return True;
         end if;
      end loop;
      return False;
   end Next;

   ----------
   -- Find --
   ----------

   function Find
     (Root      : access GPR_Node_Type'Class;
      Predicate : access function (N : GPR_Node) return Boolean)
     return Local_Find_Iterator
   is
      Dummy  : GPR_Node;
      Ignore : Boolean;
   begin
      return Ret : Local_Find_Iterator
        := Local_Find_Iterator'
          (Ada.Finalization.Limited_Controlled with
           Traverse_It => Traverse (Root),

           --  We still want to provide this functionality, even though it is
           --  unsafe. TODO: We might be able to make a safe version of this
           --  using generics. Still would be more verbose though.
           Predicate   => Predicate'Unrestricted_Access.all)
      do
         Ignore := Next (Ret.Traverse_It, Dummy);

      end return;
   end Find;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Self : in out Lex_Env_Data_Type) is
   begin
      Self.Is_Contained_By.Destroy;
      Self.Contains.Destroy;
   end Destroy;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Self : in out Lex_Env_Data) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Lex_Env_Data_Type, Lex_Env_Data);
   begin
      Destroy (Self.all);
      Free (Self);
   end Destroy;

   ----------
   -- Find --
   ----------

   function Find
     (Root      : access GPR_Node_Type'Class;
      Predicate : GPR_Node_Predicate)
      return Find_Iterator
   is
      Dummy  : GPR_Node;
      Ignore : Boolean;
   begin
      return Ret : Find_Iterator :=
        (Ada.Finalization.Limited_Controlled with
         Traverse_It => Traverse (Root),
         Predicate   => Predicate)
      do
         Ignore := Next (Ret.Traverse_It, Dummy);
      end return;
   end Find;

   ----------------
   -- Find_First --
   ----------------

   function Find_First
     (Root      : access GPR_Node_Type'Class;
      Predicate : GPR_Node_Predicate)
      return GPR_Node
   is
      I      : Find_Iterator := Find (Root, Predicate);
      Result : GPR_Node;
      Dummy  : GPR_Node;
      Ignore : Boolean;
   begin
      Ignore := Next (I.Traverse_It, Dummy);
      --  Ignore first result
      if not I.Next (Result) then
         Result := null;
      end if;
      return Result;
   end Find_First;

   --------------
   -- Evaluate --
   --------------

   function Evaluate
     (P : access GPR_Node_Kind_Filter;
      N : GPR_Node)
      return Boolean
   is
   begin
      return N.Kind = P.Kind;
   end Evaluate;

   ----------------
   -- Sloc_Range --
   ----------------

   function Sloc_Range
     (Node : access GPR_Node_Type'Class;
      Snap : Boolean := False) return Source_Location_Range
   is
      TDH                  : Token_Data_Handler renames Node.Unit.TDH;
      Sloc_Start, Sloc_End : Source_Location;

      function Get
        (Index : Token_Index) return Lexer.Token_Data_Type is
        (Get_Token (TDH, Index));

   begin
      if Node.Is_Synthetic then
         return No_Source_Location_Range;
      end if;

      --  Snapping: We'll go one token before the start token, and one token
      --  after the end token, and the sloc range will extend from the end of
      --  the start token to the start of the end token, including any
      --  whitespace and trivia that might be surrounding the node.
      --
      --  TODO: Only nodes we're gonna try to snap are nodes with default
      --  anchors. However, we can make the logic more specific, eg:
      --
      --  * If the start anchor is beginning, then snap the start sloc.
      --
      --  * If the end anchor is ending, then snap the end sloc.
      --
      --  This way composite cases can work too.

      if Snap then
         declare
            Tok_Start : constant Token_Index :=
              Token_Index'Max (Node.Token_Start_Index - 1, 0);
            Tok_End : constant Token_Index :=
              Token_Index'Min (Node.Token_End_Index + 1, Last_Token (TDH));
         begin
            Sloc_Start := End_Sloc (Get (Tok_Start).Sloc_Range);
            Sloc_End := Start_Sloc (Get (Tok_End).Sloc_Range);
         end;
      else
         Sloc_Start := Start_Sloc (Get (Node.Token_Start_Index).Sloc_Range);
         Sloc_End :=
           (if Node.Token_End_Index /= No_Token_Index
            then End_Sloc (Get (Node.Token_End_Index).Sloc_Range)
            else Start_Sloc (Get (Node.Token_Start_Index).Sloc_Range));
      end if;
      return Make_Range (Sloc_Start, Sloc_End);
   end Sloc_Range;

   ------------
   -- Lookup --
   ------------

   function Lookup (Node : access GPR_Node_Type'Class;
                    Sloc : Source_Location;
                    Snap : Boolean := False) return GPR_Node
   is
      Position : Relative_Position;
      Result   : GPR_Node;
   begin
      if Sloc = No_Source_Location then
         return null;
      end if;

      Lookup_Relative
        (GPR_Node (Node), Sloc, Position, Result, Snap);
      return Result;
   end Lookup;

   ---------------------
   -- Lookup_Internal --
   ---------------------

   function Lookup_Internal
     (Node : GPR_Node;
      Sloc : Source_Location;
      Snap : Boolean := False) return GPR_Node
   is
      --  For this implementation helper (i.e. internal primitive), we can
      --  assume that all lookups fall into this node's sloc range.
      pragma Assert (Compare (Sloc_Range (Node, Snap), Sloc) = Inside);

      Children : constant GPR_Node_Array := Node.Children;
      Pos      : Relative_Position;
      Result   : GPR_Node;
   begin
      --  Look for a child node that contains Sloc (i.e. return the most
      --  precise result).

      for Child of Children loop
         --  Note that we assume here that child nodes are ordered so that the
         --  first one has a sloc range that is before the sloc range of the
         --  second child node, etc.

         if Child /= null then
            Lookup_Relative (Child, Sloc, Pos, Result, Snap);
            case Pos is
               when Before =>
                   --  If this is the first node, Sloc is before it, so we can
                   --  stop here.  Otherwise, Sloc is between the previous
                   --  child node and the next one...  so we can stop here,
                   --  too.
                   return Node;

               when Inside =>
                   return Result;

               when After =>
                   --  Sloc is after the current child node, so see with the
                   --  next one.
                   null;
            end case;
         end if;
      end loop;

      --  If we reach this point, we found no children that covers Sloc, but
      --  Node still covers it (see the assertion).
      return Node;
   end Lookup_Internal;

   -------------
   -- Compare --
   -------------

   function Compare (Node : access GPR_Node_Type'Class;
                     Sloc : Source_Location;
                     Snap : Boolean := False) return Relative_Position is
   begin
      return Compare (Sloc_Range (Node, Snap), Sloc);
   end Compare;

   ---------------------
   -- Lookup_Relative --
   ---------------------

   procedure Lookup_Relative
     (Node       : GPR_Node;
      Sloc       : Source_Location;
      Position   : out Relative_Position;
      Node_Found : out GPR_Node;
      Snap       : Boolean := False)
   is
      Result : constant Relative_Position :=
        Compare (Node, Sloc, Snap);
   begin
      Position := Result;
      Node_Found := (if Result = Inside
                     then Lookup_Internal (Node, Sloc, Snap)
                     else null);
   end Lookup_Relative;

   -------------------
   -- Get_Extension --
   -------------------

   function Get_Extension
     (Node : access GPR_Node_Type'Class;
      ID   : Extension_ID;
      Dtor : Extension_Destructor) return Extension_Access
   is
      use Extension_Vectors;
   begin
      for Slot of Node.Extensions loop
         if Slot.ID = ID then
            return Slot.Extension;
         end if;
      end loop;

      declare
         New_Ext : constant Extension_Access :=
           new Extension_Type'(Extension_Type (System.Null_Address));
      begin
         Append (Node.Extensions,
                 Extension_Slot'(ID        => ID,
                                 Extension => New_Ext,
                                 Dtor      => Dtor));
         return New_Ext;
      end;
   end Get_Extension;

   ---------------------
   -- Free_Extensions --
   ---------------------

   procedure Free_Extensions (Node : access GPR_Node_Type'Class) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Extension_Type, Extension_Access);
      use Extension_Vectors;
      Slot : Extension_Slot;
   begin
      --  Explicit iteration for perf
      for J in First_Index (Node.Extensions) .. Last_Index (Node.Extensions)
      loop
         Slot := Get (Node.Extensions, J);
         Slot.Dtor (Node, Slot.Extension.all);
         Free (Slot.Extension);
      end loop;
   end Free_Extensions;

   --------------
   -- Children --
   --------------

   function Children
     (Node : access GPR_Node_Type'Class)
     return GPR_Node_Array
   is
      First : constant Integer
        := GPR_Node_Vectors.Index_Type'First;
      Last  : constant Integer := First + Child_Count (Node) - 1;
   begin
      return A : GPR_Node_Array (First .. Last)
      do
         for I in First .. Last loop
            A (I) := Child (Node, I);
         end loop;
      end return;
   end Children;

   function Children
     (Node : access GPR_Node_Type'Class)
     return GPR_Node_Array_Access
   is
      C : GPR_Node_Array := Children (Node);
   begin
      return Ret : GPR_Node_Array_Access := Create (C'Length) do
         Ret.Items := C;
      end return;
   end Children;

   -----------------
   -- First_Token --
   -----------------

   function First_Token (TDH : Token_Data_Handler_Access) return Token_Type is
      use Token_Vectors, Trivia_Vectors, Integer_Vectors;
   begin
      if Length (TDH.Tokens_To_Trivias) = 0
         or else (First_Element (TDH.Tokens_To_Trivias)
                  = Integer (No_Token_Index))
      then
         --  There is no leading trivia: return the first token

         return (if Length (TDH.Tokens) = 0
                 then No_Token
                 else (TDH,
                       Token_Index (First_Index (TDH.Tokens)),
                       No_Token_Index));

      else
         return (TDH, No_Token_Index, Token_Index (First_Index (TDH.Trivias)));
      end if;
   end First_Token;

   ----------------
   -- Last_Token --
   ----------------

   function Last_Token (TDH : Token_Data_Handler_Access) return Token_Type is
      use Token_Vectors, Trivia_Vectors, Integer_Vectors;
   begin
      if Length (TDH.Tokens_To_Trivias) = 0
           or else
         Last_Element (TDH.Tokens_To_Trivias) = Integer (No_Token_Index)
      then
         --  There is no trailing trivia: return the last token

         return (if Length (TDH.Tokens) = 0
                 then No_Token
                 else (TDH,
                       Token_Index (Last_Index (TDH.Tokens)),
                       No_Token_Index));

      else
         return (TDH, No_Token_Index, Token_Index (First_Index (TDH.Trivias)));
      end if;
   end Last_Token;

   ---------
   -- "<" --
   ---------

   function "<" (Left, Right : Token_Type) return Boolean is
      pragma Assert (Left.TDH = Right.TDH);
   begin
      if Left.Token < Right.Token then
         return True;

      elsif Left.Token = Right.Token then
         return Left.Trivia < Right.Trivia;

      else
         return False;
      end if;
   end "<";

   ----------
   -- Next --
   ----------

   function Next (Token : Token_Type) return Token_Type is
   begin
      if Token.TDH = null then
         return No_Token;
      end if;

      declare
         use Token_Vectors, Trivia_Vectors, Integer_Vectors;
         TDH : Token_Data_Handler renames Token.TDH.all;

         function Next_Token return Token_Type is
           (if Token.Token < Token_Index (Last_Index (TDH.Tokens))
            then (Token.TDH, Token.Token + 1, No_Token_Index)
            else No_Token);
         --  Return a reference to the next token (not trivia) or No_Token if
         --  Token was the last one.

      begin
         if Token.Trivia /= No_Token_Index then
            --  Token is a reference to a trivia: take the next trivia if it
            --  exists, or escalate to the next token otherwise.

            declare
               Tr : constant Trivia_Node :=
                  Get (TDH.Trivias, Natural (Token.Trivia));
            begin
               return (if Tr.Has_Next
                       then (Token.TDH, Token.Token, Token.Trivia + 1)
                       else Next_Token);
            end;

         else
            --  Thanks to the guard above, we cannot get to the declare block
            --  for the No_Token case, so if Token does not refers to a trivia,
            --  it must be a token.

            pragma Assert (Token.Token /= No_Token_Index);

            --  If there is no trivia, just go to the next token

            if Length (TDH.Tokens_To_Trivias) = 0 then
               return Next_Token;
            end if;

            --  If this token has trivia, return a reference to the first one,
            --  otherwise get the next token.

            declare
               Tr_Index : constant Token_Index := Token_Index
                 (Get (TDH.Tokens_To_Trivias, Natural (Token.Token) + 1));
            begin
               return (if Tr_Index = No_Token_Index
                       then Next_Token
                       else (Token.TDH, Token.Token, Tr_Index));
            end;
         end if;
      end;
   end Next;

   --------------
   -- Previous --
   --------------

   function Previous (Token : Token_Type) return Token_Type is
   begin
      if Token.TDH = null then
         return No_Token;
      end if;

      declare
         use Token_Vectors, Trivia_Vectors, Integer_Vectors;
         TDH : Token_Data_Handler renames Token.TDH.all;
      begin
         if Token.Trivia = No_Token_Index then
            --  Token is a regular token, so the previous token is either the
            --  last trivia of the previous regular token, either the previous
            --  regular token itself.
            declare
               Prev_Trivia : Token_Index;
            begin
               --  Get the index of the trivia that is right bofre Token (if
               --  any).
               if Length (TDH.Tokens_To_Trivias) = 0 then
                  Prev_Trivia := No_Token_Index;

               else
                  Prev_Trivia := Token_Index
                    (Get (TDH.Tokens_To_Trivias, Natural (Token.Token)));
                  while Prev_Trivia /= No_Token_Index
                           and then
                        Get (TDH.Trivias, Natural (Prev_Trivia)).Has_Next
                  loop
                     Prev_Trivia := Prev_Trivia + 1;
                  end loop;
               end if;

               --  If there is no such trivia and Token was the first one, then
               --  this was the start of the token stream: no previous token.
               if Prev_Trivia = No_Token_Index
                  and then Token.Token <= First_Token_Index
               then
                  return No_Token;
               else
                  return (Token.TDH, Token.Token - 1, Prev_Trivia);
               end if;
            end;

         --  Past this point: Token is known to be a trivia

         elsif Token.Trivia = First_Token_Index then
            --  This is the first trivia for some token, so the previous token
            --  cannot be a trivia.
            return (if Token.Token = No_Token_Index
                    then No_Token
                    else (Token.TDH, Token.Token, No_Token_Index));

         elsif Token.Token = No_Token_Index then
            --  This is a leading trivia and not the first one, so the previous
            --  token has to be a trivia.
            return (Token.TDH, No_Token_Index, Token.Trivia - 1);

         --  Past this point: Token is known to be a trivia *and* it is not a
         --  leading trivia.

         else
            return (Token.TDH,
                    Token.Token,
                    (if Get (TDH.Trivias, Natural (Token.Trivia - 1)).Has_Next
                     then Token.Trivia - 1
                     else No_Token_Index));
         end if;
      end;
   end Previous;

   ----------------
   -- Get_Symbol --
   ----------------

   function Get_Symbol (Token : Token_Type) return Symbol_Type is
      subtype Token_Data_Reference is
         Token_Data_Handlers.Token_Vectors.Element_Access;

      Token_Data : constant Token_Data_Reference :=
        (if Token.Trivia = No_Token_Index
         then Token_Data_Reference
           (Token.TDH.Tokens.Get_Access (Natural (Token.Token)))
         else Token_Data_Reference'
           (Token.TDH.Trivias.Get_Access
              (Natural (Token.Trivia) - 1).T'Access));
   begin
      return Force_Symbol (Token.TDH.all, Token_Data.all);
   end Get_Symbol;

   -----------------
   -- First_Token --
   -----------------

   function First_Token (Self : Token_Iterator) return Token_Type
   is (Self.Node.Token_Start);

   ----------------
   -- Next_Token --
   ----------------

   function Next_Token
     (Self : Token_Iterator; Tok : Token_Type) return Token_Type
   is (Next (Tok));

   -----------------
   -- Has_Element --
   -----------------

   function Has_Element
     (Self : Token_Iterator; Tok : Token_Type) return Boolean
   is (Tok.Token <= Self.Last);

   -------------
   -- Element --
   -------------

   function Element (Self : Token_Iterator; Tok : Token_Type) return Token_Type
   is (Tok);

   -----------------
   -- Token_Range --
   -----------------

   function Token_Range
     (Node : access GPR_Node_Type'Class)
      return Token_Iterator
   is
     (Token_Iterator'(GPR_Node (Node), Node.Token_End_Index));

   --------------
   -- Raw_Data --
   --------------

   function Raw_Data (T : Token_Type) return Lexer.Token_Data_Type is
     (if T.Trivia = No_Token_Index
      then Token_Vectors.Get (T.TDH.Tokens, Natural (T.Token))
      else Trivia_Vectors.Get (T.TDH.Trivias, Natural (T.Trivia)).T);

   -------------
   -- Convert --
   -------------

   function Convert
     (TDH      : Token_Data_Handler;
      Token    : Token_Type;
      Raw_Data : Lexer.Token_Data_Type) return Token_Data_Type is
   begin
      return (Kind          => Raw_Data.Kind,
              Is_Trivia     => Token.Trivia /= No_Token_Index,
              Index         => (if Token.Trivia = No_Token_Index
                                then Token.Token
                                else Token.Trivia),
              Source_Buffer => Text_Cst_Access (TDH.Source_Buffer),
              Source_First  => Raw_Data.Source_First,
              Source_Last   => Raw_Data.Source_Last,
              Sloc_Range    => Raw_Data.Sloc_Range);
   end Convert;

   ----------
   -- Data --
   ----------

   function Data (Token : Token_Type) return Token_Data_Type is
   begin
      return Convert (Token.TDH.all, Token, Raw_Data (Token));
   end Data;

   ----------
   -- Text --
   ----------

   function Text (Token : Token_Type) return Text_Type is
      RD : constant Lexer.Token_Data_Type := Raw_Data (Token);
   begin
      return Token.TDH.Source_Buffer (RD.Source_First .. RD.Source_Last);
   end Text;

   ----------
   -- Text --
   ----------

   function Text (First, Last : Token_Type) return Text_Type is
      FD : constant Token_Data_Type := Data (First);
      LD : constant Token_Data_Type := Data (Last);
   begin
      if First.TDH /= Last.TDH then
         raise Constraint_Error;
      end if;
      return FD.Source_Buffer.all (FD.Source_First .. LD.Source_Last);
   end Text;

   ----------
   -- Text --
   ----------

   function Text (Token : Token_Type) return String
   is (Image (Text (Token)));

   ----------
   -- Kind --
   ----------

   function Kind (Token_Data : Token_Data_Type) return Token_Kind is
   begin
      return Token_Data.Kind;
   end Kind;

   ---------------
   -- Is_Trivia --
   ---------------

   function Is_Trivia (Token_Data : Token_Data_Type) return Boolean is
   begin
      return Token_Data.Is_Trivia;
   end Is_Trivia;

   -----------
   -- Index --
   -----------

   function Index (Token_Data : Token_Data_Type) return Token_Index is
   begin
      return Token_Data.Index;
   end Index;

   ----------------
   -- Sloc_Range --
   ----------------

   function Sloc_Range
     (Token_Data : Token_Data_Type) return Source_Location_Range
   is
   begin
      return Token_Data.Sloc_Range;
   end Sloc_Range;

   ----------
   -- Text --
   ----------

   function Text
     (Node : access GPR_Node_Type'Class) return Text_Type is
   begin
      return Text (Node.Token_Start, Node.Token_End);
   end Text;

   -------------------
   -- Is_Equivalent --
   -------------------

   function Is_Equivalent (L, R : Token_Type) return Boolean is
      DL : constant Token_Data_Type := Data (L);
      DR : constant Token_Data_Type := Data (R);
      TL : constant Text_Type := Text (L);
      TR : constant Text_Type := Text (R);
   begin
      return DL.Kind = DR.Kind and then TL = TR;
   end Is_Equivalent;

   -----------
   -- Image --
   -----------

   function Image (Token : Token_Type) return String is
      D : constant Token_Data_Type := Data (Token);
   begin
      return ("<Token Kind=" & Token_Kind_Name (D.Kind) &
              " Text=" & Image (Text (Token), With_Quotes => True) & ">");
   end Image;

   --------------------------
   -- Children_With_Trivia --
   --------------------------

   function Children_With_Trivia
     (Node : access GPR_Node_Type'Class) return Children_Array
   is
      package Children_Vectors is new Langkit_Support.Vectors (Child_Record);
      use Children_Vectors;

      Ret_Vec : Children_Vectors.Vector;
      TDH     : Token_Data_Handler renames Node.Unit.TDH;

      procedure Append_Trivias (First, Last : Token_Index);
      --  Append all the trivias of tokens between indices First and Last to
      --  the returned vector.

      procedure Append_Trivias (First, Last : Token_Index) is
      begin
         for I in First .. Last loop
            for D of Get_Trivias (TDH, I) loop
               Append (Ret_Vec, (Kind   => Trivia,
                                 Trivia => (TDH    => Node.Unit.TDH'Access,
                                            Token  => I,
                                            Trivia => D)));
            end loop;
         end loop;
      end Append_Trivias;

      function Filter_Children (N : GPR_Node) return Boolean is
         --  Get rid of null nodes
        (N /= null
         --  Get rid of nodes with no real existence in the source code
         and then not N.Is_Ghost);

      First_Child : constant GPR_Node_Vectors.Index_Type :=
         GPR_Node_Vectors.Index_Type'First;
      N_Children  : constant GPR_Node_Array
        := GPR_Node_Array
             (GPR_Node_Arrays.Filter
              (GPR_Node_Vectors.Elements_Array
                (GPR_Node_Array'(Children (Node))),
               Filter_Children'Access));
   begin
      if N_Children'Length > 0
        and then (Node.Token_Start_Index
                    /= N_Children (First_Child).Token_Start_Index)
      then
         Append_Trivias (Node.Token_Start_Index,
                         N_Children (First_Child).Token_Start_Index - 1);
      end if;

      for I in N_Children'Range loop
         Append (Ret_Vec, Child_Record'(Child, N_Children (I)));
         Append_Trivias (N_Children (I).Token_End_Index,
                         (if I = N_Children'Last
                          then Node.Token_End_Index - 1
                          else N_Children (I + 1).Token_Start_Index - 1));
      end loop;

      return A : constant Children_Array :=
         Children_Array (To_Array (Ret_Vec))
      do
         --  Don't forget to free Ret_Vec, since its memory is not
         --  automatically managed.
         Destroy (Ret_Vec);
      end return;
   end Children_With_Trivia;

   ---------------
   -- PP_Trivia --
   ---------------

   procedure PP_Trivia
     (Node        : access GPR_Node_Type'Class;
      Line_Prefix : String := "")
   is
      Children_Prefix : constant String := Line_Prefix & "|  ";
   begin
      Put_Line (Line_Prefix & Kind_Name (Node));
      for C of Children_With_Trivia (Node) loop
         case C.Kind is
            when Trivia =>
               Put_Line (Children_Prefix & Text (C.Trivia));
            when Child =>
               C.Node.PP_Trivia (Children_Prefix);
         end case;
      end loop;
   end PP_Trivia;

   --------------------------
   -- Populate_Lexical_Env --
   --------------------------

   procedure Populate_Lexical_Env
     (Node     : access GPR_Node_Type'Class;
      Root_Env : AST_Envs.Lexical_Env)
   is

      procedure Populate_Internal
        (Node      : access GPR_Node_Type'Class;
         Bound_Env : Lexical_Env);

      -----------------------
      -- Populate_Internal --
      -----------------------

      procedure Populate_Internal
        (Node      : access GPR_Node_Type'Class;
         Bound_Env : Lexical_Env)
      is
         Initial_Env : Lexical_Env;
      begin
         if Node = null then
            return;
         end if;

         --  By default (i.e. unless env actions add a new env),
         --  the environment we store in Node is the current one.
         Node.Self_Env := Bound_Env;

         Initial_Env := Node.Pre_Env_Actions (Bound_Env, Root_Env);

         --  Call recursively on children
         for C of GPR_Node_Array'(Children (Node)) loop
            Populate_Internal (C, Node.Self_Env);
         end loop;

         Node.Post_Env_Actions (Initial_Env, Root_Env);
      end Populate_Internal;

      Env : AST_Envs.Lexical_Env := Root_Env;
   begin
      Populate_Internal (Node, Env);
   end Populate_Lexical_Env;

   -------------------------------
   -- Node_File_And_Sloc_Image  --
   -------------------------------

   function Node_File_And_Sloc_Image
     (Node : GPR_Node) return Text_Type
   is (To_Text (To_String (Node.Unit.File_Name))
       & ":" & To_Text (Image (Start_Sloc (Sloc_Range (Node)))));

   -----------------
   -- Short_Image --
   -----------------

   function Short_Image
     (Node : access GPR_Node_Type)
      return Text_Type
   is
      Self : access GPR_Node_Type'Class := Node;
   begin
      return "<" & To_Text (Kind_Name (Self))
             & " " & To_Text (Image (Sloc_Range (Node))) & ">";
   end Short_Image;

   -----------------
   -- Sorted_Envs --
   -----------------

   --  Those ordered maps are used to have a stable representation of internal
   --  lexical environments, which is not the case with hashed maps.

   function "<" (L, R : Symbol_Type) return Boolean
   is
     (L.all < R.all);

   package Sorted_Envs is new Ada.Containers.Ordered_Maps
     (Symbol_Type,
      Element_Type    => AST_Envs.Internal_Map_Element_Vectors.Vector,
      "<"             => "<",
      "="             => AST_Envs.Internal_Map_Element_Vectors."=");

   -------------------
   -- To_Sorted_Env --
   -------------------

   function To_Sorted_Env (Env : Internal_Envs.Map) return Sorted_Envs.Map is
      Ret_Env : Sorted_Envs.Map;
      use Internal_Envs;
   begin
      for El in Env.Iterate loop
         Ret_Env.Include (Key (El), Element (El));
      end loop;
      return Ret_Env;
   end To_Sorted_Env;

   ----------------
   -- Get_Env_Id --
   ----------------

   function Get_Env_Id
     (E : Lexical_Env; State : in out Dump_Lexical_Env_State) return String
   is
      C        : Address_To_Id_Maps.Cursor;
      Inserted : Boolean;
   begin
      if E = null then
         return "$null";

      elsif E = State.Root_Env then
         --  Insert root env with a special Id so that we only print it once
         State.Env_Ids.Insert (E, -1, C, Inserted);
         return "$root";
      end if;

      State.Env_Ids.Insert (E, State.Next_Id, C, Inserted);
      if Inserted then
         State.Next_Id := State.Next_Id + 1;
      end if;

      return '@' & Stripped_Image (Address_To_Id_Maps.Element (C));
   end Get_Env_Id;

   ----------
   -- Dump --
   ----------

   procedure Dump_One_Lexical_Env
     (Self           : AST_Envs.Lexical_Env;
      Env_Id         : String := "";
      Parent_Env_Id  : String := "";
      Dump_Addresses : Boolean := False;
      Dump_Content   : Boolean := True)
   is
      use Sorted_Envs;

      function Short_Image
        (N : access GPR_Node_Type'Class) return String
      is (if N = null then "<null>" else Image (N.Short_Image));
      -- TODO??? This is slightly hackish, because we're converting a wide
      -- string back to string. But since we're using this solely for
      -- test/debug purposes, it should not matter. Still, would be good to
      -- have Text_Type everywhere at some point.

      function Image (El : Internal_Map_Element) return String is
        (Short_Image (El.Element));

      function Image is new AST_Envs.Internal_Map_Element_Vectors.Image
        (Image);

      First_Arg : Boolean := True;

      procedure New_Arg is
      begin
         if First_Arg then
            First_Arg := False;
         else
            Put (", ");
         end if;
      end New_Arg;

      ---------------------
      -- Dump_Referenced --
      ---------------------

      procedure Dump_Referenced
        (Name : String; Refs : AST_Envs.Referenced_Envs_Vectors.Vector)
      is
         Is_First : Boolean := True;
      begin
         for R of Refs loop
            declare
               Env : constant Lexical_Env := Get_Refd_Env (R);
            begin
               if Env /= Empty_Env then
                  if Is_First then
                     Put_Line ("    " & Name & ":");
                     Is_First := False;
                  end if;
                  Put ("      ");
                  Put (Short_Image (R.From_Node) & ": ");

                  Dump_One_Lexical_Env (Self           => Env,
                                        Dump_Addresses => Dump_Addresses,
                                        Dump_Content   => False);
                  New_Line;
               end if;
            end;
         end loop;
      end Dump_Referenced;

   begin
      if Env_Id'Length /= 0 then
         Put (Env_Id & " = ");
      end if;
      Put ("LexEnv(");
      if Self = Empty_Env then
         New_Arg;
         Put ("Empty");
      end if;
      if Self.Ref_Count /= AST_Envs.No_Refcount then
         New_Arg;
         Put ("Synthetic");
      end if;
      if Parent_Env_Id'Length > 0 then
         New_Arg;
         Put ("Parent=" & (if Self.Parent /= AST_Envs.No_Env_Getter
                           then Parent_Env_Id else "null"));
      end if;
      if Self.Node /= null then
         New_Arg;
         Put ("Node=" & Image (Self.Node.Short_Image));
      end if;
      if Dump_Addresses then
         New_Arg;
         Put ("0x" & System.Address_Image (Self.all'Address));
      end if;
      Put (")");
      if not Dump_Content then
         return;
      end if;
      Put_Line (":");

      Dump_Referenced ("Referenced", Self.Referenced_Envs);

      if Self.Env = null then
         Put_Line ("    <null>");
      elsif Self.Env.Is_Empty then
         Put_Line ("    <empty>");
      else
         for El in To_Sorted_Env (Self.Env.all).Iterate loop
            Put ("    ");
            Put_Line (Langkit_Support.Text.Image (Key (El).all) & ": "
                 & Image (Element (El)));
         end loop;
      end if;
      New_Line;
   end Dump_One_Lexical_Env;

   ----------------------
   -- Dump_Lexical_Env --
   ----------------------

   procedure Dump_Lexical_Env
     (Node     : access GPR_Node_Type'Class;
      Root_Env : AST_Envs.Lexical_Env)
   is
      State : Dump_Lexical_Env_State := (Root_Env => Root_Env, others => <>);

      --------------------------
      -- Explore_Parent_Chain --
      --------------------------

      procedure Explore_Parent_Chain (Env : Lexical_Env) is
      begin
         if Env /= null then
            Dump_One_Lexical_Env
              (Env, Get_Env_Id (Env, State),
               Get_Env_Id (AST_Envs.Get_Env (Env.Parent), State));
            Explore_Parent_Chain (AST_Envs.Get_Env (Env.Parent));
         end if;
      end Explore_Parent_Chain;

      --------------
      -- Internal --
      --------------

      procedure Internal (Current : GPR_Node) is
         Explore_Parent : Boolean := False;
         Env, Parent    : Lexical_Env;
      begin
         if Current = null then
            return;
         end if;

         --  We only dump environments that we haven't dumped before. This way
         --  we'll only dump environments at the site of their creation, and
         --  not in any subsequent link. We use the Env_Ids map to check which
         --  envs we have already seen or not.
         if not State.Env_Ids.Contains (Current.Self_Env) then
            Env := Current.Self_Env;
            Parent := Ast_Envs.Get_Env (Env.Parent);
            Explore_Parent := not State.Env_Ids.Contains (Parent);

            Dump_One_Lexical_Env
              (Env, Get_Env_Id (Env, State), Get_Env_Id (Parent, State));

            if Explore_Parent then
               Explore_Parent_Chain (Parent);
            end if;
         end if;

         for Child of GPR_Node_Array'(Children (Current)) loop
            Internal (Child);
         end loop;
      end Internal;
      --  This procedure implements the main recursive logic of dumping the
      --  environments.
   begin
      Internal (GPR_Node (Node));
   end Dump_Lexical_Env;

   -----------------------------------
   -- Dump_Lexical_Env_Parent_Chain --
   -----------------------------------

   procedure Dump_Lexical_Env_Parent_Chain (Env : AST_Envs.Lexical_Env) is
      Id : Positive := 1;
      E  : Lexical_Env := Env;
   begin
      if E = null then
         Put_Line ("<null>");
      end if;

      while E /= null loop
         declare
            Id_Str : constant String := '@' & Stripped_Image (Id);
         begin
            if E = null then
               Put_Line (Id_Str & " = <null>");
            else
               Dump_One_Lexical_Env
                 (Self           => E,
                  Env_Id         => Id_Str,
                  Parent_Env_Id  => '@' & Stripped_Image (Id + 1),
                  Dump_Addresses => True);
            end if;
         end;
         Id := Id + 1;
         E := AST_Envs.Get_Env (E.Parent);
      end loop;
   end Dump_Lexical_Env_Parent_Chain;

   -------------
   -- Parents --
   -------------

   function Parents
     (Node         : access GPR_Node_Type'Class;
      Include_Self : Boolean := True)
      return GPR_Node_Array_Access
   is
      Count : Natural := 0;
      Start : GPR_Node :=
        GPR_Node (if Include_Self then Node else Node.Parent);
      Cur   : GPR_Node := Start;
   begin
      while Cur /= null loop
         Count := Count + 1;
         Cur := Cur.Parent;
      end loop;

      declare
         Result : constant GPR_Node_Array_Access := Create (Count);
      begin
         Cur := Start;
         for I in Result.Items'Range loop
            Result.Items (I) := Cur;
            Cur := Cur.Parent;
         end loop;
         return Result;
      end;
   end Parents;

   -----------------------
   -- First_Child_Index --
   -----------------------

   function First_Child_Index
     (Node : access GPR_Node_Type'Class) return Natural
   is (1);

   ----------------------
   -- Last_Child_Index --
   ----------------------

   function Last_Child_Index
     (Node : access GPR_Node_Type'Class) return Natural
   is (Node.Child_Count);

   ------------
   -- Parent --
   ------------

   function Parent
     (Node : access GPR_Node_Type'Class) return GPR_Node
   is
   begin
      return Node.Parent;
   end Parent;

   ------------------
   -- Stored_Token --
   ------------------

   function Stored_Token
     (Node  : access GPR_Node_Type'Class;
      Token : Token_Type)
      return Token_Index
   is
   begin
      if Node.Unit.TDH'Access /= Token.TDH then
         raise Property_Error with
           ("Cannot associate a token and a node from different analysis"
            & " units");
      elsif Token.Trivia /= No_Token_Index then
         raise Property_Error with
           ("A node cannot hold trivia");
      end if;

      return Token.Token;
   end Stored_Token;

   --------------
   -- Is_Ghost --
   --------------

   function Is_Ghost
     (Node : access GPR_Node_Type'Class) return Boolean
   is (Node.Token_End_Index = No_Token_Index);

   ------------------
   -- Is_Synthetic --
   ------------------

   function Is_Synthetic
     (Node : access GPR_Node_Type'Class) return Boolean
   is (Node.Token_Start_Index = No_Token_Index);

   -----------------
   -- Token_Start --
   -----------------

   function Token_Start
     (Node : access GPR_Node_Type'Class)
      return Token_Type
   is (Node.Token (Node.Token_Start_Index));

   ---------------
   -- Token_End --
   ---------------

   function Token_End
     (Node : access GPR_Node_Type'Class)
      return Token_Type
   is
     (if Node.Token_End_Index = No_Token_Index
      then Node.Token_Start
      else Node.Token (Node.Token_End_Index));

   -----------
   -- Token --
   -----------

   function Token
     (Node  : access GPR_Node_Type'Class;
      Index : Token_Index) return Token_Type
   is
     (if Index = No_Token_Index
      then No_Token
      else (TDH    => Token_Data (Node.Unit),
            Token  => Index,
            Trivia => No_Token_Index));

   -------------
   -- Is_Null --
   -------------

   function Is_Null
     (Node : access GPR_Node_Type'Class) return Boolean
   is (Node = null);

   ------------------
   -- Child_Number --
   ------------------

   function Child_Number
     (Node : access GPR_Node_Type'Class)
      return Positive
   is
      N : GPR_Node := null;
   begin
      for I in Node.Parent.First_Child_Index .. Node.Parent.Last_Child_Index
      loop
         N := Child (Node.Parent, I);
         if N = Node then
            return I;
         end if;
      end loop;

      --  If we reach this point, then Node isn't a Child of Node.Parent. This
      --  is not supposed to happen.
      raise Program_Error;
   end Child_Number;

   ----------------------
   -- Previous_Sibling --
   ----------------------

   function Previous_Sibling
     (Node : access GPR_Node_Type'Class)
     return GPR_Node
   is
      N : constant Positive := Child_Number (Node);
   begin
      return (if N = 1
              then null
              else Node.Parent.Child (N - 1));
   end Previous_Sibling;

   ------------------
   -- Next_Sibling --
   ------------------

   function Next_Sibling
     (Node : access GPR_Node_Type'Class)
     return GPR_Node
   is
   begin
      --  If Node is the last sibling, then Child will return null
      return Node.Parent.Child (Child_Number (Node) + 1);
   end Next_Sibling;


   

   





   -------------
   -- Combine --
   -------------

   function Combine
     (L, R : Metadata) return Metadata
   is
      pragma Unreferenced (L, R);
      Ret : Metadata := No_Metadata;
   begin
      return Ret;
   end Combine;

   ---------
   -- Get --
   ---------

   function Get
     (A     : AST_Envs.Entity_Array;
      Index : Integer)
      return Entity
   is
      function Length (A : AST_Envs.Entity_Array) return Natural
      is (A'Length);

      function Get
        (A     : AST_Envs.Entity_Array;
         Index : Integer)
         return Entity
      is (A (Index + 1)); --  A is 1-based but Index is 0-based

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Entity,
         Sequence_Type => AST_Envs.Entity_Array,
         Length        => Length,
         Get           => Get);
      Result : Entity;
   begin
      if Relative_Get (A, Index, Result) then
         return Result;
      else
         raise Property_Error with "out-of-bounds array access";
      end if;
   end Get;

   -----------
   -- Group --
   -----------

   function Group
     (Envs : Lexical_Env_Array_Access)
      return Lexical_Env
   is (Group (Envs.Items));

       

   

      --
      --  Private and non-dispatching primitives for GPR_Node
      --

         



 function Children_Env
   
  (Node :
   access GPR_Node_Type'Class

      ; E_Info : Entity_Info
         := No_Entity_Info
  )

   return Lexical_Env
   ;
--  For nodes that introduce a new environment, return it. Return the
--  "inherited" environment otherwise.






       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   




       

   





   ------------------
   -- Children_Env --
   ------------------

   function Children_Env
     (Node : access GPR_Node_Type'Class;
      E_Info : Entity_Info := No_Entity_Info) return Lexical_Env
   is (Rebind_Env (Node.Self_Env, E_Info));

   --------------
   -- Node_Env --
   --------------

   function Node_Env
     (Node : access GPR_Node_Type;
      E_Info : Entity_Info := No_Entity_Info) return AST_Envs.Lexical_Env
   is (Rebind_Env (Node.Self_Env, E_Info));

   








   








   








   









   --------------------------------
   -- Assign_Names_To_Logic_Vars --
   --------------------------------

   procedure Assign_Names_To_Logic_Vars
    (Node : access GPR_Node_Type'Class) is
   begin
      Assign_Names_To_Logic_Vars_Impl (Node);
      for Child of GPR_Node_Array'(Children (Node)) loop
         if Child /= null then
            Assign_Names_To_Logic_Vars (Child);
         end if;
      end loop;
   end Assign_Names_To_Logic_Vars;

   -----------
   -- Image --
   -----------

   function Image (N : Entity) return String is
   begin
      if N.El /= null then
         declare
            Node_Image : String := Image (N.El.Short_Image);
         begin
            return
            (if N.Info.Rebindings /= null
             then "<| "
             & Node_Image (Node_Image'First + 1 .. Node_Image'Last -1) & " "
             & Image (AST_Envs.Image (N.Info.Rebindings)) & " |>"
             else Node_Image);
         end;
      else
         return "None";
      end if;
   end Image;

   ---------------
   -- Can_Reach --
   ---------------

   function Can_Reach (El, From : GPR_Node) return Boolean
   is
   begin
      --  Since this function is only used to implement sequential semantics in
      --  envs, we consider that elements coming from different units are
      --  always visible for each other, and let the user implement language
      --  specific visibility rules in the DSL.
      if El.Unit /= From.Unit then
         return True;
      end if;

       return Compare
         (Start_Sloc (Sloc_Range (El)),
          Start_Sloc (Sloc_Range (From))) = After;
   end Can_Reach;

   ------------
   -- Create --
   ------------

   function Create
      (El : GPR_Node; Info : Entity_Info)
       return Entity is
    begin
      Inc_Ref (Info.Rebindings);
      return (El => El, Info => Info);
    end Create;

   procedure Register_Destroyable is new Register_Destroyable_Gen
     (AST_Envs.Lexical_Env_Type, AST_Envs.Lexical_Env, AST_Envs.Destroy);

   pragma Warnings (Off, "referenced");
   procedure Register_Destroyable
     (Unit : Analysis_Unit; Node : GPR_Node);
   --  Helper for synthetized nodes. We cannot used the generic
   --  Register_Destroyable because the root AST node is an abstract types, so
   --  this is implemented using the untyped (using System.Address)
   --  implementation helper.
   pragma Warnings (Off, "referenced");

   procedure Destroy_Synthetic_Node (Node : in out GPR_Node);
   --  Helper for the Register_Destroyable above

   function Get_Lex_Env_Data
     (Node : access GPR_Node_Type'Class) return Lex_Env_Data
   is (GPR_Parser.Analysis.Get_Lex_Env_Data (Node.Unit));

   -----------
   -- Image --
   -----------

   overriding function Image
     (Node : access Base_List_Type) return String
   is
      Result : Unbounded_String;
   begin
      Append (Result, '[');
      for Child of Node.Nodes (1 .. Node.Count) loop
         if Length (Result) > 0 then
            Append (Result, ", ");
         end if;
         Append (Result, Child.Image);
      end loop;

      Append (Result, ']');
      return To_String (Result);
   end Image;

   -----------------
   -- Child_Count --
   -----------------

   overriding function Child_Count
     (Node : access Base_List_Type) return Natural
   is
   begin
      return Node.Count;
   end Child_Count;

   ---------------
   -- Get_Child --
   ---------------

   overriding procedure Get_Child
     (Node            : access Base_List_Type;
      Index           : Positive;
      Index_In_Bounds : out Boolean;
      Result          : out GPR_Node) is
   begin
      if Index > Node.Count then
         Index_In_Bounds := False;
      else
         Index_In_Bounds := True;
         Result := Node.Nodes (Index);
      end if;
   end Get_Child;

   -----------
   -- Print --
   -----------

   overriding procedure Print
     (Node : access Base_List_Type; Line_Prefix : String := "")
   is
      Class_Wide_Node : constant GPR_Node :=
         GPR_Node (Node);
   begin
      Put
        (Line_Prefix & Class_Wide_Node.Kind_Name
         & "[" & Image (Node.Sloc_Range) & "]");
      if Node.Count = 0 then
         Put_Line (": <empty list>");
         return;
      end if;

      New_Line;
      for Child of Node.Nodes (1 .. Node.Count) loop
         if Child /= null then
            Child.Print (Line_Prefix & "|  ");
         end if;
      end loop;
   end Print;

   -------------------
   -- Is_Empty_List --
   -------------------

   overriding function Is_Empty_List
     (Node : access Base_List_Type)
      return Boolean
   is
     (Child_Count (GPR_Node (Node)) = 0);

   ------------------
   -- Destroy_Node --
   ------------------

   overriding procedure Destroy_Node
     (Node : access Base_List_Type)
   is
   begin
      if Langkit_Support.Extensions.Has_Extensions then
         Node.Free_Extensions;
      end if;
   end Destroy_Node;



   

   pragma Warnings (Off, "referenced");
   type Logic_Converter_Default is null record;
   No_Logic_Converter_Default : constant Logic_Converter_Default :=
     (null record);

   function Convert
     (Self : Logic_Converter_Default;
      From : Entity) return Entity
   is
      pragma Unreferenced (Self);
   begin
      Inc_Ref (From);
      return From;
   end Convert;

   type Equals_Data_Default is null record;
   No_Equals_Data_Default : constant Equals_Data_Default := (null record);

   function Eq_Default
     (Data : Equals_Data_Default; L, R : Entity) return Boolean
   is (Is_Equivalent (L, R))
      with Inline;
   pragma Warnings (On, "referenced");





       

   --
   --  Primitives for Abstract_Present
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Abstract_Present_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Abstract_Present;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Abstract_Present_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "AbstractPresent";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Abstract_Present_Type) return String
      is
         Class_Wide_Node : constant Abstract_Present := Abstract_Present (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Abstract_Present_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Abstract_Present_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Abstract_Present_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Abstract_Present := Abstract_Present (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");


      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Abstract_Present_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for Attribute_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Attribute_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Attribute_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Attribute_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "AttributeDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Attribute_Decl_Type) return String
      is
         Class_Wide_Node : constant Attribute_Decl := Attribute_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Attr_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attr_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Index)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Attribute_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Attribute_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attr_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Attr_Index);
                     Index_In_Bounds := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Expr);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Attribute_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Attribute_Decl := Attribute_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "attr_name:");
               if Node.F_Attr_Name /= null then
                  New_Line;
                  Node.F_Attr_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "attr_index:");
               if Node.F_Attr_Index /= null then
                  New_Line;
                  Node.F_Attr_Index.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "expr:");
               if Node.F_Expr /= null then
                  New_Line;
                  Node.F_Expr.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Attribute_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Attr_Name
        (Node : access Attribute_Decl_Type) return Identifier
      is
      begin
         return Node.F_Attr_Name;
      end F_Attr_Name;

      function F_Attr_Index
        (Node : access Attribute_Decl_Type) return GPR_Node
      is
      begin
         return Node.F_Attr_Index;
      end F_Attr_Index;

      function F_Expr
        (Node : access Attribute_Decl_Type) return Term_List
      is
      begin
         return Node.F_Expr;
      end F_Expr;



   


       

   --
   --  Primitives for Attribute_Reference
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Attribute_Reference_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Attribute_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Attribute_Reference_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "AttributeReference";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Attribute_Reference_Type) return String
      is
         Class_Wide_Node : constant Attribute_Reference := Attribute_Reference (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Attribute_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Index /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Index)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Attribute_Reference_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Attribute_Reference_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attribute_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Attribute_Index);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Attribute_Reference_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Attribute_Reference := Attribute_Reference (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "attribute_name:");
               if Node.F_Attribute_Name /= null then
                  New_Line;
                  Node.F_Attribute_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "attribute_index:");
               if Node.F_Attribute_Index /= null then
                  New_Line;
                  Node.F_Attribute_Index.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Attribute_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Attribute_Name
        (Node : access Attribute_Reference_Type) return Identifier
      is
      begin
         return Node.F_Attribute_Name;
      end F_Attribute_Name;

      function F_Attribute_Index
        (Node : access Attribute_Reference_Type) return GPR_Node
      is
      begin
         return Node.F_Attribute_Index;
      end F_Attribute_Index;



   


       

   --
   --  Primitives for Builtin_Function_Call
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Builtin_Function_Call_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Builtin_Function_Call;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Builtin_Function_Call_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "BuiltinFunctionCall";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Builtin_Function_Call_Type) return String
      is
         Class_Wide_Node : constant Builtin_Function_Call := Builtin_Function_Call (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Function_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Function_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Parameters /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Parameters)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Builtin_Function_Call_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Builtin_Function_Call_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Function_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Parameters);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Builtin_Function_Call_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Builtin_Function_Call := Builtin_Function_Call (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "function_name:");
               if Node.F_Function_Name /= null then
                  New_Line;
                  Node.F_Function_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "parameters:");
               if Node.F_Parameters /= null then
                  New_Line;
                  Node.F_Parameters.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Builtin_Function_Call_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Function_Name
        (Node : access Builtin_Function_Call_Type) return Identifier
      is
      begin
         return Node.F_Function_Name;
      end F_Function_Name;

      function F_Parameters
        (Node : access Builtin_Function_Call_Type) return Expr_List
      is
      begin
         return Node.F_Parameters;
      end F_Parameters;



   


       

   --
   --  Primitives for Case_Construction
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Case_Construction_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Case_Construction;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Case_Construction_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "CaseConstruction";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Case_Construction_Type) return String
      is
         Class_Wide_Node : constant Case_Construction := Case_Construction (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Var_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Ref)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Items /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Items)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Case_Construction_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Case_Construction_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Var_Ref);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Items);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Case_Construction_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Case_Construction := Case_Construction (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "var_ref:");
               if Node.F_Var_Ref /= null then
                  New_Line;
                  Node.F_Var_Ref.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "items:");
               if Node.F_Items /= null then
                  New_Line;
                  Node.F_Items.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Case_Construction_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Var_Ref
        (Node : access Case_Construction_Type) return Variable_Reference
      is
      begin
         return Node.F_Var_Ref;
      end F_Var_Ref;

      function F_Items
        (Node : access Case_Construction_Type) return Case_Item_List
      is
      begin
         return Node.F_Items;
      end F_Items;



   


       

   --
   --  Primitives for Case_Item
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Case_Item_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Case_Item;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Case_Item_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "CaseItem";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Case_Item_Type) return String
      is
         Class_Wide_Node : constant Case_Item := Case_Item (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Choice /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Choice)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Case_Item_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Case_Item_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Choice);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Decls);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Case_Item_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Case_Item := Case_Item (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "choice:");
               if Node.F_Choice /= null then
                  New_Line;
                  Node.F_Choice.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "decls:");
               if Node.F_Decls /= null then
                  New_Line;
                  Node.F_Decls.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Case_Item_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Choice
        (Node : access Case_Item_Type) return GPR_Node_List
      is
      begin
         return Node.F_Choice;
      end F_Choice;

      function F_Decls
        (Node : access Case_Item_Type) return GPR_Node_List
      is
      begin
         return Node.F_Decls;
      end F_Decls;



   


       

   --
   --  Primitives for Compilation_Unit
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Compilation_Unit_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Compilation_Unit;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Compilation_Unit_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "CompilationUnit";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Compilation_Unit_Type) return String
      is
         Class_Wide_Node : constant Compilation_Unit := Compilation_Unit (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Project /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Compilation_Unit_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Compilation_Unit_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Project);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Compilation_Unit_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Compilation_Unit := Compilation_Unit (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "project:");
               if Node.F_Project /= null then
                  New_Line;
                  Node.F_Project.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Compilation_Unit_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Project
        (Node : access Compilation_Unit_Type) return Project
      is
      begin
         return Node.F_Project;
      end F_Project;



   


       

   --
   --  Primitives for Empty_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Empty_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Empty_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Empty_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "EmptyDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Empty_Decl_Type) return String
      is
         Class_Wide_Node : constant Empty_Decl := Empty_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Empty_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Empty_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Empty_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Empty_Decl := Empty_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");


      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Empty_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for Expr
   --

   








   


       

   --
   --  Primitives for Prefix
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Prefix_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Prefix;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Prefix_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "Prefix";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Prefix_Type) return String
      is
         Class_Wide_Node : constant Prefix := Prefix (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Prefix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prefix)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Suffix /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Suffix)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Prefix_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Prefix_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prefix);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Suffix);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Prefix_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Prefix := Prefix (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "prefix:");
               if Node.F_Prefix /= null then
                  New_Line;
                  Node.F_Prefix.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "suffix:");
               if Node.F_Suffix /= null then
                  New_Line;
                  Node.F_Suffix.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Prefix_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Prefix
        (Node : access Prefix_Type) return Expr
      is
      begin
         return Node.F_Prefix;
      end F_Prefix;

      function F_Suffix
        (Node : access Prefix_Type) return Identifier
      is
      begin
         return Node.F_Suffix;
      end F_Suffix;



   


       

   --
   --  Primitives for Single_Tok_Node
   --

   






      function F_Tok
        (Node : access Single_Tok_Node_Type) return Token_Type
      is
      begin
         return Token (Node, Node.F_Tok);
      end F_Tok;



   


       

   --
   --  Primitives for Identifier
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Identifier_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Identifier;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Identifier_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "Id";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Identifier_Type) return String
      is
         Class_Wide_Node : constant Identifier := Identifier (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Identifier_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Identifier_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Identifier_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Identifier := Identifier (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put_Line
                 (Attr_Prefix & "tok: "
                  & Text (F_Tok (Node)));

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Identifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for Num_Literal
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Num_Literal_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Num_Literal;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Num_Literal_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "Num";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Num_Literal_Type) return String
      is
         Class_Wide_Node : constant Num_Literal := Num_Literal (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Num_Literal_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Num_Literal_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Num_Literal_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Num_Literal := Num_Literal (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put_Line
                 (Attr_Prefix & "tok: "
                  & Text (F_Tok (Node)));

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Num_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for String_Literal
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access String_Literal_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_String_Literal;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access String_Literal_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "Str";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access String_Literal_Type) return String
      is
         Class_Wide_Node : constant String_Literal := String_Literal (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");



                Append (Result, Image (Token (Node, Node.F_Tok)));


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access String_Literal_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access String_Literal_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access String_Literal_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant String_Literal := String_Literal (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put_Line
                 (Attr_Prefix & "tok: "
                  & Text (F_Tok (Node)));

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access String_Literal_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for Expr_List
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Expr_List_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Expr_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Expr_List_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "ExprList";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Expr_List_Type) return String
      is
         Class_Wide_Node : constant Expr_List := Expr_List (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Exprs /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Exprs)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Expr_List_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Expr_List_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Exprs);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Expr_List_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Expr_List := Expr_List (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "exprs:");
               if Node.F_Exprs /= null then
                  New_Line;
                  Node.F_Exprs.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Expr_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Exprs
        (Node : access Expr_List_Type) return Term_List_List
      is
      begin
         return Node.F_Exprs;
      end F_Exprs;



   


       

   --
   --  Primitives for Others_Designator
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Others_Designator_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Others_Designator;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Others_Designator_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "OthersDesignator";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Others_Designator_Type) return String
      is
         Class_Wide_Node : constant Others_Designator := Others_Designator (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Others_Designator_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 0;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Others_Designator_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
             pragma Unreferenced (Node);
             pragma Unreferenced (Result);
      begin
         case Index is
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Others_Designator_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Others_Designator := Others_Designator (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");


      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Others_Designator_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;









   


       

   --
   --  Primitives for Package_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Package_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Package_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "PackageDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Package_Decl_Type) return String
      is
         Class_Wide_Node : constant Package_Decl := Package_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Spec /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Spec)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Package_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Package_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Spec);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Package_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Package_Decl := Package_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "pkg_name:");
               if Node.F_Pkg_Name /= null then
                  New_Line;
                  Node.F_Pkg_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "pkg_spec:");
               if Node.F_Pkg_Spec /= null then
                  New_Line;
                  Node.F_Pkg_Spec.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Package_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Pkg_Name
        (Node : access Package_Decl_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;

      function F_Pkg_Spec
        (Node : access Package_Decl_Type) return GPR_Node
      is
      begin
         return Node.F_Pkg_Spec;
      end F_Pkg_Spec;



   


       

   --
   --  Primitives for Package_Extension
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Package_Extension_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Extension;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Package_Extension_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "PackageExtension";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Package_Extension_Type) return String
      is
         Class_Wide_Node : constant Package_Extension := Package_Extension (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Package_Extension_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Package_Extension_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Package_Extension_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Package_Extension := Package_Extension (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "prj_name:");
               if Node.F_Prj_Name /= null then
                  New_Line;
                  Node.F_Prj_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "pkg_name:");
               if Node.F_Pkg_Name /= null then
                  New_Line;
                  Node.F_Pkg_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Package_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Prj_Name
        (Node : access Package_Extension_Type) return Identifier
      is
      begin
         return Node.F_Prj_Name;
      end F_Prj_Name;

      function F_Pkg_Name
        (Node : access Package_Extension_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;



   


       

   --
   --  Primitives for Package_Renaming
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Package_Renaming_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Renaming;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Package_Renaming_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "PackageRenaming";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Package_Renaming_Type) return String
      is
         Class_Wide_Node : constant Package_Renaming := Package_Renaming (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Prj_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Prj_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Pkg_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Pkg_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Package_Renaming_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Package_Renaming_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Prj_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Pkg_Name);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Package_Renaming_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Package_Renaming := Package_Renaming (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "prj_name:");
               if Node.F_Prj_Name /= null then
                  New_Line;
                  Node.F_Prj_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "pkg_name:");
               if Node.F_Pkg_Name /= null then
                  New_Line;
                  Node.F_Pkg_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Package_Renaming_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Prj_Name
        (Node : access Package_Renaming_Type) return Identifier
      is
      begin
         return Node.F_Prj_Name;
      end F_Prj_Name;

      function F_Pkg_Name
        (Node : access Package_Renaming_Type) return Identifier
      is
      begin
         return Node.F_Pkg_Name;
      end F_Pkg_Name;



   


       

   --
   --  Primitives for Package_Spec
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Package_Spec_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Package_Spec;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Package_Spec_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "PackageSpec";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Package_Spec_Type) return String
      is
         Class_Wide_Node : constant Package_Spec := Package_Spec (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Package_Spec_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Package_Spec_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Extension);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Decls);
                     Index_In_Bounds := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Package_Spec_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Package_Spec := Package_Spec (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "extension:");
               if Node.F_Extension /= null then
                  New_Line;
                  Node.F_Extension.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "decls:");
               if Node.F_Decls /= null then
                  New_Line;
                  Node.F_Decls.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "end_name:");
               if Node.F_End_Name /= null then
                  New_Line;
                  Node.F_End_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Package_Spec_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Extension
        (Node : access Package_Spec_Type) return Package_Extension
      is
      begin
         return Node.F_Extension;
      end F_Extension;

      function F_Decls
        (Node : access Package_Spec_Type) return GPR_Node_List
      is
      begin
         return Node.F_Decls;
      end F_Decls;

      function F_End_Name
        (Node : access Package_Spec_Type) return Identifier
      is
      begin
         return Node.F_End_Name;
      end F_End_Name;



   


       

   --
   --  Primitives for Project
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Project_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Project_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "Project";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Project_Type) return String
      is
         Class_Wide_Node : constant Project := Project (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Context_Clauses /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Context_Clauses)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Decl /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Decl)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Project_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Project_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Context_Clauses);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Project_Decl);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Project_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Project := Project (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "context_clauses:");
               if Node.F_Context_Clauses /= null then
                  New_Line;
                  Node.F_Context_Clauses.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "project_decl:");
               if Node.F_Project_Decl /= null then
                  New_Line;
                  Node.F_Project_Decl.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Project_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Context_Clauses
        (Node : access Project_Type) return With_Decl_List
      is
      begin
         return Node.F_Context_Clauses;
      end F_Context_Clauses;

      function F_Project_Decl
        (Node : access Project_Type) return Project_Declaration
      is
      begin
         return Node.F_Project_Decl;
      end F_Project_Decl;



   


       

   --
   --  Primitives for Project_Declaration
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Project_Declaration_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Declaration;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Project_Declaration_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "ProjectDeclaration";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Project_Declaration_Type) return String
      is
         Class_Wide_Node : constant Project_Declaration := Project_Declaration (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Project_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Project_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Extension /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Extension)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Decls /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Decls)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_End_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_End_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Project_Declaration_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 5;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Project_Declaration_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Project_Name);
                     Index_In_Bounds := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Extension);
                     Index_In_Bounds := True;
                 when 4 =>
                     Result := GPR_Node (Node.F_Decls);
                     Index_In_Bounds := True;
                 when 5 =>
                     Result := GPR_Node (Node.F_End_Name);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Project_Declaration_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Project_Declaration := Project_Declaration (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "qualifier:");
               if Node.F_Qualifier /= null then
                  New_Line;
                  Node.F_Qualifier.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "project_name:");
               if Node.F_Project_Name /= null then
                  New_Line;
                  Node.F_Project_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "extension:");
               if Node.F_Extension /= null then
                  New_Line;
                  Node.F_Extension.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "decls:");
               if Node.F_Decls /= null then
                  New_Line;
                  Node.F_Decls.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "end_name:");
               if Node.F_End_Name /= null then
                  New_Line;
                  Node.F_End_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Project_Declaration_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Qualifier
        (Node : access Project_Declaration_Type) return Project_Qualifier
      is
      begin
         return Node.F_Qualifier;
      end F_Qualifier;

      function F_Project_Name
        (Node : access Project_Declaration_Type) return Expr
      is
      begin
         return Node.F_Project_Name;
      end F_Project_Name;

      function F_Extension
        (Node : access Project_Declaration_Type) return Project_Extension
      is
      begin
         return Node.F_Extension;
      end F_Extension;

      function F_Decls
        (Node : access Project_Declaration_Type) return GPR_Node_List
      is
      begin
         return Node.F_Decls;
      end F_Decls;

      function F_End_Name
        (Node : access Project_Declaration_Type) return Expr
      is
      begin
         return Node.F_End_Name;
      end F_End_Name;



   


       

   --
   --  Primitives for Project_Extension
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Project_Extension_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Extension;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Project_Extension_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "ProjectExtension";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Project_Extension_Type) return String
      is
         Class_Wide_Node : constant Project_Extension := Project_Extension (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_All));

                 Append (Result, ", ");

                 if Node.F_Path_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Name)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Project_Extension_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Project_Extension_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Path_Name);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Project_Extension_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Project_Extension := Project_Extension (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put_Line (Attr_Prefix & "is_all: "
                         & Image (Node.F_Is_All));
               Put (Attr_Prefix & "path_name:");
               if Node.F_Path_Name /= null then
                  New_Line;
                  Node.F_Path_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Project_Extension_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Is_All
        (Node : access Project_Extension_Type) return Boolean
      is
      begin
         return Node.F_Is_All;
      end F_Is_All;

      function F_Path_Name
        (Node : access Project_Extension_Type) return String_Literal
      is
      begin
         return Node.F_Path_Name;
      end F_Path_Name;



   


       

   --
   --  Primitives for Project_Qualifier
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Project_Qualifier_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Qualifier;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Project_Qualifier_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "ProjectQualifier";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Project_Qualifier_Type) return String
      is
         Class_Wide_Node : constant Project_Qualifier := Project_Qualifier (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Qualifier /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Project_Qualifier_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Project_Qualifier_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Project_Qualifier_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Project_Qualifier := Project_Qualifier (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "qualifier:");
               if Node.F_Qualifier /= null then
                  New_Line;
                  Node.F_Qualifier.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Project_Qualifier_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Qualifier
        (Node : access Project_Qualifier_Type) return GPR_Node
      is
      begin
         return Node.F_Qualifier;
      end F_Qualifier;



   


       

   --
   --  Primitives for Project_Reference
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Project_Reference_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Project_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Project_Reference_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "ProjectReference";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Project_Reference_Type) return String
      is
         Class_Wide_Node : constant Project_Reference := Project_Reference (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Attr_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attr_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Project_Reference_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Project_Reference_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Attr_Ref);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Project_Reference_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Project_Reference := Project_Reference (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "attr_ref:");
               if Node.F_Attr_Ref /= null then
                  New_Line;
                  Node.F_Attr_Ref.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Project_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Attr_Ref
        (Node : access Project_Reference_Type) return Attribute_Reference
      is
      begin
         return Node.F_Attr_Ref;
      end F_Attr_Ref;



   


       

   --
   --  Primitives for Qualifier_Names
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Qualifier_Names_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Qualifier_Names;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Qualifier_Names_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "QualifierNames";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Qualifier_Names_Type) return String
      is
         Class_Wide_Node : constant Qualifier_Names := Qualifier_Names (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Qualifier_Id1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Qualifier_Id2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Qualifier_Id2)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Qualifier_Names_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Qualifier_Names_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Qualifier_Id1);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Qualifier_Id2);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Qualifier_Names_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Qualifier_Names := Qualifier_Names (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "qualifier_id1:");
               if Node.F_Qualifier_Id1 /= null then
                  New_Line;
                  Node.F_Qualifier_Id1.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "qualifier_id2:");
               if Node.F_Qualifier_Id2 /= null then
                  New_Line;
                  Node.F_Qualifier_Id2.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Qualifier_Names_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Qualifier_Id1
        (Node : access Qualifier_Names_Type) return Identifier
      is
      begin
         return Node.F_Qualifier_Id1;
      end F_Qualifier_Id1;

      function F_Qualifier_Id2
        (Node : access Qualifier_Names_Type) return Identifier
      is
      begin
         return Node.F_Qualifier_Id2;
      end F_Qualifier_Id2;



   


       

   --
   --  Primitives for String_Literal_At
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access String_Literal_At_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_String_Literal_At;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access String_Literal_At_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "StringLiteralAt";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access String_Literal_At_Type) return String
      is
         Class_Wide_Node : constant String_Literal_At := String_Literal_At (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Str_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Str_Lit)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_At_Lit /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_At_Lit)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access String_Literal_At_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access String_Literal_At_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Str_Lit);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_At_Lit);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access String_Literal_At_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant String_Literal_At := String_Literal_At (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "str_lit:");
               if Node.F_Str_Lit /= null then
                  New_Line;
                  Node.F_Str_Lit.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "at_lit:");
               if Node.F_At_Lit /= null then
                  New_Line;
                  Node.F_At_Lit.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access String_Literal_At_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Str_Lit
        (Node : access String_Literal_At_Type) return String_Literal
      is
      begin
         return Node.F_Str_Lit;
      end F_Str_Lit;

      function F_At_Lit
        (Node : access String_Literal_At_Type) return Num_Literal
      is
      begin
         return Node.F_At_Lit;
      end F_At_Lit;



   


       

   --
   --  Primitives for Term_List
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Term_List_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Term_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Term_List_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "TermList";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Term_List_Type) return String
      is
         Class_Wide_Node : constant Term_List := Term_List (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Terms /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Terms)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Term_List_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Term_List_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Terms);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Term_List_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Term_List := Term_List (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "terms:");
               if Node.F_Terms /= null then
                  New_Line;
                  Node.F_Terms.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Term_List_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Terms
        (Node : access Term_List_Type) return GPR_Node_List
      is
      begin
         return Node.F_Terms;
      end F_Terms;



   


       

   --
   --  Primitives for Typed_String_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Typed_String_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Typed_String_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Typed_String_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "TypedStringDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Typed_String_Decl_Type) return String
      is
         Class_Wide_Node : constant Typed_String_Decl := Typed_String_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Type_Id /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Type_Id)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_String_Literals /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_String_Literals)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Typed_String_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 2;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Typed_String_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Type_Id);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_String_Literals);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Typed_String_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Typed_String_Decl := Typed_String_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "type_id:");
               if Node.F_Type_Id /= null then
                  New_Line;
                  Node.F_Type_Id.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "string_literals:");
               if Node.F_String_Literals /= null then
                  New_Line;
                  Node.F_String_Literals.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Typed_String_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Type_Id
        (Node : access Typed_String_Decl_Type) return Identifier
      is
      begin
         return Node.F_Type_Id;
      end F_Type_Id;

      function F_String_Literals
        (Node : access Typed_String_Decl_Type) return String_Literal_List
      is
      begin
         return Node.F_String_Literals;
      end F_String_Literals;



   


       

   --
   --  Primitives for Variable_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Variable_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Variable_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Variable_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "VariableDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Variable_Decl_Type) return String
      is
         Class_Wide_Node : constant Variable_Decl := Variable_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Var_Name /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Name)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Var_Type /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Var_Type)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Expr /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Expr)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Variable_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Variable_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Var_Name);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Var_Type);
                     Index_In_Bounds := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Expr);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Variable_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Variable_Decl := Variable_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "var_name:");
               if Node.F_Var_Name /= null then
                  New_Line;
                  Node.F_Var_Name.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "var_type:");
               if Node.F_Var_Type /= null then
                  New_Line;
                  Node.F_Var_Type.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "expr:");
               if Node.F_Expr /= null then
                  New_Line;
                  Node.F_Expr.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Variable_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Var_Name
        (Node : access Variable_Decl_Type) return Identifier
      is
      begin
         return Node.F_Var_Name;
      end F_Var_Name;

      function F_Var_Type
        (Node : access Variable_Decl_Type) return Expr
      is
      begin
         return Node.F_Var_Type;
      end F_Var_Type;

      function F_Expr
        (Node : access Variable_Decl_Type) return Term_List
      is
      begin
         return Node.F_Expr;
      end F_Expr;



   


       

   --
   --  Primitives for Variable_Reference
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Variable_Reference_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_Variable_Reference;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Variable_Reference_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "VariableReference";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access Variable_Reference_Type) return String
      is
         Class_Wide_Node : constant Variable_Reference := Variable_Reference (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");


                 if Node.F_Variable_Name1 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name1)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Variable_Name2 /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Variable_Name2)));

                 else
                    Append (Result, "None");
                 end if;
                 Append (Result, ", ");

                 if Node.F_Attribute_Ref /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Attribute_Ref)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access Variable_Reference_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 3;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access Variable_Reference_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Variable_Name1);
                     Index_In_Bounds := True;
                 when 2 =>
                     Result := GPR_Node (Node.F_Variable_Name2);
                     Index_In_Bounds := True;
                 when 3 =>
                     Result := GPR_Node (Node.F_Attribute_Ref);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access Variable_Reference_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant Variable_Reference := Variable_Reference (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put (Attr_Prefix & "variable_name1:");
               if Node.F_Variable_Name1 /= null then
                  New_Line;
                  Node.F_Variable_Name1.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "variable_name2:");
               if Node.F_Variable_Name2 /= null then
                  New_Line;
                  Node.F_Variable_Name2.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;
               Put (Attr_Prefix & "attribute_ref:");
               if Node.F_Attribute_Ref /= null then
                  New_Line;
                  Node.F_Attribute_Ref.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access Variable_Reference_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Variable_Name1
        (Node : access Variable_Reference_Type) return Identifier
      is
      begin
         return Node.F_Variable_Name1;
      end F_Variable_Name1;

      function F_Variable_Name2
        (Node : access Variable_Reference_Type) return Identifier
      is
      begin
         return Node.F_Variable_Name2;
      end F_Variable_Name2;

      function F_Attribute_Ref
        (Node : access Variable_Reference_Type) return Attribute_Reference
      is
      begin
         return Node.F_Attribute_Ref;
      end F_Attribute_Ref;



   


       

   --
   --  Primitives for With_Decl
   --

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access With_Decl_Type) return GPR_Node_Kind_Type
      is
         pragma Unreferenced (Node);
      begin
         return GPR_With_Decl;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access With_Decl_Type) return String
      is
         pragma Unreferenced (Node);
      begin
         return "WithDecl";
      end Kind_Name;


      -----------
      -- Image --
      -----------

      overriding function Image
        (Node : access With_Decl_Type) return String
      is
         Class_Wide_Node : constant With_Decl := With_Decl (Node);
         Result          : Unbounded_String;
      begin
         Append (Result, Class_Wide_Node.Kind_Name);
         Append (Result, '[');
         Append (Result, Image (Node.Sloc_Range));
         Append (Result, "](");



                Append (Result, Image (Node.F_Is_Limited));

                 Append (Result, ", ");

                 if Node.F_Path_Names /= null then

                Append (Result,
                        Image (GPR_Node (Node.F_Path_Names)));

                 else
                    Append (Result, "None");
                 end if;

         Append (Result, ')');
         return To_String (Result);
      end Image;

      -----------------
      -- Child_Count --
      -----------------

      overriding function Child_Count
        (Node : access With_Decl_Type) return Natural
      is
         pragma Unreferenced (Node);
      begin
         return 1;
      end Child_Count;

      ---------------
      -- Get_Child --
      ---------------

      overriding procedure Get_Child
        (Node            : access With_Decl_Type;
         Index           : Positive;
         Index_In_Bounds : out Boolean;
         Result          : out GPR_Node)
      is
      begin
         case Index is
                 when 1 =>
                     Result := GPR_Node (Node.F_Path_Names);
                     Index_In_Bounds := True;
             when others =>
                Index_In_Bounds := False;
                Result := null;
         end case;
      end Get_Child;

      -----------
      -- Print --
      -----------

      overriding procedure Print
        (Node        : access With_Decl_Type;
         Line_Prefix : String := "")
      is
         Class_Wide_Node : constant With_Decl := With_Decl (Node);
         Attr_Prefix     : constant String := Line_Prefix & "|";
         Children_Prefix : constant String := Line_Prefix & "|  ";
      begin
         Put_Line
           (Line_Prefix & Class_Wide_Node.Kind_Name
            & "[" & Image (Node.Sloc_Range) & "]");

               Put_Line (Attr_Prefix & "is_limited: "
                         & Image (Node.F_Is_Limited));
               Put (Attr_Prefix & "path_names:");
               if Node.F_Path_Names /= null then
                  New_Line;
                  Node.F_Path_Names.Print (Children_Prefix);
               else
                  Put_Line (" <null>");
               end if;

      end Print;


      ------------------
      -- Destroy_Node --
      ------------------

      overriding procedure Destroy_Node
        (Node : access With_Decl_Type)
      is
      begin
         if Langkit_Support.Extensions.Has_Extensions then
            Node.Free_Extensions;
         end if;
      end Destroy_Node;







      function F_Is_Limited
        (Node : access With_Decl_Type) return Boolean
      is
      begin
         return Node.F_Is_Limited;
      end F_Is_Limited;

      function F_Path_Names
        (Node : access With_Decl_Type) return String_Literal_List
      is
      begin
         return Node.F_Path_Names;
      end F_Path_Names;



   



         

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Case_Item_List_Type) return GPR_Node_Kind_Type
      is
      begin
         return GPR_Case_Item_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Case_Item_List_Type) return String
      is
      begin
         return "CaseItemList";
      end Kind_Name;


   ---------
   -- Get --
   ---------

   function Get
     (Node    : access Case_Item_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return Case_Item
   is
      function Absolute_Get
        (L : Case_Item_List; Index : Integer)
         return Case_Item
      is
        (Case_Item (L.Nodes (Index + 1)));
      --  L.Nodes is 1-based but Index is 0-based

      function Length (Node : Case_Item_List) return Natural is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Case_Item,
         Sequence_Type => Case_Item_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Case_Item;
   begin
      if Relative_Get (Case_Item_List (Node), Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;

   ----------
   -- Item --
   ----------

   function Item
     (Node  : access Case_Item_List_Type; Index : Positive) return Case_Item
   is (Case_Item (Node.Child (Index)));

   ------------
   -- Length --
   ------------

   function Length (Node : access Case_Item_List_Type'Class) return Natural
   is (Node.Child_Count);

         

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access GPR_Node_List_Type) return GPR_Node_Kind_Type
      is
      begin
         return GPR_GPR_Node_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access GPR_Node_List_Type) return String
      is
      begin
         return "GPRNodeList";
      end Kind_Name;


   ---------
   -- Get --
   ---------

   function Get
     (Node    : access GPR_Node_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return GPR_Node
   is
      function Absolute_Get
        (L : GPR_Node_List; Index : Integer)
         return GPR_Node
      is
        (GPR_Node (L.Nodes (Index + 1)));
      --  L.Nodes is 1-based but Index is 0-based

      function Length (Node : GPR_Node_List) return Natural is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => GPR_Node,
         Sequence_Type => GPR_Node_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : GPR_Node;
   begin
      if Relative_Get (GPR_Node_List (Node), Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;

   ----------
   -- Item --
   ----------

   function Item
     (Node  : access GPR_Node_List_Type; Index : Positive) return GPR_Node
   is (GPR_Node (Node.Child (Index)));

   ------------
   -- Length --
   ------------

   function Length (Node : access GPR_Node_List_Type'Class) return Natural
   is (Node.Child_Count);

         

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access String_Literal_List_Type) return GPR_Node_Kind_Type
      is
      begin
         return GPR_String_Literal_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access String_Literal_List_Type) return String
      is
      begin
         return "StringLiteralList";
      end Kind_Name;


   ---------
   -- Get --
   ---------

   function Get
     (Node    : access String_Literal_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return String_Literal
   is
      function Absolute_Get
        (L : String_Literal_List; Index : Integer)
         return String_Literal
      is
        (String_Literal (L.Nodes (Index + 1)));
      --  L.Nodes is 1-based but Index is 0-based

      function Length (Node : String_Literal_List) return Natural is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => String_Literal,
         Sequence_Type => String_Literal_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : String_Literal;
   begin
      if Relative_Get (String_Literal_List (Node), Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;

   ----------
   -- Item --
   ----------

   function Item
     (Node  : access String_Literal_List_Type; Index : Positive) return String_Literal
   is (String_Literal (Node.Child (Index)));

   ------------
   -- Length --
   ------------

   function Length (Node : access String_Literal_List_Type'Class) return Natural
   is (Node.Child_Count);

         

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access Term_List_List_Type) return GPR_Node_Kind_Type
      is
      begin
         return GPR_Term_List_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access Term_List_List_Type) return String
      is
      begin
         return "TermListList";
      end Kind_Name;


   ---------
   -- Get --
   ---------

   function Get
     (Node    : access Term_List_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return Term_List
   is
      function Absolute_Get
        (L : Term_List_List; Index : Integer)
         return Term_List
      is
        (Term_List (L.Nodes (Index + 1)));
      --  L.Nodes is 1-based but Index is 0-based

      function Length (Node : Term_List_List) return Natural is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => Term_List,
         Sequence_Type => Term_List_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Term_List;
   begin
      if Relative_Get (Term_List_List (Node), Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;

   ----------
   -- Item --
   ----------

   function Item
     (Node  : access Term_List_List_Type; Index : Positive) return Term_List
   is (Term_List (Node.Child (Index)));

   ------------
   -- Length --
   ------------

   function Length (Node : access Term_List_List_Type'Class) return Natural
   is (Node.Child_Count);

         

   



      ----------
      -- Kind --
      ----------

      overriding function Kind
        (Node : access With_Decl_List_Type) return GPR_Node_Kind_Type
      is
      begin
         return GPR_With_Decl_List;
      end Kind;

      ---------------
      -- Kind_Name --
      ---------------

      overriding function Kind_Name
        (Node : access With_Decl_List_Type) return String
      is
      begin
         return "WithDeclList";
      end Kind_Name;


   ---------
   -- Get --
   ---------

   function Get
     (Node    : access With_Decl_List_Type'Class;
      Index   : Integer;
      Or_Null : Boolean := False) return With_Decl
   is
      function Absolute_Get
        (L : With_Decl_List; Index : Integer)
         return With_Decl
      is
        (With_Decl (L.Nodes (Index + 1)));
      --  L.Nodes is 1-based but Index is 0-based

      function Length (Node : With_Decl_List) return Natural is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Relative_Get is new Langkit_Support.Relative_Get
        (Item_Type     => With_Decl,
         Sequence_Type => With_Decl_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : With_Decl;
   begin
      if Relative_Get (With_Decl_List (Node), Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         raise Property_Error with "out-of-bounds AST list access";
      end if;
   end Get;

   ----------
   -- Item --
   ----------

   function Item
     (Node  : access With_Decl_List_Type; Index : Positive) return With_Decl
   is (With_Decl (Node.Child (Index)));

   ------------
   -- Length --
   ------------

   function Length (Node : access With_Decl_List_Type'Class) return Natural
   is (Node.Child_Count);


   --------------------------
   -- Register_Destroyable --
   --------------------------

   procedure Register_Destroyable
     (Unit : Analysis_Unit; Node : GPR_Node)
   is
      procedure Helper is new Register_Destroyable_Gen
        (GPR_Node_Type'Class,
         GPR_Node,
         Destroy_Synthetic_Node);
   begin
      Helper (Unit, Node);
   end Register_Destroyable;

   ----------------------------
   -- Destroy_Synthetic_Node --
   ----------------------------

   procedure Destroy_Synthetic_Node (Node : in out GPR_Node) is
      procedure Free is new Ada.Unchecked_Deallocation
        (GPR_Node_Type'Class, GPR_Node);
   begin
      Node.Destroy_Node;
      Free (Node);
   end Destroy_Synthetic_Node;

   -----------
   -- Image --
   -----------

   function Image (Value : Boolean) return String
   is (if Value then "True" else "False");

end GPR_Parser.Analysis;
