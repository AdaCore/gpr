# This bit is used to make sure we don't run too many pipelines:
# don't run the branch CI when a merge request is already open for the
# branch.
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"
      when: never
    - when: always

variables:
   GIT_CLONE_BASE: https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}:${CI_SERVER_PORT}
   SANDBOX: /it/wave
   HOST: x86_64-linux
   ANOD_DEFAULT_SANDBOX_DIR: /it/wave

stages:
  - build
  - test
  - post

# This step defines bash functions that are shared between jobs.
# Note: before_script at toplevel is always executed, unless overriden by the
# various stages, so please don't !

default:
  before_script: |
    echo "before script executing..."

    #######################
    ## colored execution ##
    #######################

    exec() {
       # dark green + $ + command line + grey
       echo -e "\e[0;32m\$ $@\e[0;37m"
       $@
       # save the result
       res=$?
       # back to normal output
       echo -e -n "\e[0m"
       # make sure we translate the exit code
       return $res
    }

    ########################
    ## SETUP REPOSITORIES ##
    ########################

    setup_repos() {
      # clone subprojects and ensure anod uses them.
      # input: the list of subprojects to clone

      # make sure we use the local branch as gpr2 repo
      exec anod vcs --add-repo gpr2 $CI_PROJECT_DIR

      # ??? Following steps are workarounds waiting for a proper handling of
      # commits dependencies between repositories. This ensures that the latest
      # version of anod scripts and list given as input are used instead of the
      # latest nightly build versions.

      # Use latest anod
      cd /tmp
      exec git clone $GIT_CLONE_BASE/eng/it/anod
      exec anod tune --anod /tmp/anod

      # Setup the anod vcs for all subprojects.
      cd /tmp
      for subproject in $@; do
        exec git clone $GIT_CLONE_BASE/eng/gpr/$subproject
        if [ "$subproject" = "gprbuild-internal" ]; then
          anod_repo=gprbuild_testsuite
        else
          anod_repo=$subproject
        fi
        exec anod vcs --add-repo $anod_repo /tmp/$subproject
      done
      # print final status, for record
      exec anod vcs --list
    }

    #########################
    # PACKAGES INSTALLATION #
    #########################

    install_packages() {
      # input: a list of packages to install in anod

      cd $SANDBOX
      exec mkdir -p fingerprints
      for pkg in $@; do
        if [ $pkg = "gnat" -o $pkg = "gnatall" ]; then
          exec anod install $pkg
          exec tar zxf $CI_PROJECT_DIR/gprbuild.tar.gz -C $HOST/$pkg
        else
          exec mkdir -p $HOST/$pkg ;
          exec tar zxf $CI_PROJECT_DIR/$pkg.tar.gz -C $HOST/$pkg
        fi
        for json in install download-bin; do
          exec touch fingerprints/$HOST.$pkg.$json.json.assume-unchanged
        done
      done
      exec rm -f $CI_PROJECT_DIR/*.tar.gz
    }

    ######################
    # RUNNING TESTSUITES #
    ######################

    run_testsuite() {
      # inputs:
      # spec: the anod spec under test
      # quals: the qualifiers to use
      # xunit_name: the name under which the testsuite is reported to gitlab

      local spec=$1
      local quals=$2
      local xunit_name=$3

      # run the testsuite and extract its namespace
      exec anod test $spec $quals --minimal
      build_space=`anod eval $spec build_space_name $quals --primitive test`
      test_output="$(echo $xunit_name | sed -e 's/_//g')_result.xml"

      echo "generating result in $test_output"

      # translate e3 results into xunit results (and highlight it in yellow)
      echo -e "\e[1;34m"
      e3-testsuite-report \
        --failure-exit-code 1 \
        --xunit-output $CI_PROJECT_DIR/$test_output \
        --xunit-name $xunit_name \
        $SANDBOX/$HOST/$build_space/results/new/ || exit 1
      echo -e "\e[0m"
    }

################
# JOB TEMPLATE #
################

.job_template: &job_definition
  services:
     - image:sandbox
     - cpu:8
     - mem:16

.test_template: &test_definition
  <<: *job_definition
  stage: test
  allow_failure: true

###########
## BUILD ##
###########

build:
  <<: *job_definition
  stage: build
  script:
    # setup submodules
    - setup_repos gprbuild gprconfig_kb

    # Tune to use our build & test plan
    - anod tune --plan $CI_PROJECT_DIR/.ci.plan

    # Run a gnat bootstrap.
    # Note: we could take shortcuts here and just build the gprbuild package
    # but being able to run a full gnat bootstrap with the updated gpr tools is
    # part of our assurance that we don't provoque a disaster during the
    # nightly builds.
    - anod run build

    # generate packages to be used at test stages.
    # Note: we can't package the full gnat or gnatall install as the size seems
    # to reach some limits for the saved artifacts. So we package gprbuild and
    # co and will amend the toolchains for testing..
    - for pkg in gprbuild gpr2 libgpr2 gpr2-bindings gpr1build; do
        echo "packaging $SANDBOX/$HOST/$pkg/install/" ;
        tar czf $CI_PROJECT_DIR/$pkg.tar.gz -C $SANDBOX/$HOST/$pkg/ install/ ;
      done
    - cd $CI_PROJECT_DIR
    - ls -l *.tar.gz

  artifacts:
    paths:
      - gprbuild.tar.gz
      - gpr2.tar.gz
      - gpr2-bindings.tar.gz
      - libgpr2.tar.gz
      - gpr1build.tar.gz

####################
## GPR2 TESTSUITE ##
####################

test_gpr2:
  <<: *test_definition
  script:
    - setup_repos
    - install_packages gnat gpr2 libgpr2
    - run_testsuite gpr2 -Qfrom_gnat test_gpr2
  artifacts:
    when:
      always
    paths:
      - testgpr2_result.xml
    reports:
      junit: testgpr2_result.xml

##############
## COVERAGE ##
##############

test_gpr2_cov:
  <<: *test_definition
  script:
    - setup_repos
    - anod build gpr2 -Qcoverage
    # do a normal testsuite run but save the exit code instead of just exiting
    # so that coverage artifacts can be saved and used.
    - result=0
    - run_testsuite gpr2 -Qcoverage test_gpr2_cov || result=$?

    - mkdir $CI_PROJECT_DIR/coverage

    # save coverage results
    - cov_dir=$SANDBOX/$HOST/$build_space/results/new
    - mv $cov_dir/coverage-cobertura/cobertura.xml $CI_PROJECT_DIR/coverage/
    - mv $cov_dir/coverage-dhtml $CI_PROJECT_DIR/coverage/dhtml

    # display coverage stats for global reporting
    - echo_coverage_stats --coverage-file $cov_dir/coverage-xml/index.xml

    # report initial test status code
    - exit $result

  coverage: '/^Stmt Coverage:\s+(\d+\.\d+\%) \(\d+ \/ \d+\)$/'
  artifacts:
    when:
      always
    paths:
      - coverage/cobertura.xml
      - coverage/dhtml
      - testgpr2cov_result.xml
    reports:
      junit: testgpr2cov_result.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura.xml

########################
## GPRBUILD TESTSUITE ##
########################

test_gprbuild:
  <<: *test_definition
  script:
    - setup_repos gprbuild-internal
    - install_packages gnatall
    - run_testsuite gprbuild -QAdaCC++_Auto test_gprbuild
  artifacts:
    when:
      always
    paths:
      - testgprbuild_result.xml
    reports:
      junit: testgprbuild_result.xml

######################
## GPR2LS TESTSUITE ##
######################

test_gpr2ls:
  <<: *test_definition
  script:
    - setup_repos gprbuild-internal
    - install_packages gnatall gpr1build
    - run_testsuite gprbuild "-QAdaCC++_Auto -Qcheck-gpr2ls" test_gpr2ls
  artifacts:
    when:
      always
    paths:
      - testgpr2ls_result.xml
    reports:
      junit: testgpr2ls_result.xml

#############################
## GPR2 BINDINGS TESTSUITE ##
#############################

test_gpr2bindings:
  <<: *test_definition
  script:
    - setup_repos
    - install_packages gpr2-bindings

    - anod test gpr2-bindings --minimal
    # TODO: adjust this when this testsuite supports e3-testsuite-report
    - OUTPUT=$(sed $SANDBOX/$HOST/gpr2-bindings-test/results/results -e '/.*PASSED$/d' -e '/.*XFAIL$/d' -e '/^$/d')
    - if [ -n "$OUTPUT" ] ; then
         echo "the following tests fail:" ;
         echo "$OUTPUT" ;
         exit 1 ;
      fi

####################
## POSTPROCESSING ##
####################

post:
  <<: *job_definition
  stage: post
  when: always
  script:
    # generate badge
    - cd $CI_PROJECT_DIR
    - rm -f test-count.svg
    - if ls test*_result.xml &> /dev/null; then
        create_xunit_badge --xunit_reports test*_result.xml ;
      else
        anybadge -l "Tests Passing" -v "Error" -f test-count.svg -c red ;
      fi
  artifacts:
    when:
      always
    paths:
      - test-count.svg
